<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="STL,Associative Container," />





  <link rel="alternate" href="/rss2.xml" title="Jingxa's Blog" type="application/atom+xml" />






<meta name="description" content="本文章内容来源于《STL源码分析》第五章   1 概述 插入，删除，搜索都是常数时间 视为一种字典结构   问题：  array数组 索引 索引碰撞     负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；  2 ：解决办法：  线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；  二次探测：     开链    2 桶（buckets）和节点(nodes) hash">
<meta name="keywords" content="STL,Associative Container">
<meta property="og:type" content="article">
<meta property="og:title" content="STL_关联式容器_hashtable">
<meta property="og:url" content="https://jingxa.github.io/2018/07/08/STL-关联式容器-hashtable/index.html">
<meta property="og:site_name" content="Jingxa&#39;s Blog">
<meta property="og:description" content="本文章内容来源于《STL源码分析》第五章   1 概述 插入，删除，搜索都是常数时间 视为一种字典结构   问题：  array数组 索引 索引碰撞     负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；  2 ：解决办法：  线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；  二次探测：     开链    2 桶（buckets）和节点(nodes) hash">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5361608-ab2c47b3a5e91bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5361608-2b6d559944a935d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5361608-f9011c6bd0983d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5361608-318b1549c961b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5361608-fd77a7af5f9a037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-07-08T10:45:01.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL_关联式容器_hashtable">
<meta name="twitter:description" content="本文章内容来源于《STL源码分析》第五章   1 概述 插入，删除，搜索都是常数时间 视为一种字典结构   问题：  array数组 索引 索引碰撞     负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；  2 ：解决办法：  线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；  二次探测：     开链    2 桶（buckets）和节点(nodes) hash">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5361608-ab2c47b3a5e91bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Jingxa'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jingxa.github.io/2018/07/08/STL-关联式容器-hashtable/"/>





  <title>STL_关联式容器_hashtable | Jingxa's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jingxa's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">It's my precious!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jingxa.github.io/2018/07/08/STL-关联式容器-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jingxa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jingxa's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL_关联式容器_hashtable</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T18:44:01+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/08/STL-关联式容器-hashtable/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/07/08/STL-关联式容器-hashtable/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,183
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文章内容来源于《STL源码分析》第五章</p>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul>
<li>插入，删除，搜索都是常数时间</li>
<li>视为一种字典结构</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5361608-ab2c47b3a5e91bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>问题：</p>
<ol>
<li>array数组</li>
<li>索引<ul>
<li>索引碰撞</li>
</ul>
</li>
</ol>
<ul>
<li>负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；</li>
</ul>
<p>2 ：解决办法：</p>
<ul>
<li><p>线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-2b6d559944a935d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>二次探测：</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5361608-f9011c6bd0983d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><p>开链</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5361608-318b1549c961b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<h1 id="2-桶（buckets）和节点-nodes"><a href="#2-桶（buckets）和节点-nodes" class="headerlink" title="2 桶（buckets）和节点(nodes)"></a>2 桶（buckets）和节点(nodes)</h1><ul>
<li>hash table的表格元素为桶子；(表示可能为单个元素，或者一个list)</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5361608-fd77a7af5f9a037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="3-hashtable-实现"><a href="#3-hashtable-实现" class="headerlink" title="3 hashtable 实现"></a>3 hashtable 实现</h1><h2 id="3-1-hash-table-节点"><a href="#3-1-hash-table-节点" class="headerlink" title="3.1 hash table 节点"></a>3.1 hash table 节点</h2><pre><code>/**
    hash table 节点定义
    bucket维护的linked list，不采用stl的list或slist，而是维护
    上述的hash table node;
    bucket聚合体，以vector完成；
*/

template&lt;class Value&gt;
struct __hashtable_node{
    __hashtable_node* next;
    Value val;

};

</code></pre><h2 id="3-2-hashtable迭代器"><a href="#3-2-hashtable迭代器" class="headerlink" title="3.2 hashtable迭代器"></a>3.2 hashtable迭代器</h2><ul>
<li>hashtable的迭代器器没有后退操作，也没有双向迭代器</li>
</ul>
<pre><code>
/**
    hashtable 的迭代器
    hashtable的迭代器器没有后退操作，也没有双向迭代器
*/

template&lt;class Value, class Key, class HashFcn,
        class ExtratKey, class Equalkey, class Alloc&gt;
struct __hashtable_iterator{
    typedef hashtable&lt;Value, Key,HashFcn,ExtratKey,Equalkey,Alloc&gt;
        hashtable;

    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,
                                    Equalkey,Alloc&gt;  iterator;

    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,
                                    Equalkey,Alloc&gt;  const_iterator;

    typedef __hashtable_node&lt;Value&gt; node;

    typedef forward_iterator_tag  iterator_category;
    typedef    Value                   value_type;
    typedef ptrdiff_t              difference_type;
    typedef size_t                  size_type;
    typedef Value&amp;                   reference;
    typedef Value*                pointer;

    node* cur;   // 迭代器当前指向节点
    hashtable* ht; // 保持对容器的连接关系



    __hashtable_iterator(node* n, hashtable* tab):cur(n),ht(tab){}
    __hashtable_iterator(){}

    reference operator*()const {return cur-&gt;val;}
    pointer operator-&gt;() const {return &amp;(operator*());}


    // hashtable的迭代器器没有后退操作，也没有双向迭代器
    // 如果存在下一节点，直接next指针就可以；
    // 如果节点为list的尾端，就跳到下一个bucket，即指向下一个list的头部节点；
    iterator oprator++(){
        const node* old = cur;
        cur = cur-&gt;next; // 如果存在， 否则进入一下if
        if(! cur){
            // 根据元素值，定位下一个bucket，起始处就为答案
            size_type bucket = ht-&gt;bkt_num(old-&gt;val);
            while(!cur &amp;&amp; ++bucket &lt; ht-&gt;bucket.size()){
                cur = ht-&gt;buckets[bucket];
            }
            return *this;
        }
    }
    iterator operator++(int){
        iterator tmp = *this;
        ++*this;
        return tmp;
    }



    bool operator== (const iterator&amp; it){return cur == it.cur;}
    bool operator!= (const iterator&amp; it){return cur != it.cur;}
};

</code></pre><h2 id="3-3-hashtable数据结构"><a href="#3-3-hashtable数据结构" class="headerlink" title="3.3 hashtable数据结构"></a>3.3 hashtable数据结构</h2><h3 id="3-3-1-模板参数"><a href="#3-3-1-模板参数" class="headerlink" title="3.3.1 模板参数"></a>3.3.1 模板参数</h3><pre><code>    hashtable的数据结构
    Value: 实值
    Key: 键值
    HashFcn: hash function类型
    ExtratKey: 从节点中取出键值的方法
    Equalkey : 判断键值相同与否的方法
    Alloc: 空间配置；
</code></pre><h3 id="3-3-2-表格大小设计"><a href="#3-3-2-表格大小设计" class="headerlink" title="3.3.2 表格大小设计"></a>3.3.2 表格大小设计</h3><ul>
<li>开链法 </li>
<li>SGI用质数来设计表格大小，先计算28 个质数的值存放起来方便直接访问；</li>
<li>提供了一个函数，用来查询“最近并大于某数”的质数</li>
</ul>
<pre><code>/**
    开链法的表格大小预先设计
    sgi stl 以质数来设计表格大小，现将28个质数计算好，用来被查询

*/

static const int __stl_num_primes = 28;

static const unsigned long __stl_prime_list[__stl_num_primes] = 
{
    53，97， 193， 389， 769，
    ...
    ...
    ...  , 4294967291
}

// 一下用来找处28个质数中最近于n并大于n的质数
inline unsigned long __stl_next_prime(unsigned long n){
    const unsigned long* first = __stl_prime_list;
    const unsigned long* last = __stl_prime_list + __stl_num_primes;
    const unsigned long* pos = lower_bound(first,last,n); // 泛型算法，序列已排序
    return pos == last ? *(last -1):*pos;
}

size_type max_bucket_count() const{
    return __stl_prime_list[__stl_num_primes -1];
    // 最大值为4294967291
}
</code></pre><h3 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3.3.3 数据结构"></a>3.3.3 数据结构</h3><pre><code>template&lt;class Value, class Key, class HashFcn,
            class ExtratKey,class Equalkey, class Alloc = alloc&gt;
class hashtable{
public:
    typedef        HashFcn        hasher;   // 型别参数重新定义一个名字
    typedef        Equalkey    key_equal;    
    typedef        size_t        size_type;


private:

    // 以下三者都是函数对象 &lt;stl_hash_fun.h&gt;定义了数个
    // 标准型（如int,c-style string等）的hasher;
    hasher  hash;
    key_equal equals;
    ExtratKey  get_key;

    typedef        __hashtable_node&lt;Value&gt; node;
    typedef        simple_alloc&lt;node, Alloc&gt; node_allocator;


    vector&lt;node*, Alloc&gt; buckets;  // vector完成
    size_type    num_elements;

public:
    // bucket 个数 即 buckets vector的大小
    size_type  bucket_count() const {return buckets.size();}

...
</code></pre><h3 id="3-3-4-构造函数"><a href="#3-3-4-构造函数" class="headerlink" title="3.3.4  构造函数"></a>3.3.4  构造函数</h3><ul>
<li>hashtable没有默认构造函数,其中一个构造函数为：</li>
</ul>
<pre><code>
protected:
    node* new_node(const value_type&amp; obj){
        node* n = node_allocator::allocate();
        n-&gt;next = 0;
        __STL_TRY{
            construct(&amp;n-&gt;val, obj);
            return n;
        }
        __STL_UNWIND(node_allocator::deallocate(n));
    }


    void delete_node(node* n){
        destroy(&amp;n-&gt;val);
        node_allocator::deallocate(n);
    }

    // 初始构造 n个bunckets
    void iniitalize_buckets(size_type n){
        const size_type n_buckets = next_size(n);
        buckets.reserve(n_buckets);
        buckets.insert(buckets.end(),n_buckets,(node*)0);
        num_elements = 0;
    }

    // 就会最接近于n并且大于n的质数
    size_type next_size(size_type n) const {return __stl_next_prime(n);}



public:
    // hashtable没有默认构造函数
    hashtable&lt;size_type n, const HashFcn&amp; hf, const Equalkey&amp; eql)
        :hash(hf),equals(eql),get_key(ExtratKey()),num_elements(0){
            iniitalize_buckets(n);
        }
</code></pre><h3 id="3-3-5-插入操作和表格重建"><a href="#3-3-5-插入操作和表格重建" class="headerlink" title="3.3.5  插入操作和表格重建"></a>3.3.5  插入操作和表格重建</h3><ul>
<li><p>当客户端插入元素的时候，会判断是否需要重建表格</p>
</li>
<li><p>resize() ：表格重建判断</p>
</li>
</ul>
<pre><code>// 函数判断是否需要重建表示，如果不要，立刻返回，如果需要，就动手
    void resize(size_type num_elements_hint){
        // 判断方法： 元素个数和bucker vector个数比较
        // 如果前者大于后者，就重建
        // 每个list的最大容量 和bucket vector大小相同
        const size_type old_n = buckets.size();
        if(num_elements_hint &gt; old_n){   // 需要重新配置
            const size_type n = next_size(num_elements_hint);  // 新大小
            if(n &gt; old_n){
                vector&lt;node*, Alloc&gt;tmp(n, (node*)0);  // 设立新的buckets;
                __STL_TRY{
                    // 处理旧的bucket
                    for(size_type bucket = 0; bucket &lt; old_n;++bucket){
                        node* first = buckets[bucket];
                        // 处理每个bucket的list
                        while(first){
                            // 寻找节点落在哪一个bucket
                            size_type new_bucket =  bkt_num(first-&gt;val,n);
                            // (1) 令旧的bucket 指向下一个节点
                            buckets[bucket] = first-&gt;next;
                            //(2)(3)将当前节点插入到新bucket中,前插法
                            first-&gt;next = tmp[new_bucket];
                            tmp[new_bucket] = first;
                            //(4) 回到旧的bucket所指的list,准备处理下一个节点
                            first = buckets[bucket];
                        }
                    }
                    buckets.swap(tmp);  // vector::swap, 新旧两个bucket对换
                    // 对换后，如果大小不一样，大的会变小，小的会变大
                    // 离开后tmp释放
                }
            }

        }

    }

</code></pre><ul>
<li><p>插入操作：分为两种，一种允许重复，一种不允许重复</p>
<ul>
<li><code>insert_unique_noresize</code> ：不允许重复</li>
<li><code>insert_equal_noresize</code> :允许节点重复</li>
</ul>
</li>
<li><p>第一种情况</p>
</li>
</ul>
<pre><code>    // 插入元素，不允许重复
    pair&lt;iterator, bool&gt; insert_unique(const value_types obj){
        resize(num_elements +1);  // 判断是否需要重建表格，如果需要就重新扩充
        return insert_unique_noresize(obj);
    }
</code></pre><pre><code>    // 在不要建表格的情况下插入新节点，键值不允许重复
    pair&lt;iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){
        const size_type n = bkt_num(obj); // 决定obj的bucket位置
        node* first = buckets[n];

        // 如果buckets[n]已经被占用，此时first将不为0
        // 迭代到list最尾节点
        for(node* cur = first; cur; cur = cur-&gt;next){
            // 如果发现存在相同键值，就返回，不插入
            if(equals(get_key(cur-&gt;val), get_key(obj))
                return pair&lt;iterator,bool&gt;(iterator(cur,this),false);
        }

        node* tmp = new_node(obj);  // 产生新节点
        tmp-&gt;next = first;
        buckets[n] = tmp ;   // 前插法
        ++num_elements;
        return pair&lt;iterator,bool&gt; (iterator(tmp,this),true);
    }

</code></pre><ul>
<li>第二种情况</li>
</ul>
<pre><code>
    // 插入元素，允许重复
    iterator insert_equal(const value_type&amp; obj){
        resize(num_elements + 1);  // 判断是否重建表格
        return insert_equal_noresize(obj);
    }

</code></pre><pre><code>    iterator insert_equal_noresize(const value_type&amp; obj){
        const size_type n = bkt_num(obj);
        node* first = buckets[n] ; 

        for(node* cur = first; cur; cur = cur-&gt;next){
            if(equals(get_key(cur-&gt;val),get_key(obj)){
                // list中存在相同键值的实值，就马上插入，在返回
                node* tmp = new_node(obj);  // 新节点
                tmp-&gt;next = cur-&gt;next;
                cur-&gt;next = tmp;
                ++num_elements;
                return iterator(tmp, this);  // 返回
            }
        }

        // 未发现重复值，到达链表尾端
        node* tmp = new_node(obj);  // 新节点
        tmp-&gt;next = first;
        buckets[n] = tmp;
        ++num_elements;
        return iterator(tmp, this);  // 返回
    }
</code></pre><h3 id="3-3-6-复制和清除"><a href="#3-3-6-复制和清除" class="headerlink" title="3.3.6 复制和清除"></a>3.3.6 复制和清除</h3><ul>
<li>清除 <code>clear()</code></li>
</ul>
<pre><code>    void clear(){  // buckets空间为释放
        // 对每一个bucket
        for(size_type i=0; i&lt;buckets.size(); ++i){
            node* cur = bucket[i];
            // 将list每一个节点删除
            while(cur != 0){
                node* next = cur-&gt;next;
                delete_node(cur);
                cur = next;
            }
            bucket[i] = 0;  // bucket为NULL
        }
        num_elements = 0;  // 总数为0
    }
</code></pre><ul>
<li>复制</li>
</ul>
<pre><code>    void copy_from(const hashtable&amp; ht){
        // 先清除自己的buckets vector,调用vector::clear()
        buckets.clear();
        // 如果自己的空间大于对方，就不动，小于的话，增大
        buckets.reserve(ht.buckets.size());
        // 此时buckets为空，end()就是起头
        buckets.insert(buckets.end(),ht.buckets.size(), (node*)0);
        __STL_TRY{
            // 每个bucket
            for(size_type i=0 ;i&lt;ht.buckets.size(); ++i){
                // 每个bucket 开头
                if(const node* cur = ht.bucket[i]) {
                    node* cp = new_node(cur-&gt;val);
                    buckets[i] = cp;


                    // 每个bucket的list
                    for(node* next = cur-&gt;next; next; cur =next, next = cur-&gt;next){
                        cop -&gt;next = new_node(next-&gt;val);
                        cp = cp-&gt;next;
                    }
                }    
            }
            num_elements = ht.num_elements;
        }
        __STL_UNWIND(clear());
    }

</code></pre><h3 id="3-3-7-判断元素落脚"><a href="#3-3-7-判断元素落脚" class="headerlink" title="3.3.7 判断元素落脚"></a>3.3.7 判断元素落脚</h3><pre><code>
public:
    // 计算 元素的键值,即hashtable上的bucket序号

    // 版本1： 接受实值和buckets个数
    size_type bkt_num(const value_type&amp; obj, size_t n) const{
        return bkt_num_key(get_key(obj),n);  // 版本4
    }
    // 版本2： 只接受实值value
    size_type bkt_num(const value_type&amp; obj) const{
        return bkt_num_key(get_key(obj));   // 版本3
    }

    // 版本3： 只接受键值
    size_type bkt_num(const key_type&amp; key) const{
        return bkt_num_key(key,buckets.size());   // 版本4
    }

    // 版本4： 只接受键值和buckets个数
    size_type bkt_num(const key_type&amp; key，size_t n) const{
        return hash(key) % n; // SGI内建 hash()
    }
</code></pre><h1 id="4-hashtable的hash-function"><a href="#4-hashtable的hash-function" class="headerlink" title="4. hashtable的hash function"></a>4. hashtable的hash function</h1><ul>
<li>SGI的内置hash函数只针对了char,int,long等整数型别，而且都只是返回原值</li>
<li>只对<code>const char*</code>做了一个转换</li>
<li>因此无法处理string,double ,float等型别，</li>
<li>用户必须自定义hash function</li>
</ul>
<pre><code>/**
 hash function类型
 &lt;stl_hash_fun.h&gt;
*/




template&lt;class Key&gt;
struct hash{


};

inline size_t __stl_hash_string(const char* s){
    unsigned long  h =0;
    for(;*s;++s)
        h = 5*h + *s;
    return size_t(h);
}


// __STL_TAMPLATE_NULL 定义为template&lt;&gt; 在;&lt;stl_config.h&gt;中

__STL_TAMPLATE_NULL
struct hash&lt;char*&gt;{
    size_t operator()(char* s){
        return __stl_hash_string(s);
    }
}



__STL_TAMPLATE_NULL
struct hash&lt;const char*&gt;{
    size_t operator()(const char* s){
        return __stl_hash_string(s);
    }
}



__STL_TAMPLATE_NULL
struct hash&lt;char&gt;{
    size_t operator()(char s){
        return s;
    }
}


__STL_TAMPLATE_NULL
struct hash&lt;unsigned char&gt;{
    size_t operator()(unsigned char s){
        return s;
    }
}

__STL_TAMPLATE_NULL
struct hash&lt;signed char&gt;{
    size_t operator()(unsigned char s){
        return s;
    }
}

__STL_TAMPLATE_NULL
struct hash&lt;short&gt;{
    size_t operator()(short s){
        return s;
    }
}

__STL_TAMPLATE_NULL
struct hash&lt;unsigned short&gt;{
    size_t operator()(unsigned short s){
        return s;
    }
}


__STL_TAMPLATE_NULL
struct hash&lt;int&gt;{
    size_t operator()(int s){
        return s;
    }
}


__STL_TAMPLATE_NULL
struct hash&lt;unsigned int&gt;{
    size_t operator()( unsigned int s){
        return s;
    }
}


__STL_TAMPLATE_NULL
struct hash&lt;long&gt;{
    size_t operator()(long s){
        return s;
    }
}


__STL_TAMPLATE_NULL
struct hash&lt;unsigned long&gt;{
    size_t operator()( unsigned long s){
        return s;
    }
}

</code></pre><hr>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    jingxa
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jingxa.github.io/2018/07/08/STL-关联式容器-hashtable/" title="STL_关联式容器_hashtable">https://jingxa.github.io/2018/07/08/STL-关联式容器-hashtable/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/STL/" rel="tag"># STL</a>
          
            <a href="/tags/Associative-Container/" rel="tag"># Associative Container</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/07/STL-关联式容器-map/" rel="next" title="STL_关联式容器_map">
                <i class="fa fa-chevron-left"></i> STL_关联式容器_map
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/11/STL-仿函数/" rel="prev" title="STL_仿函数">
                STL_仿函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="jingxa" />
            
              <p class="site-author-name" itemprop="name">jingxa</p>
              <p class="site-description motion-element" itemprop="description">单影无人相依偎！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jingxa" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://jingxa.coding.me" target="_blank" title="Coding">
                      
                        <i class="fa fa-fw fa-globe"></i>Coding</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wjszwzyd@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kylingit.com/" title="诗与胡说" target="_blank">诗与胡说</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-概述"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-桶（buckets）和节点-nodes"><span class="nav-text">2 桶（buckets）和节点(nodes)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-hashtable-实现"><span class="nav-text">3 hashtable 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-hash-table-节点"><span class="nav-text">3.1 hash table 节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-hashtable迭代器"><span class="nav-text">3.2 hashtable迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-hashtable数据结构"><span class="nav-text">3.3 hashtable数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-模板参数"><span class="nav-text">3.3.1 模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-表格大小设计"><span class="nav-text">3.3.2 表格大小设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-数据结构"><span class="nav-text">3.3.3 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-构造函数"><span class="nav-text">3.3.4  构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-插入操作和表格重建"><span class="nav-text">3.3.5  插入操作和表格重建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-6-复制和清除"><span class="nav-text">3.3.6 复制和清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-7-判断元素落脚"><span class="nav-text">3.3.7 判断元素落脚</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-hashtable的hash-function"><span class="nav-text">4. hashtable的hash function</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jingxa</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">37.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'jingxa',
            repo: 'jingxa.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'a60429c86a4b7abb1e1d5d4fa11db0557eb2683a',
            
                client_id: 'a24135f240136ad4e4bb'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
