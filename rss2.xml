<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sun, 15 Jul 2018 09:26:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>MTProxy：专为Telegram打造的代理工具</title>
      <link>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <guid>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Sun, 15 Jul 2018 09:23:50 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://lala.im/3598.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lala.im/3598.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>转载自：<a href="https://lala.im/3598.html" target="_blank" rel="noopener">https://lala.im/3598.html</a></p></blockquote><hr><blockquote><p>记录一下操作</p></blockquote><hr><p>接着我们按键盘组合键Ctrl+C退出运行。<br>现在来创建一个系统服务，可以在往后更方便的管理和运行MTProxy。</p><p>新建服务文件：</p><pre><code>vi /etc/systemd/system/MTProxy.service</code></pre><p>写入：</p><pre><code>[Unit]Description=MTProxyAfter=network.target[Service]Type=simpleWorkingDirectory=/root/MTProxyExecStart=/root/MTProxy/objs/bin/mtproto-proxy -u nobody -p 8888 -H 2333 -S 密匙 --aes-pwd /root/MTProxy/objs/bin/proxy-secret /root/MTProxy/objs/bin/proxy-multi.conf -M 1Restart=on-failure[Install]WantedBy=multi-user.target</code></pre><p>注：</p><p>1、确保WorkingDirectory以及ExecStart内正确写明mtproto-proxy可执行文件的绝对路径。<br>以及指定proxy-secret、proxy-multi.conf的路径也是绝对路径。如果你是按照我的这篇文章来一字不动部署的，那么可以直接看第2点注意说明。</p><p>2、“密匙”改为之前你生成的密匙。</p><p>重加载，让新的服务文件生效：</p><pre><code>systemctl daemon-reload</code></pre><p>现在就可以启动MTProxy了：</p><pre><code>systemctl start MTProxy.service</code></pre><p>查看运行状态：</p><pre><code>systemctl status MTProxy.service</code></pre><p>如图所示是Active就说明MTProxy运行正常：</p><p><img src="https://lala.im/wp-content/uploads/2018/06/lala.im_2018-06-11-00-795.png" alt=""></p><p>把MTProxy设为开机启动：</p><pre><code>systemctl enable MTProxy.service</code></pre><p>停止MTProxy的运行：</p><pre><code>systemctl stop MTProxy.service</code></pre><p>OK，到这里，MTProxy的服务端就部署完成了，</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS131_Homework_2</title>
      <link>https://jingxa.github.io/2018/07/14/CS131-Homework-2/</link>
      <guid>https://jingxa.github.io/2018/07/14/CS131-Homework-2/</guid>
      <pubDate>Sat, 14 Jul 2018 11:07:30 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs131 hw2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;part-1-canny-Edge-Detector&quot;&gt;&lt;a href=&quot;#part-1-canny-Edge-Detector&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs131 hw2</p></blockquote><hr><h1 id="part-1-canny-Edge-Detector"><a href="#part-1-canny-Edge-Detector" class="headerlink" title="part 1 canny Edge Detector"></a>part 1 canny Edge Detector</h1><ul><li>canny 算子可以分为以下五步：<ul><li>Smoothing</li><li>Finding gradients</li><li>Non-maximum supperession</li><li>Double thredsholding</li><li>Edge tracking by hysterisis</li></ul></li></ul><h2 id="1-1-Smoothing"><a href="#1-1-Smoothing" class="headerlink" title="1.1 Smoothing"></a>1.1 Smoothing</h2><p>平滑一张图片，可以使用（Gaussian kernel）高斯核来卷积；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d9ecc61140d81a3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def conv(image, kernel):    Hi, Wi = image.shape    Hk, Wk = kernel.shape    out = np.zeros((Hi, Wi)).    pad_width0 = Hk // 2    pad_width1 = Wk // 2    pad_width = ((pad_width0,pad_width0),(pad_width1,pad_width1))    padded = np.pad(image, pad_width, mode=&#39;edge&#39;)    # 卷积过程    kernel = np.flip(np.flip(kernel, 0), 1)  # 上下翻转，在左右翻转    for i in range(Hi):        for j in range(Wi):            out[i, j] = np.sum(padded[i:(i + Hk), j:(j + Wk)] * kernel)    return outdef gaussian_kernel(size, sigma):    kernel = np.zeros((size, size))    # size = 2k+1    k = size // 2    for i in range(size):        for j in range(size):            kernel[i, j] = np.exp(-(((i-k)**2 + (j-k)**2))/2*sigma**2) / (2 * np.pi * (sigma**2))    return kernel</code></pre><p>输出为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8446400e3eb433ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>[问题] What is the effect of the kernel_size and sigma?</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c58b1092a531d5d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9aa6973c4104d788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>高斯核的sigma和size越大，就越模糊；</li></ul><hr><h2 id="1-2-Finding-gradients"><a href="#1-2-Finding-gradients" class="headerlink" title="1.2 Finding gradients"></a>1.2 Finding gradients</h2><h3 id="1-2-1-偏导数"><a href="#1-2-1-偏导数" class="headerlink" title="1.2.1 偏导数"></a>1.2.1 偏导数</h3><ul><li>图片的偏导数可以计算为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bcd31befb666ccfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>对于一张图片，我们需要给图片添加一层为0 的padding:</li></ul><pre><code>def partial_x(img):    out = None    # Hi, Wi = img.shape    # padd = np.zeros((Hi, Wi+2))    # padd[:, 1:Wi+1] = img    #    # out = np.zeros((Hi, Wi))    # for i in range(Wi):    #     out[:, i] = (padd[:, i+2] - padd[:, i]) / 2    # 使用卷积    kernel = np.array([[1, 0, -1]]) / 2    out = conv(img, kernel)    return outdef partial_y(img):    out = None    # Hi, Wi = img.shape    # padd = np.zeros((Hi + 2, Wi))    # padd[1:Hi+1, :] = img    #    # out = np.zeros((Hi, Wi))    # for i in range(Hi):    #     out[i, :] = (padd[i+2, :] - padd[i, :]) / 2    kernel = np.array([[1, 0, -1]]).T / 2    out = conv(img, kernel)    return out</code></pre><p>结果为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-364f1442bad2fc12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>[问题]：What is the reason for performing smoothing prior to computing the gradients?</li><li>在计算导数之前先进行smoothing,是为了降低噪声；</li></ul><h3 id="1-2-2-导数"><a href="#1-2-2-导数" class="headerlink" title="1.2.2 导数"></a>1.2.2 导数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-be899d6188d15932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Hint: Use np.arctan2 to compute</li><li>the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.)</li></ul><pre><code>def gradient(img):    G = np.zeros(img.shape)    theta = np.zeros(img.shape)    gx = partial_x(img)    gy = partial_y(img)    G = np.sqrt(gx**2 + gy**2)    theta = np.arctan2(gy, gx)  # (-pi/2, pi/2)    theta = (np.rad2deg(np.arctan2(gy, gx)) + 180) % 360    return G, theta</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-994c7f22bda0fd31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-3-Non-maximum-suppression"><a href="#1-3-Non-maximum-suppression" class="headerlink" title="1.3 Non - maximum suppression"></a>1.3 Non - maximum suppression</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f8507e47aeebd8e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在八个方向上[0,45,90,135,180,225,270,315]比较;</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ec4621ad6dad900f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def non_maximum_suppression(G, theta):    H, W = G.shape    out = np.zeros((H, W))    # Round the gradient direction to the nearest 45 degrees    theta = np.floor((theta + 22.5) / 45) * 45  # 方向定位    # 添加一层padding    padd = np.zeros((H+2,W +2))    padd[1:H+1, 1:W+1] = G    for m in range(1, H+1):        for n in range(1, W+1):            # 题目定义为顺时针方向，和逆时针相反,y方向相反            rad = np.deg2rad(theta[m-1, n-1])            i =int(np.around(np.sin(rad)))   # 行            j =int(np.around(np.cos(rad)))   # 列            p1 = padd[m+i, n+j]            p2 = padd[m-i, n-j]            if(padd[m, n] &gt; p1 and padd[m, n] &gt; p2): # 一个方向上                out[m-1, n-1] = padd[m, n]            else:                out[m-1, n-1] = 0    return out</code></pre><p>结果为：</p><pre><code>Thetas: 0[[0.  0.  0.6] [0.  0.  0.7] [0.  0.  0.6]]Thetas: 45[[0.  0.  0.6] [0.  0.  0.7] [0.4 0.5 0.6]]Thetas: 90[[0.4 0.  0. ] [0.  0.  0.7] [0.4 0.  0. ]]Thetas: 135[[0.4 0.5 0.6] [0.  0.  0.7] [0.  0.  0.6]]</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6f7d04485316dfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-4-Double-Thresholding"><a href="#1-4-Double-Thresholding" class="headerlink" title="1.4 Double Thresholding"></a>1.4 Double Thresholding</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-632e6d73905542c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-32612e1f72d9e762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>阈值假设：</li><li>定义两个阈值：low High</li><li>如果 小于low,不是一个边</li><li>如果大于High, 就是一条强边</li><li>如果在low和High之间，弱边</li></ul><p>使用 <code>np.where</code>:<a href="https://blog.csdn.net/sloanqin/article/details/51612618" target="_blank" rel="noopener">np.where</a></p><pre><code>def double_thresholding(img, high, low):    strong_edges = np.zeros(img.shape)    weak_edges = np.zeros(img.shape)    strong_edges = np.where(img&gt;=high,1,0)    weak_edges = np.where(img&gt;=low,1,0)    weak_edges = weak_edges-strong_edges    return strong_edges, weak_edges</code></pre><hr><h2 id="1-5-Edge-tracking"><a href="#1-5-Edge-tracking" class="headerlink" title="1.5 Edge tracking"></a>1.5 Edge tracking</h2><ul><li>strong edges : 确定的边</li><li>weak edges: 只有和strong edges相连的边才是正确的边， 其他的就是噪点；</li></ul><pre><code>def get_neighbors(y, x, H, W):    # 返回(y,x)周围等于(y,x)的邻居的坐标列表[(i,j),(i2,j2)..]    neighbors = []    for i in (y-1, y, y+1):        for j in (x-1, x, x+1):            if i &gt;= 0 and i &lt; H and j &gt;= 0 and j &lt; W:                if (i == y and j == x):                    continue                neighbors.append((i, j))    return neighborsdef link_edges(strong_edges, weak_edges):    # 寻找强边像素相连的弱边像素    H, W = strong_edges.shape    indices = np.stack(np.nonzero(strong_edges)).T    edges = np.zeros((H, W))    ### YOUR CODE HERE    edges = np.copy(strong_edges)    for i in range(1, H-1):        for j in range(1, W-1):            neighbors = get_neighbors(j, i, H, W)            if weak_edges[i, j] and np.any(edges[x, y] for x, y in neighbors):                edges[i, j] = True    ### END YOUR CODE    return edges</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-000d8d5790513651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-6-Canny-edge-detector"><a href="#1-6-Canny-edge-detector" class="headerlink" title="1.6 Canny edge detector"></a>1.6 Canny edge detector</h2><ul><li>实现canny算子</li></ul><pre><code>def canny(img, kernel_size=5, sigma=1.4, high=20, low=15):    ### YOUR CODE HERE    kernel = gaussian_kernel(kernel_size, sigma)  # 1. smoothing    smoothed = conv(img,kernel)    G, theta = gradient(smoothed)                 # 2. 梯度计算    nms = non_maximum_suppression(G,theta)        # 3. non-maximum_suppression    strong_edges, weak_edges = double_thresholding(nms, low,high) #double thresholding    edge = link_edges(strong_edges,weak_edges)    # link    ### END YOUR CODE    return edge</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c03f9c9fc21f90d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="Part-2-Lane-Detection"><a href="#Part-2-Lane-Detection" class="headerlink" title="Part 2 Lane Detection"></a>Part 2 Lane Detection</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7a261fb12aceb969.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>检测平面<br>算法：</li><li>使用canny算子检测边</li><li>提取兴趣区域的边</li><li>运行Hough transform  来检测平面</li></ul><h2 id="2-1-边检测"><a href="#2-1-边检测" class="headerlink" title="2.1 边检测"></a>2.1 边检测</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8f938b5f48dda00e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-Extracting-region-of-interest-ROI"><a href="#2-2-Extracting-region-of-interest-ROI" class="headerlink" title="2.2 Extracting region of interest (ROI)"></a>2.2 Extracting region of interest (ROI)</h2><ul><li>提取兴趣区域</li><li>使用一个二位掩码来定义兴趣区域；然后提取兴趣区域的边；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b234885744b5cd69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-3-Fitting-lines-using-Hough-transform"><a href="#2-3-Fitting-lines-using-Hough-transform" class="headerlink" title="2.3 Fitting lines using Hough transform"></a>2.3 Fitting lines using Hough transform</h2><ul><li>边检测的输出为连接点的集合；</li><li><p>使用hough变换来检测一条直线；</p></li><li><p>直线 y =ax + b 被表示为：(a,b),这种方式不能表示垂直线段；</p></li><li>因此，使用极方程表示：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-26385475a7a120de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1e7e069710553bb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def hough_transform(img):    &quot;&quot;&quot; Transform points in the input image into Hough space.    Use the parameterization:        rho = x * cos(theta) + y * sin(theta)    to transform a point (x,y) to a sine-like function in Hough space.    Args:        img: binary image of shape (H, W)    Returns:        accumulator: numpy array of shape (m, n)        rhos: numpy array of shape (m, )        thetas: numpy array of shape (n, )    &quot;&quot;&quot;    # Set rho and theta ranges    W, H = img.shape    diag_len = int(np.ceil(np.sqrt(W * W + H * H)))  # 对角线长度，np.ceil 向大取整    rhos = np.linspace(-diag_len, diag_len, diag_len * 2.0 + 1) # 2倍，等差数列    thetas = np.deg2rad(np.range(-90.0, 90.0))    # Cache some reusable values    cos_t = np.cos(thetas)    sin_t = np.sin(thetas)    num_thetas = len(thetas)    # Initialize accumulator in the Hough space    accumulator = np.zeros((2 * diag_len + 1, num_thetas), dtype=np.uint64)    ys, xs = np.nonzero(img)    # Transform each point (x, y) in image    # Find rho corresponding to values in thetas    # and increment the accumulator in the corresponding coordiate.    ### YOUR CODE HERE    for i, j in zip(ys, xs):        for idx in range(thetas.shape[0]):            r = j * cos_t[idx] + i * sin_t[idx]            accumulator[int(r + diag_len), idx] += 1    ### END YOUR CODE    return accumulator, rhos, thetas</code></pre><p>结果为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-9dc4fdd0fc83ed97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3 参考资料"></a>3 参考资料</h1><ol><li><a href="https://github.com/mikucy/CS131/tree/master/hw2_release" target="_blank" rel="noopener">mikucy/CS131</a></li><li><a href="https://github.com/wwdguu/CS131_homework/tree/master/hw2_release" target="_blank" rel="noopener">wwdguu/CS131_homework</a></li></ol><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/14/CS131-Homework-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_适配接器_2</title>
      <link>https://jingxa.github.io/2018/07/12/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-2/</link>
      <guid>https://jingxa.github.io/2018/07/12/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-2/</guid>
      <pubDate>Thu, 12 Jul 2018 13:36:37 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第八章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第八章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>bind </li><li>negate</li><li>compose</li><li>修饰(使他成为一个仿函数)</li></ul><p>接口：</p><ul><li><code>&lt;functional&gt;</code></li><li>SGI STL<code>&lt;stl_function.h&gt;</code></li></ul><p>【注意】：</p><ul><li>所有期待获得配节能力的组件，本身必须是可配接的；</li><li>一元仿函数必须继承自<code>unary_function</code></li><li>二元仿函数必须继承自<code>binary_function</code></li><li>成员函数必须以<code>mem_fun</code>处理过</li><li>一般函数必须以<code>ptr_fun</code>处理过</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9496865ef7ffb463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c1f1605f6072ba0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h1><h2 id="2-1-返回值得逻辑否定not1-not2"><a href="#2-1-返回值得逻辑否定not1-not2" class="headerlink" title="2.1 返回值得逻辑否定not1,not2"></a>2.1 返回值得逻辑否定not1,not2</h2><pre><code>/**    1. 返回值得逻辑否定not1,not2    --- not1: 仿函数只有一个参数    --- not2: 仿函数有两个参数*/template&lt;class Predicate&gt;class unary_negate: public unary_function&lt;typename Predicate::argument_type,bool&gt;{protected:    Predicate pred;  // 内部成员；public:    explicit unary_negate(const Predicate&amp; x):pred(x){}    bool operator()(const typename Predicate::argument_type&amp; x)const{        return !pred(x);    }};// 辅助函数template&lt;class Predicate&gt;inline unary_negate&lt;Predicate&gt; not1(const Predicate&amp; pred){    return unary_negate&lt;Predicate&gt;(pred);}// Binary Predicate 的逻辑负值template&lt;class Predicate&gt;class binary_negate: public binary_function&lt;typename Predicate::first_argument_type,                                            typename Predicate::second_argument_type,                                            bool&gt;{protected:    Predicate pred;  // 内部成员；public:    explicit binary_negate(const Predicate&amp; x):pred(x){}    bool operator()(const typename Predicate::first_argument_type&amp; x,                    const typename Predicate::second_argument_type&amp; y)const{        return !pred(x,y);    }};// 辅助函数template&lt;class Predicate&gt;inline binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred){    return binary_negate&lt;Predicate&gt;(pred);}</code></pre><h2 id="2-2-bind1st-bind2nd对参数进行绑定"><a href="#2-2-bind1st-bind2nd对参数进行绑定" class="headerlink" title="2.2 bind1st, bind2nd对参数进行绑定"></a>2.2 bind1st, bind2nd对参数进行绑定</h2><pre><code>/**    2. bind1st, bind2nd对参数进行绑定    --- bind1st(...)会产生一个binder1st&lt;operation&gt;(...)对象；        --- bind2nd(...)会产生一个binder2nd&lt;operation&gt;(...)对象；*/// binder1sttemplate&lt;class Operation&gt;class binder1st: public unary_function&lt;typename Operation::second_argument_type,                                        typename Operation::result_type&gt;{protected:    Operation op;  // 内部成员    typename Operation::first_argument_type value; // 内部成员public:    // ctor    binder1st(const Operation&amp; x,         const typename Operation::first_argument_type&amp; y):op(x),value(y){        }    typename Operation::result_type        operator()(const typename Operation::second_argument_type&amp; x)const{            return op(value,x);        }                                            };// 辅助函数template&lt;class Operation , class T&gt;inline binder1st&lt;Operation&gt; bind1st(const Operation&amp;operation&amp; op, const T&amp; x){    typedef typename Operation::first_argument_type arg1_value;    // 把 x转为第一参数类型    return binder1st&lt;Operation&gt;(op, arg1_value(x));}// binder2ndtemplate&lt;class Operation&gt;class binder2nd: public unary_function&lt;typename Operation::first_argument_type,                                        typename Operation::result_type&gt;{protected:    Operation op;  // 内部成员    typename Operation::second_argument_type value; // 内部成员public:    // ctor    binder1st(const Operation&amp; x,         const typename Operation::second_argument_type&amp; y):op(x),value(y){        }    typename Operation::result_type        operator()(const typename Operation::first_argument_type&amp; x)const{            return op(x,value);        }                                            };// 辅助函数 bind2nd&lt;Op&gt;template&lt;class Operation , class T&gt;inline binder2nd&lt;Operation&gt; bind2nd(const Operation&amp;operation&amp; op, const T&amp; x){    typedef typename Operation::second_argument_type arg1_value;    // 把 x转为第二参数类型    return binder2nd&lt;Operation&gt;(op, arg1_value(x));}</code></pre><h2 id="2-3-用于函数合成：-compose1-compose2"><a href="#2-3-用于函数合成：-compose1-compose2" class="headerlink" title="2.3 用于函数合成： compose1, compose2"></a>2.3 用于函数合成： compose1, compose2</h2><pre><code>/**    3. 用于函数合成： compose1, compose2*/template&lt;class Operation1, class Operation2&gt;class unary_compose:public unary_function&lt;typename Operation2:argument_type,                                        typename Operation1::result_type&gt;{protected:    Operation1 op1;    Operation2 op2;  // 内部成员public:    // ctor    unary_compose(const Operation1&amp; x, const Operation2&amp; y)        :op1(x),op2(y){}    typename Operation1::result_type        operator()(const typename Operation::argument_type&amp; x)const{            return op1(op2(x)); // 函数合成        }};// 辅助函数template&lt;class Operation1, Operation2&gt;inline unary_compose&lt;Operation1,Operation2&gt;compose1(const Operation1&amp; op1, const Operation2&amp; op2){    return unary_compose&lt;Operation1,Operation2&gt;(op1,op2);}// binary_composetemplate&lt;class Operation1, class Operation2,class Operation3&gt;class binary_compose:public unary_function&lt;typename Operation2:argument_type,                                        typename Operation1::result_type&gt;{protected:    Operation1 op1;    Operation2 op2;  // 内部成员    Operation3 op3;public:    // ctor    binary_compose(const Operation1&amp; x, const Operation2&amp; y,Operation&amp; z)        :op1(x),op2(y),op3(z){}    typename Operation1::result_type        operator()(const typename Operation::argument_type&amp; x)const{            return op1(op2(x), op3(x)); // 函数合成        }};// binary_compose&lt;Op1,Op2,Op3&gt;template&lt;class Operation1, Operation2,Operation3&gt;inline binary_compose&lt;Operation1,Operation2,Operation3&gt;compose2(const Operation1&amp; op1, const Operation2&amp; op2,const Operation3&amp; op3){    return binary_compose&lt;Operation1,Operation2,Operation3&gt;(op1,op2,op3);}</code></pre><h2 id="2-4-用于函数指针：ptr-fun"><a href="#2-4-用于函数指针：ptr-fun" class="headerlink" title="2.4 用于函数指针：ptr_fun"></a>2.4 用于函数指针：ptr_fun</h2><pre><code>/**    4. 用于函数指针：ptr_fun    --- pointer_to_unary_function    --- pointer_to_binary_function*/// pointer_to_unary_functiontemplate&lt;class Arg, class Result&gt;class pointer_to_unary_function：public unary_function&lt;Arg,Result&gt;{protected:    Result(*ptr)(Arg); // 内部成员，一个函数指针public:    // ctors    pointer_to_unary_function(){}    explicit pointer_to_unary_function(Result(*x)(Arg)):ptr(x){}    // 通过函数指针执行函数    Result operator()(Arg x)const{return ptr(x);}};// 辅助函数template&lt;class Arg,class Result&gt;inline pointer_to_unary_function&lt;Arg,Result&gt;ptr_fun(Result (*x)(Arg)){    return pointer_to_unary_function&lt;Arg,Result&gt;(x);}// pointer_to_binary_functiontemplate&lt;class Arg1,Arg2, class Result&gt;class pointer_to_binary_function:public binary_function&lt;Arg1,Arg2,Result&gt;{protected:    Result(*ptr)(Arg1, Arg2); // 内部成员，一个函数指针public:    // ctors    pointer_to_binary_function(){}    explicit pointer_to_binary_function(Result(*x)(Arg1,Arg2)):ptr(x){}    // 通过函数指针执行函数    Result operator()(Arg1 x, Arg2 y)const{return ptr(x, y);}};// 辅助函数template&lt;class Arg1,class Arg2,class Result&gt;inline pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;ptr_fun(Result (*x)(Arg1,Arg2)){    return pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;(x);}</code></pre><h2 id="2-5-用于成员函数指针：mem-fun-mem-fun-ref"><a href="#2-5-用于成员函数指针：mem-fun-mem-fun-ref" class="headerlink" title="2.5 用于成员函数指针：mem_fun, mem_fun_ref"></a>2.5 用于成员函数指针：mem_fun, mem_fun_ref</h2><pre><code>/**    5. 用于成员函数指针：mem_fun, mem_fun_ref    -- 对于每个Adapter function objects：每个对象有三种变化：    (1) 无任何参数 vs &quot;一个参数&quot;    (2) “通过pointer调用” vs “通过reference 调用”    (3) &quot;const 成员函数&quot; vs &quot;non-const 成员函数&quot;    // 所有复杂都在对象内部，直接调用上层函数 mem_fun  和 mem_fun_ref*/// 1.无任何参数，通过pointer调用， “non-const 成员函数”template&lt;class S, class T&gt;class mem_fun_t: public unary_function&lt;T* , S&gt;{public:    explicit mem_fun_t(S (T::*pf()):f(pf){} // 记录下来    S operator()(T* p) {return (p-&gt;*f)();}  // 调用”private:    S (T::*f)();  // 内部成员 ， 成员对象函数 指针};// 2.无任何参数， 通过 pointer调用， const 成员函数template&lt;class S, class T&gt;class const_mem_fun_t: public unary_function&lt;T* , S&gt;{public:    explicit mem_fun_t(S (T::*pf() const):f(pf){} // 记录下来    S operator()(const T* p) const{return (p-&gt;*f)();}  // 调用”private:    S (T::*f)() const;  // 内部成员 ， 成员对象函数 指针};// 3.无任何参数， 通过reference调用， non-const成员函数template&lt;class S, class T&gt;class mem_fun_ref_t: public unary_function&lt;T , S&gt;{public:    explicit mem_fun_ref_t(S (T::*pf()):f(pf){} // 记录下来    S operator()( T&amp; r) {return (r.*f)();}  // 调用”private:    S (T::*f)() ;  // 内部成员 ， 成员对象函数 指针};// 4.无任何参数， 通过reference调用， const成员函数template&lt;class S, class T&gt;class const_mem_fun_ref_t: public unary_function&lt;T , S&gt;{public:    explicit const_mem_fun_ref_t(S (T::*pf() const):f(pf){} // 记录下来    S operator()( const T&amp; r) const{return (r.*f)();}  // 调用”private:    S (T::*f)() const;  // 内部成员 ， 成员对象函数 指针};// 5.有一个参数，通过pointer调用， “non-const 成员函数”template&lt;class S, class T,class A&gt;class mem_fun1_t: public unary_function&lt;T*,A , S&gt;{public:    explicit mem_fun1_t(S (T::*pf(A)):f(pf){} // 记录下来    S operator()(T* p,A x){return (p-&gt;*f)(x);}  // 调用”private:    S (T::*f)(A);  // 内部成员 ， 成员对象函数 指针};// 6. 有一个参数，通过pointer调用， “const 成员函数”template&lt;class S, class T,class A&gt;class const_mem_fun1_t: public unary_function&lt;T*,A , S&gt;{public:    explicit const_mem_fun1_t(S (T::*pf(A)):f(pf){} // 记录下来    S operator()(const T* p, A x) const{return (p-&gt;*f)(x);}  // 调用”private:    S (T::*f)(A) const;  // 内部成员 ， 成员对象函数 指针};// 7. 有一个参数，通过reference调用， “non-const 成员函数”template&lt;class S, class T,class A&gt;class mem_fun1_ref_t: public unary_function&lt;T, A , S&gt;{public:    explicit mem_fun1_ref_t(S (T::*pf(A)):f(pf){} // 记录下来    S operator()(T&amp; r,A x){return (r.*f)(x);}  // 调用”private:    S (T::*f)(A);  // 内部成员 ， 成员对象函数 指针};// 8.有一个参数，通过reference调用， “const 成员函数”template&lt;class S, class T,class A&gt;class const_mem_fun1_ref_t: public unary_function&lt;T*,A , S&gt;{public:    explicit const_mem_fun1_ref_t(S (T::*pf(A)):f(pf){} // 记录下来    S operator()(const T&amp; r, A x) const{return (r.*f)(x);}  // 调用”private:    S (T::*f)(A) const;  // 内部成员 ， 成员对象函数 指针};// 辅助函数// mem_fun mem_fun_reftemplate&lt;class S, class T&gt;inline mem_fun_t&lt;S,T&gt; mem_fun(S T::*f()){    return mem_fun_t&lt;S,T&gt;(f);}template&lt;class S, class T&gt;inline const_mem_fun_t&lt;S,T&gt; mem_fun(S T::*f() const){    return const_mem_fun_t&lt;S,T&gt;(f);}template&lt;class S, class T&gt;inline mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S T::*f() ){    return mem_fun_ref_t&lt;S,T&gt;(f);}template&lt;class S, class T&gt;inline const_mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S T::*f() const){    return const_mem_fun_ref_t&lt;S,T&gt;(f);}// 带参数template&lt; class S, class T, class A&gt;inline mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A)){    return mem_fun1_t&lt;S,T,A&gt;(f);}template&lt; class S, class T, class A&gt;inline const_mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A) const){    return const_mem_fun1_t&lt;S,T,A&gt;(f);}template&lt; class S, class T, class A&gt;inline mem_fun1_ref_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A)){    return mem_fun1_ref_t&lt;S,T,A&gt;(f);}template&lt; class S, class T, class A&gt;inline const_mem_fun1_ref_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A) const){    return const_mem_fun1_ref_t&lt;S,T,A&gt;(f);}</code></pre>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/12/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_配接器_1</title>
      <link>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-1/</link>
      <guid>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-1/</guid>
      <pubDate>Wed, 11 Jul 2018 12:48:33 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第八章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;ad
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第八章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>adapter:</p><ul><li>讲一个class的接口转换为另一个class的接口，使原本不兼容而不能合作的classes，可以一起运作；</li></ul><h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h1><ul><li>funcition adapter</li><li>container adapter</li><li>iterator adapter</li></ul><hr><h1 id="3-container-adapter"><a href="#3-container-adapter" class="headerlink" title="3 container adapter"></a>3 container adapter</h1><ul><li>quque<ul><li>deque构成底层；</li></ul></li><li>stack</li></ul><hr><h1 id="4-iterator-adapter"><a href="#4-iterator-adapter" class="headerlink" title="4 iterator adapter"></a>4 iterator adapter</h1><ul><li>insert itearators</li><li>reverse iterators</li><li>iostream iterators<br>接口：</li><li><code>&lt;iterator&gt;</code></li><li>SGI STL <code>&lt;stl_iterator.h</code></li></ul><h2 id="4-1-insert-itearators"><a href="#4-1-insert-itearators" class="headerlink" title="4.1 insert itearators"></a>4.1 insert itearators</h2><ul><li>back_insert_iterator</li><li>front_insert_iterator</li><li>insert_iterator</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a52a8e6d8c64cacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个insert iterators内部维护一个容器（用户指定）,</li><li>用户对insert iterator赋值的时候，insert iterator调用内部容器的操作</li><li><code>operator++,opreator++(int),operator*</code>等都被关闭；</li><li>insert_iterators的前进，后退，取值，成员取用都不被允许；</li></ul><h3 id="4-1-1-back-insert-iterator"><a href="#4-1-1-back-insert-iterator" class="headerlink" title="4.1.1 back_insert_iterator"></a>4.1.1 back_insert_iterator</h3><pre><code>/**    1. back_insert_iterator*/template&lt;class Container&gt;class back_insert_iterator{protected:    Container* container; // 底层容器public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    explicit back_insert_iterator(Container&amp; x):container(x){}    back_insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            container-&gt;push_back(value);  // 调用容器操作            return *this;    }    // 一下三个操作对 back_insert_iterator 不起作用    // 三个返回都是自己    back_insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    back_insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    back_insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x){    return back_insert_iterator&lt;Container&gt;(x);}</code></pre><h3 id="4-1-2-front-insert-iterator"><a href="#4-1-2-front-insert-iterator" class="headerlink" title="4.1.2 front_insert_iterator"></a>4.1.2 front_insert_iterator</h3><pre><code>/**    2. front_insert_iterator*/template&lt;class Container&gt;class front_insert_iterator{protected:    Container* container; // 底层容器public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    explicit front_insert_iterator(Container&amp; x):container(x){}    front_insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            container-&gt;push_front(value);  // 调用容器操作            return *this;    }    // 一下三个操作对 front_insert_iterator 不起作用    // 三个返回都是自己    front_insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    front_insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    front_insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x){    return front_insert_iterator&lt;Container&gt;(x);}</code></pre><h3 id="4-1-3-insert-iterator"><a href="#4-1-3-insert-iterator" class="headerlink" title="4.1.3 insert_iterator"></a>4.1.3 insert_iterator</h3><pre><code>/**    3. insert_iterator*/template&lt;class Container&gt;class insert_iterator{protected:    Container* container; // 底层容器    typename Container::iterator  iter;public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    insert_iterator(Container&amp; x,typename Container::iterator i)        :container(x),iter(i){}    insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            iter = container-&gt;insert(value);  // 调用容器操作            ++iter;  // 随着目标移动            return *this;    }    // 一下三个操作对 insert_iterator 不起作用    // 三个返回都是自己    insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline insert_iterator&lt;Container&gt; front_inserter(Container&amp; x，Iterator i){    typedef typename Container::iterator iter;    return insert_iterator&lt;Container&gt;(x,iter(i));}</code></pre><h2 id="4-2-Reverse-Iterators"><a href="#4-2-Reverse-Iterators" class="headerlink" title="4.2 Reverse Iterators"></a>4.2 Reverse Iterators</h2><ul><li>将一般的迭代器逆转；</li></ul><pre><code>/**    二、 reverse Iterator*/template&lt;class Iterator&gt;class reverse_iterator{protected:    Iterator    current;   // 记录正向迭代器public:    // 逆向迭代器的5中类型    typedef typename iterator_traits&lt;Iterator&gt;:: iterator_category iterator_category;    typedef typename iterator_traits&lt;Iterator&gt;::value_type             value_type;    typedef typename iterator_traits&lt;Iterator&gt;::difference_type        difference_type;    typedef typename iterator_traits&lt;Iterator&gt;::pointer                pointer;    typedef typename iterator_traits&lt;Iterator&gt;::reference            reference;    typedef    Iterator    iterator_type;  // 正向迭代器    typedef    reverse_iterator&lt;Iterator&gt; self;        // 逆向迭代器public:    reverse_iterator(){}    explicit reverse_iterator(iterator_type x):current(x){}    reverse_iterator(const self&amp; x):current(x.current){}    iterator_type base() const{return current;}   // 取出正向迭代器    reference operator*() const {      // 对逆向迭代器取值，就是讲“对应的正向迭代器”退一格在取值        Iterator tmp = current;        treturn *--tmp;    }    pointer operator-&gt;() const{return &amp;(operator*());}    self&amp; operator++(){        -- current;        return *this;    }    self operator++(int){        self tmp = *this;        -- current;        return tmp;    }    // 后退操作    self&amp; operator--(){        ++current;        return *this;    }    self operator--(int){        self  tmp = *this;        ++current;        return tmp;    }    // 前进和后退完全逆转    self  operator+(difference_type n) const{        return self(current -n);    }    self&amp;  operator+=(difference_type n) const{        current -= n;        return *this;    }    self  operator-(difference_type n) const{        return self(current + n);    }    self&amp;  operator-=(difference_type n) const{        current += n;        return *this;    }    // 下面第一个* 和 + 都会调用本类的operator* 和operator+    // 第二个 * 不会调用本类，而是调用正向迭代器的operator*；    reference operator[](difference_type n )const{        return *(*this + n);    }};</code></pre><h2 id="4-3-IOStream-Iterators"><a href="#4-3-IOStream-Iterators" class="headerlink" title="4.3 IOStream Iterators"></a>4.3 IOStream Iterators</h2><ul><li>将迭代器绑定到某个iostream对象上；</li><li>istream_iterator</li><li>ostream_iterator</li></ul><h3 id="4-3-1-istream-iterator"><a href="#4-3-1-istream-iterator" class="headerlink" title="4.3.1 istream_iterator"></a>4.3.1 istream_iterator</h3><pre><code>// istream_iteratortemplate&lt;class T, class Distance = prdiff_t&gt;class istream_iterator{    // __STL_NULL_TMPL_ARGS    在&lt;stl_config.h&gt;中定义为 template&lt;&gt;    friend bool         operator== __STL_NULL_TMPL_ARGS(const istream_iterator&lt;T,Distance&gt;&amp; x,            const istream_iterator&lt;T,Distance&gt;&amp; y&gt;;protected:    istream* stream;    T value;    bool end_marker;    void read(){        end_marker = (*stream)? true: false;        if(end_marker)*stream &gt;&gt;value;        //以上输入之后，stream状态改变，所以在下面在判断一次决定end_marker        // 当读到eof或者型别不符合的时候，stream处于false状态        end_marker = (*stream)? true: false;    }public:    typedef input_iterator_tag                    iterator_category;    typedef    T                                    value_type;    typedef    Distance                            difference_type;    typedef    const T*                            pointer;    typedef    const T&amp;                            reference;    // 以上，因为input iterator ,所以采用const    istream_iterator(): stream(&amp;cin),end_marker(false){}    istream_iterator(istream&amp; s):stream(&amp;s){red();}    // 以上两行用法：    // istream_iterator&lt;int&gt; eos;  造成end_marker为false;    // istream_iterator&lt;int&gt; initer(cin); 引发read(), 程序会等待    // 因此，下面这两行：    // istream_iterator&lt;int&gt; initer(cin); (A)    // cout&lt;&lt;&quot;please input ..&quot;&lt;&lt;endl;     (B)    // 会停留在A等待一个输入，然后才执行(B)的提示信息，不合理；    // 规避：永远在合适的时候定义一个 istream_iterator    reference operator*()const{return value;}    pointer operator-&gt;() const{return &amp;(operator*());}    // 迭代器前进一个位置，读取一个资料    istream_iterator&lt;T,Distance&gt;&amp; operator++(){        read();        return *this;    }    istream_iterator&lt;T,Distance&gt; operator++(int){        istream_iterator&lt;T,Distance&gt; tmp = *this;        read();        return tmp;    }};</code></pre><h3 id="4-3-2-ostream-itreator"><a href="#4-3-2-ostream-itreator" class="headerlink" title="4.3.2 ostream_itreator"></a>4.3.2 ostream_itreator</h3><pre><code>// ostream_iteratortemplate&lt;class T&gt;class ostream_iterator{protected:    ostream* stream;    const char* string; // 每次输出的间隔符号public:    typedef output_iterator_tag        iterator_category;    typedef    void                    value_type;    typedef    void                    pointer;    typedef    void                    difference_type;    typedef    void                    reference;    ostream_iterator(ostream&amp; s):stream(&amp;s),string(0){}    ostream_iterator(ostream&amp; s, const char* c):stream(&amp;s),string(c){}    // 以上，用法：    // ostream_iterator&lt;int&gt; outlier(cout,&#39; &#39;); 输出到cout,每次间隔一个空格    // 迭代器赋值操作，代表输出一笔数据    ostream_iterator&lt;T&gt;&amp; operator=(const T&amp; value){        *stream&lt;&lt;value;        if(string) *stream&lt;&lt;string;  // 如果状态无误，输出间隔符号        return *this;    }    // 一下三个操作，都是返回自己    ostream_iterator&lt;T&gt;&amp; operator*(){return *this;}    ostream_iterator&lt;T&gt;&amp; operator++(){return *this;}    ostream_iterator&lt;T&gt;&amp; operator++(int){return *this;}};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_仿函数</title>
      <link>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
      <guid>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Wed, 11 Jul 2018 12:47:56 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第七章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361608-e4607d5a9010
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第七章</p></blockquote><hr><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e4607d5a9010612b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li><p>操作数的个数</p><ul><li>一元</li><li>二元</li></ul></li><li><p>功能</p><ul><li>算法运算</li><li>关系运算</li><li>逻辑运算</li></ul></li><li><p><code>&lt;stl_finction.h&gt;</code> </p></li></ul><h1 id="2-基类"><a href="#2-基类" class="headerlink" title="2 基类"></a>2 基类</h1><pre><code>/**    一元仿函数： unary_function*/template&lt;class Arg, class Result&gt;struct unary_function{    typedef Arg argument_type;    typedef Result result_type;};/**    二元仿函数： binary_function*/template&lt;class Arg1,class Arg2,class Result&gt;struct binary_function{    typedef Arg1 first_argument_type;    typedef Arg2 seconde_argument_type;    typedef Result return_type;};</code></pre><h1 id="3-算术运算"><a href="#3-算术运算" class="headerlink" title="3 算术运算"></a>3 算术运算</h1><pre><code>/**    一、 算术类    --- 支持加法，减法，乘法，除法，模数和否定运算    -- 加法：plus&lt;T&gt;    -- 减法：minus&lt;T&gt;    -- 乘法： multiplies&lt;T&gt;    -- 除法： divides&lt;T&gt;    -- 模取： modulus&lt;T&gt;    -- 否定： negate&lt;T&gt;*/template&lt;class T&gt;struct plus : public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const{        return x + y;    }};template&lt;class T&gt;struct minus: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const {        return x - y;    }};template&lt;class T&gt;struct multiplies: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x,const T&amp; y) const{        return x * y;    }};template&lt;class T&gt;struct divides: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const{        return x / y;    }};template&lt;class T&gt;struct modulus: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const {        return x % y;    }};template&lt;class T&gt;struct negate: public unary_function&lt;T,T&gt;{    T operator()(const T&amp; x) const{        return -x;    }};</code></pre><h1 id="4-关系运算"><a href="#4-关系运算" class="headerlink" title="4 关系运算"></a>4 关系运算</h1><pre><code>/**    二、关系运算    -- 等于： equal_to&lt;T    -- 不等于： not_equal_to&lt;T    -- 大于： greater&lt;T&gt;    -- 大于或等于： greater_equal&lt;T&gt;    -- 小于： less&lt;T&gt;    -- 小于等于： less_equal&lt;T&gt;*/template&lt; class T&gt;struct equal_to: public binary_function&lt;T,T, bool&gt; {    bool operator()(const T&amp; x, const T&amp; y)const{        return x==y;    }};template&lt;class T&gt;struct not_equal_to: public binary_function&lt;T,T,T&gt;{    bool oeperator()(const T&amp; x, const T&amp; y) const{        return x!= y;    }};template&lt; class T&gt;struct greater: public binary_function&lt;T,T,T&gt; {    bool operator()(const T&amp; x, const T&amp; y) const{        return x&gt;y;    }};template&lt; class T&gt;struct less: public binary_function&lt;T,T,T&gt; {    bool operator()(const T&amp; x,const T&amp; y) const{        return x &lt; y;    }};template&lt; class T&gt;struct greater_equal: public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        sdreturn x&gt;=y;    }};template&lt; class T&gt;struct less_equal: public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x,const T&amp; y)const{        return x &lt;= y;    }};</code></pre><h1 id="5-逻辑运算"><a href="#5-逻辑运算" class="headerlink" title="5 逻辑运算"></a>5 逻辑运算</h1><pre><code>/**    三、 逻辑运算    -- And : logical_and    -- Or  : logical_or    __ Not:  logical_not*/template&lt;class T&gt;struct logical_and:public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        return x &amp;&amp; y;    }};template&lt;class T&gt;struct logical_or:public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        return x || y;    }};template&lt;class T&gt;struct logical_not:public unary_function&lt;T,T&gt;{    bool operator()(const T&amp; x) const{        return !x ;    }};</code></pre><h1 id="6-证同（identity）、选择（select）、-投射（project）"><a href="#6-证同（identity）、选择（select）、-投射（project）" class="headerlink" title="6 证同（identity）、选择（select）、 投射（project）"></a>6 证同（identity）、选择（select）、 投射（project）</h1><h2 id="6-1-证同"><a href="#6-1-证同" class="headerlink" title="6.1 证同"></a>6.1 证同</h2><h3 id="6-1-1-仿函数的证同"><a href="#6-1-1-仿函数的证同" class="headerlink" title="6.1.1 仿函数的证同"></a>6.1.1 仿函数的证同</h3><p> 证同元素(identity element)</p><ul><li>数值A若与该元素做op运算，会得到A自己；</li><li>加法的证同元素为0</li><li>乘法的证同元素为1 </li></ul><pre><code>/** 3.2 证同元素(identity element)- 数值A若与该元素做op运算，会得到A自己；- 加法的证同元素为0- 乘法的证同元素为1 */template&lt;class T&gt;inline T identity_element(plus&lt;T&gt;){    return T(0);}template&lt; class T&gt;inline T identity_element(multiplies&lt;T&gt;){    return T(1);}</code></pre><h3 id="6-1-2-证同函数"><a href="#6-1-2-证同函数" class="headerlink" title="6.1.2 证同函数"></a>6.1.2 证同函数</h3><pre><code>struct identity: public unary_function&lt;T,T&gt;{    const T&amp; operator()(const T&amp; x)const{        return x;    }};</code></pre><h2 id="6-2-选择"><a href="#6-2-选择" class="headerlink" title="6.2 选择"></a>6.2 选择</h2><pre><code>// 选择函数： 接受一个pair,传回第一个元素// 运用于&lt;stl_map.h&gt; ，用来指定rb_tree所需要的KeyOfValue op;template&lt; class Pair&gt;struct select1st:public unary_function&lt;Pair,typename Pair::first_type&gt;{    const typename Pair::first_type&amp; operator()(const Pair&amp; x) const{        return x.first;    }};// 选择函数，返回第二个元素// SGI stl 未使用此式子template&lt; class Pair&gt;struct select2nd:public unary_function&lt;Pair,typename Pair::second_type&gt;{    const typename Pair::second_type&amp; operator()(const Pair&amp; x) const{        return x.second;    }};</code></pre><h2 id="6-3-投射"><a href="#6-3-投射" class="headerlink" title="6.3 投射"></a>6.3 投射</h2><pre><code>// 投射函数：传回第一参数，忽略第二参数// SGI STL 未使用此式子template&lt;class Arg1,class Arg2&gt;struct project1st:public binary_function&lt;T,T,T&gt;{    Arg1 operator()(const Arg1&amp; x, const Arg2&amp;) const{        return x;    }};// 投射函数：传回第二参数，忽略第一参数// SGI STL 未使用此式子template&lt;class Arg1,class Arg2&gt;struct project1st:public binary_function&lt;T,T,T&gt;{    Arg2 operator()(const Arg1&amp;, const Arg2&amp; y) const{        return y;    }};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
