<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Wed, 27 Jun 2018 11:53:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>char\*的疑问</title>
      <link>https://jingxa.github.io/2018/06/27/char-%E7%9A%84%E7%96%91%E9%97%AE/</link>
      <guid>https://jingxa.github.io/2018/06/27/char-%E7%9A%84%E7%96%91%E9%97%AE/</guid>
      <pubDate>Wed, 27 Jun 2018 11:15:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在使用char* 传递参数的时候，以为char* 传递的是指针；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
#in
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在使用char* 传递参数的时候，以为char* 传递的是指针；</p><pre><code class="C++">#include &lt;iostream&gt;#include&lt;string&gt;#include &lt;cstring&gt;#include&lt;vector&gt;using namespace std;void printNoref(char * s){    cout&lt;&lt;&quot;非引用传值函数中s 地址:&quot;&lt;&lt;&amp;s&lt;&lt;endl;    cout&lt;&lt;&quot;s 指向的地址:&quot;&lt;&lt;(int*)s&lt;&lt;endl;    s++;    cout&lt;&lt;&quot;str:&quot;&lt;&lt;s&lt;&lt;endl;}void printref(char *&amp; s){    cout&lt;&lt;&quot;非引用传值函数中s 地址:&quot;&lt;&lt;&amp;s&lt;&lt;endl;    cout&lt;&lt;&quot;s 指向的地址:&quot;&lt;&lt;(int*)s&lt;&lt;endl;    (s)++;    cout&lt;&lt;&quot;ref str:&quot;&lt;&lt;s&lt;&lt;endl;}int main() {    string s ( &quot;123456789&quot;);    char* str = new char[s.size() + 1];    strcpy(str, s.c_str());    // 真实地址    cout&lt;&lt;&quot;真实 str 地址：&quot;&lt;&lt;&amp;str&lt;&lt;endl;    cout&lt;&lt;&quot;str 指向的地址：&quot;&lt;&lt;(int*)str&lt;&lt;endl;      //非引用传值    printNoref(str);    cout&lt;&lt;&quot;str 指向的地址:&quot;&lt;&lt;(int*)str&lt;&lt;&quot; 值 str:&quot;&lt;&lt;str&lt;&lt;endl;    cout&lt;&lt;&quot;================&quot;&lt;&lt;endl;    // 引用传值    printref(str);    cout&lt;&lt;&quot;str 指向的地址:&quot;&lt;&lt;(int*)str&lt;&lt;&quot; 值 str:&quot;&lt;&lt;str&lt;&lt;endl;    return 0;}</code></pre><p>结果：</p><pre><code>真实 str 地址：0x7ffcf092ee08str 指向的地址：0x1481c20非引用传值函数中s 地址:0x7ffcf092ede8s 指向的地址:0x1481c20str:23456789str 指向的地址:0x1481c20 值 str:123456789================引用传值函数中s 地址:0x7ffcf092ee08s 指向的地址:0x1481c20ref str:23456789str 指向的地址:0x1481c21 值 str:23456789</code></pre><ul><li><code>char * s</code>传递的是s地址中存储的指针地址的复制，</li><li><code>char*&amp; s</code>传递的是指向s真实地址的指针；</li></ul><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/27/char-%E7%9A%84%E7%96%91%E9%97%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_1—_空间分配器</title>
      <link>https://jingxa.github.io/2018/06/26/STL-1%E2%80%94-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/</link>
      <guid>https://jingxa.github.io/2018/06/26/STL-1%E2%80%94-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/</guid>
      <pubDate>Tue, 26 Jun 2018 12:56:17 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-STL-allocater&quot;&gt;&lt;a href=&quot;#1-STL-allocater&quot; class=&quot;headerlink&quot; title=&quot;1. ST
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》</p></blockquote><hr><h1 id="1-STL-allocater"><a href="#1-STL-allocater" class="headerlink" title="1. STL allocater"></a>1. STL allocater</h1><h2 id="1-1-操作过程"><a href="#1-1-操作过程" class="headerlink" title="1.1 操作过程"></a>1.1 操作过程</h2><ul><li>对象创建<ul><li>内存分配： alloc:allocate()</li><li>对象构造： ::construct()</li></ul></li><li>对象释放<ul><li>对象析构： ::destroy()</li><li>内存释放：  alloc:deallocate()</li></ul></li></ul><h2 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2 定义"></a>1.2 定义</h2><ul><li><code>&lt;memory&gt;</code><br>包含以下两个头文件：<pre><code class="C++">#include &lt;stl_alloc.h&gt;  //负责内存配置和释放#include &lt;stl_construct.h&gt;  //负责对象构造和析构</code></pre></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e5370350f3ee4f1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-构造和析构"><a href="#1-3-构造和析构" class="headerlink" title="1.3 构造和析构"></a>1.3 构造和析构</h2><ul><li>construct()</li><li>destroy()</li></ul><p>部分代码：</p><pre><code class="C++"># include &lt;new.h&gt;  //使用placement new template&lt;class T1, class T2&gt;inline void construct(T1* p, T2&amp; value){  new(p) T1(value);  // placement new ; 调用T1::T1(value);在p指向的内存上构造}template&lt;class T&gt;inline void destroy(T&amp; pointer){  pointer-&gt;~T();  //调用析构 ~T()}//destroy 的其他版本 ···</code></pre><h2 id="1-4-空间的配置和释放：std-alloc"><a href="#1-4-空间的配置和释放：std-alloc" class="headerlink" title="1.4 空间的配置和释放：std::alloc"></a>1.4 空间的配置和释放：std::alloc</h2><h3 id="1-4-1-分类"><a href="#1-4-1-分类" class="headerlink" title="1.4.1 分类"></a>1.4.1 分类</h3><ul><li>malloc()</li><li>free()</li><li>内存破碎问题：<ul><li>第一级配置器： 直接使用malloc()和free()</li><li>第二级配置器： <ul><li>(1) 配置区块大于128bytes，使用第一级配置器；</li><li>(2) 小于128bytes，视区块过小，使用memory pool 即内存池</li></ul></li></ul></li></ul><p>定义：<br>第一级配置器： <code>_malloc_alloc_template</code><br>第二级配置器：<code>_default_alloc_template</code></p><ul><li>alloc不接受任何template参数；</li></ul><h3 id="1-4-2-接口"><a href="#1-4-2-接口" class="headerlink" title="1.4.2 接口"></a>1.4.2 接口</h3><ul><li>为了符合stl规范，包装一个接口；</li></ul><pre><code class="C++">template&lt;class T， class Alloc&gt;class simple_aaloc{public:    static T* allocate(size_t n){        return 0 == n ? 0 : (T*)Alloc::allocate(n*sizeof(T));    }    static T* allocate(void){        return (T*) Alloc::allocate(sizeof(T));    }    static void deallocate(T* p, size_t n){        if(0 != n)Alloc::deallocate(p, n*sizeof(T));    }    static void deallocate(T* p){        Alloc::deallocate(p, sizeof(T));    }};</code></pre><h3 id="1-4-3-实际使用"><a href="#1-4-3-实际使用" class="headerlink" title="1.4.3  实际使用"></a>1.4.3  实际使用</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-966b28c00474dcf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a95bf56b52f422fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-4-5-第一级配置器-malloc-alloc-template"><a href="#1-4-5-第一级配置器-malloc-alloc-template" class="headerlink" title="1.4.5 第一级配置器 __malloc_alloc_template"></a>1.4.5 第一级配置器 <code>__malloc_alloc_template</code></h3><p>第一级配置器直接使用<code>malloc</code>和·free·</p><pre><code class="C++">template&lt;int inst&gt;  // 无template参数，“非型别参数”inst没用class __malloc_alloc_template{private:// 处理内存不足的函数指针//  oom: out of memory    static void *oom_malloc(size_t);    static void *oom_realloc(void*, size_t);    static void (*__malloc_alloc_oom_handler)();public://    分配内存    static void * allocate(){        void* result = malloc(n);     // 直接使用malloc        if(0 == result)result = oom_malloc(n); // 如果分配不成功，改用oom_malloc()        return result;    }// 释放内存    static void* deallocate(void* p , size_t /*n*/){        free(p);        //直接使用free    }//... 省略};</code></pre><h3 id="1-4-6-第二级配置器-default-alloc-template"><a href="#1-4-6-第二级配置器-default-alloc-template" class="headerlink" title="1.4.6 第二级配置器__default_alloc_template"></a>1.4.6 第二级配置器<code>__default_alloc_template</code></h3><p>(1) <strong>定义</strong></p><ul><li><p>如果区块：</p><ul><li>大于128bytes： 交给第一级配置器处理</li><li>小于128bytes: 使用内存池（memory pool）管理</li></ul></li><li><p>内存池管理（次层配置）：</p><ul><li>每次配置一大块内存，维护对应的自由链表(free-list)，然后从链表中划分内存给请求，或者回收小块内存；</li><li>内存池维护16个free-lists：各自管理(8, 16,24,32, …, 120 ,128)的小额区块；</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-62692f7adc03ce2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code class="C++">/**    第二配置器的部分代码*/enum{__ALIGN = 8};   // 小型区块的上调边界  ，分配内存不足8的补齐8enum {__MAX_BYTES = 128};        //小型区块的上限enum {__NFREELISTS = __MAX_BYTES / __ALIGN};  // free-liststemplate&lt;bool threads, in inst&gt;  // 第一参数 多线程， 第二参数 无用class __default_alloc_template{private:// round_up() 将byte上调至8的倍数static size_t ROUND_UP(size_t bytes){    return (((bytes) + __ALIGN -1) &amp; ~(__ALIGN -1));}private:    union obj{        // free-lists 的节点构造        union obj * free_list_link;        char client_data[1];      };private:    static obj* vaolatile free_list[__NFREELISTS];   // 16个列表    static size_t FREELIST_INDEX(size_t bytes){        return (((bytes) + __ALIGN -1) / __ALIGN - );    }    static void* refill(size_t n);    // 返回一个大小为n的对象，可能加入大小为n的其他区块到free list    static char* chunk_alloc(size_t size, int &amp; nobjs);        //配置一大块内存，容纳nojbs个“size”的区块// static data membersstatic char* start_free;  // 内存池起始位置static char* end_free;static size_t heap_size;// 成员函数// 省略public:    static void* allocate(size_t n){  // n 大于0/* 后详*/}    static void deallocate(void* p , size_t n){/*后详*/};    static void* reallocate(void* p, size_t old_size, size_t new_size);};// 静态变量的初始化 // 省略</code></pre><p>(2) <strong>配置器函数allocate</strong></p><ul><li>第二级配置器分配内存的过程：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5f57f1d1a29d7128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code class="C++">    static void* allocate(size_t n){  // n 大于0        obj* volatile * my_free_list;        obj* result;        // 大于128bytes        if(n &gt; (size_t)__MAX_BYTES){            return (malloc_alloc::allocate(n));        }        // 寻找16个free_list中的一个        my_free_list = free_list + FREELIST_INDEX(n);        result = *my_free_list;        if(0 == result){            // 没有可用的free_list,准备填充free list            void* r = refill(ROUND_UP(n));            return r;        }        // 调整free list        * my_free_list = result-&gt;free_list_link;  // 将result指向的区块移除，my_free_list 指向result的后续        return result;    }</code></pre><p>(3) <strong>配置器函数deallocate()</strong></p><ul><li>同样，如果区块大于128bytes调用第一级配置器；</li><li>小于128bytes就找到相应的free list ，并将区块收回；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-db5f494e259f11b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code class="C++">    static void deallocate(void* p , size_t n){        obj* q = (obj*)p;        obj* volatile * my_free_list;        //大于128bytes 调用第一级配置器        if(n&gt;(size_t)__MAX_BYTES)        {            malloc::deallocate(p, n);            return;        }        // 寻找对应的free list        my_free_list = free_list + FREELIST_INDEX(n);        q-&gt;free_list_link = *my_free_list;        *my_free_list = q;    }</code></pre><p>(4)  <strong>重新填充 free lists</strong></p><ul><li>free list中没有可用区块的时候，调用<code>refill()</code>，为free list填充空间，新的空间取自内存池(chunk_alloc()完成)，缺省取得20个新节点，如果内存池不足，可能小于20个；<br><code>`</code>C++</li></ul><p>template<bool threads,="" int="" inst=""><br>void<em> __default_alloc_template&lt;threads, inst&gt;::refill(size_t n){<br>    int nobjs = 20;<br>    // 调用chunk_alloc()，nobjs 是引用传值<br>    char</em> chunk = chunk_alloc(n, nobjs);  </bool></p><pre><code>obj* volatile * my_free_list;obj* result;obj* current_obj, * next_obj;int i;// 如果只获得一个区块，直接分给调用者，free list 无新节点if(1 == nobjs )retun (chunk);//否则准备调整free list , 接入新节点my_free_list = free_list + FREELIST_INDEX(n);// 以下在chunk空间建立free list result = (obj*) chunk;  // 这一块返回客户端//导引free list 指向新配置的空间*my_free_list = next_obj = (obj*) (chunk+n);// 从1开始，第o个返回给客端for（int i= 1;; i++){    current_obj = next_obj;    next_obj = (obj*)((char*)next_obj + n); //分块    if(nobjs -1 == i){   // 最后一块        current_obj-&gt;free_list_link =0;        break;    }else{        current_obj -&gt;free_list_link = next_obj;    }}return result;</code></pre><p>}</p><pre><code>(5) **内存池(memory pool)**- 当free list中区块不够的时候，需要从内存池中取得新的区块；- `chunk_alloc()`完成这项任务：```C++// chunk_alloctemplate&lt;bool threads, in inst&gt;char* __default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int&amp; nobjs){    char* result;    size_t total_bytes = size * nobjs;    size_t bytes_left = end_free - start_free;  // 内存池剩余空间    if(bytes_left &gt;= total_bytes){        result = start_free;        start_free += total_bytes;        return result;    }else if(bytes_left &gt;=size){        // 剩余空间不能满足所有需求量，但足够供应一个以上的区块        nobjs = bytes_left / size;        total_bytes = size * nobjs;        result = start_free;        start_free += total_bytes;        return result;    }else{        //内存池剩余空间不能满足一个区块        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);        if(bytes_left &gt; 0){            //内存池还有零头，线分配给free list            //首先寻找合适的free list            obj* volatile* my_free_list = free_list +                 FREELIST_INDEX(bytes_left);            // 调整free list, 将内存中的残余空间编入            ((obj*)start_free)-&gt;free_list_link = *my_free_list;            *my_free_list = (obj*)start_free;        }        // 配置heap空间，用来补充内存池        start_free = (char*)malloc(bytes_to_get);        if(0 == start_free){            // heap 空间不足， malloc失败            int i;            obj* volatile* my_free_list,*p;            // 搜索适当的free list: 指的是“尚有未用完，而且区块够大”的free list            for(i = size;i&lt;__MAX_BYTES; i+=__ALIGN){                my_free_list = free_list + FREELIST_INDEX(i);                p = *my_free_list;                if(0 != p){ // free_list 有未用完区块                    *my_free_list = p-&gt;free_list_link;                    start_free = (char*)p;                    end_free = start_free +i;                    //递归调用自己，为了修正nobjs                    return chunk_alloc(size, nobjs);                    // 注意： 任何残零头部都被编入到free-list 中备用                }            }            end_free =0; // 如果出现意外，没有任何内存可用            // 调用第一级配置器，看看是oom否有用            start_free = (char*)malloc_alloc:allocate(bytes_to_get);            // 这会导致异常，或者存不足的情况获得改善        }        heap_size += bytes_to_get;        end_free = start_free + bytes_to_get；        //递归调用自己， 为了修正nobjs        return chunk_alloc(size, nobjs);    }    }</code></pre><ul><li><code>chunk_alloc()</code>通过<code>end_free - start_free</code>判断内存池的状态；</li><li>如果内存池剩余充分， 直接调出20个区块返回；</li><li>如果不够20个区块，返回世界能够供应的区块；</li><li>如果一个都不够，通过malloc() 从heap中配置内存– 新内存块为需求量的2倍，再加上一个随着配置次数越来越大的附加量；</li></ul><p>例子：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd0ce8eb28e51e1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/26/STL-1%E2%80%94-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A-Homework-2.3</title>
      <link>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/</link>
      <guid>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/</guid>
      <pubDate>Mon, 25 Jun 2018 08:28:37 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs231A Homework-2:ps-code2-part-3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;三、-The-Factorization-Method&quot;&gt;&lt;a href=&quot;#三、-The-Factorization
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs231A Homework-2:ps-code2-part-3</p></blockquote><hr><h1 id="三、-The-Factorization-Method"><a href="#三、-The-Factorization-Method" class="headerlink" title="三、 The Factorization Method"></a>三、 The Factorization Method</h1><ul><li>此方法用来解决SFM问题；</li></ul><h1 id="一、-算法过程"><a href="#一、-算法过程" class="headerlink" title="一、 算法过程"></a>一、 算法过程</h1><ul><li><p>Tomasi &amp; Kanade algorithm </p></li><li><p>分为两步：</p><ul><li>Data centering</li><li>Factorization</li></ul></li></ul><h2 id="1-centering-step"><a href="#1-centering-step" class="headerlink" title="1. centering step"></a>1. centering step</h2><ul><li>居中数据： 对于一张图片中的每个点，定义新的坐标点，通过减去图片中心点：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eb8a7a929e736702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>并且可知：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-386ec29786e6939a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上述两个式子可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb9796ccae27a7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>居中后的3D点和居中后的图片点通过一个2*3矩阵A相关；</p></li><li><p>但是，只知道图片中的点，不知道A和X;</p></li></ul><h2 id="2、-建立D矩阵"><a href="#2、-建立D矩阵" class="headerlink" title="2、 建立D矩阵"></a>2、 建立D矩阵</h2><p>通过建立一个处理矩阵D，由m个相机的n个观察点组成；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8b77c687821f7a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>M：2m*3</li><li>S: 3 * n</li><li>D = M * S </li><li>rank(D) = 3</li></ul><h2 id="3-因素化"><a href="#3-因素化" class="headerlink" title="3. 因素化"></a>3. 因素化</h2><p>通过使用SVD方法将D分解为运动矩阵M和结构矩阵S：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4f364584f1225c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>因为D的秩为3， 但是由于噪声和仿射变换近似，rank(D) &gt;3, 但是只需要取3仍然是最好的近似；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8a2bc38962294ff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>Tomasi and Kanade 的方法： </p><p>最佳因素化选择：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-be770447488c70bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>【问题】</p><ul><li>怎么得到M : 2m * 3? 难道其他元素为0？</li><li>S也是类似？<ul><li>因为M,S两个矩阵最大秩为3，所以两个矩阵的乘积Rank=3；实际中，D的rank大于3，但是rank为3是最佳近似；</li><li>由于D有秩为3，将分解为（2m <em> 3）(3 </em> 3)(3 * n)的三个矩阵；</li></ul></li></ul><h1 id="二、-python实现"><a href="#二、-python实现" class="headerlink" title="二、 python实现"></a>二、 python实现</h1><h2 id="1-因素化方法"><a href="#1-因素化方法" class="headerlink" title="1.因素化方法"></a>1.因素化方法</h2><pre><code class="Python">def factorization_method(points_im1, points_im2):    N = points_im1.shape[0]    points_sets = [points_im1, points_im2]      # 2* (N * 3)    # 建立D矩阵    D = np.zeros((4, N))    for i in range(len(points_sets)):   # len : 2        points = points_sets[i]        # N * 3        # 中心化点        centroid = 1.0 / N * points.sum(axis=0)     # 均值 (x,y),        points[:, 0] -= centroid[0] * np.ones(N)    # x        points[:, 1] -= centroid[1] * np.ones(N)    # y        D[2*i:2*i+2, :] = points[:, 0:2].T    # 每一副图片的(x,y)复制到D中    # svd分解D矩阵    u, s, vt = np.linalg.svd(D)    print(u.shape, s.shape, vt.shape)    print(s)    M = u[:, 0:3]      # Motion    S = np.diag(s)[0:3, 0:3].dot(vt[0:3, :])        # structure    return S, M</code></pre><p>在svd分解后，直接使用u作为M运动矩阵，S = singa*vT,作为结构矩阵；其实可以选择上面最后的最佳选择；</p><h2 id="2-主函数"><a href="#2-主函数" class="headerlink" title="2. 主函数"></a>2. 主函数</h2><pre><code class="Python">import numpy as npfrom scipy.misc import imreadimport matplotlib.pyplot as pltimport scipy.io as sioimport matplotlib.gridspec as gridspecfrom epipolar_utils import *if __name__ == &#39;__main__&#39;:    for im_set in [&#39;data/set1&#39;, &#39;data/set1_subset&#39;]:        # Read in the data        im1 = imread(im_set+&#39;/image1.jpg&#39;)        im2 = imread(im_set+&#39;/image2.jpg&#39;)        points_im1 = get_data_from_txt_file(im_set + &#39;/pt_2D_1.txt&#39;)        points_im2 = get_data_from_txt_file(im_set + &#39;/pt_2D_2.txt&#39;)        points_3d = get_data_from_txt_file(im_set + &#39;/pt_3D.txt&#39;)        assert (points_im1.shape == points_im2.shape)        # Run the Factorization Method        structure, motion = factorization_method(points_im1, points_im2)        # Plot the structure        fig = plt.figure()        ax = fig.add_subplot(121, projection = &#39;3d&#39;)        scatter_3D_axis_equal(structure[0,:], structure[1,:], structure[2,:], ax)        ax.set_title(&#39;Factorization Method&#39;)        ax = fig.add_subplot(122, projection = &#39;3d&#39;)        scatter_3D_axis_equal(points_3d[:,0], points_3d[:,1], points_3d[:,2], ax)        ax.set_title(&#39;Ground Truth&#39;)        plt.show()</code></pre><h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><pre><code>(4, 4) (4,) (37, 37)[959.5852216  540.47613178 184.43174791  27.9151956 ](4, 4) (4,) (18, 18)[264.54396508 210.06072009   7.21921783   5.12857709]</code></pre><p>图对比：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-88e8a61ad5260eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A-Homework-2.2</title>
      <link>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/</link>
      <guid>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/</guid>
      <pubDate>Mon, 25 Jun 2018 02:32:43 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs231A Homework-2:ps-code2-part-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;2-图片校正-之-单应性匹配&quot;&gt;&lt;a href=&quot;#2-图片校正-之-单应性匹配&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs231A Homework-2:ps-code2-part-2</p></blockquote><hr><h1 id="2-图片校正-之-单应性匹配"><a href="#2-图片校正-之-单应性匹配" class="headerlink" title="2 图片校正 之 单应性匹配"></a>2 图片校正 之 单应性匹配</h1><h2 id="2-1-求解过程"><a href="#2-1-求解过程" class="headerlink" title="2.1 求解过程"></a>2.1 求解过程</h2><p> 校正两个图片不需要就知道相机的内参K和外参矩阵R,T，只需要通过基础矩阵计算极线；<br>然后计算所以极线的交点—极点；由于噪点的干扰，不可能交于一点，因此计算极点，利用最小二乘方法求得极线拟合一点；<br>并且在极线上的每一点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-041355bcb93319ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-70ef22c82e308bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果定义极线集合：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ad1cd071a0b7c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-80295e9834fc1d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因此整个步骤为：</p><ul><li><ol><li>通过归一化8点算法获取基本矩阵</li></ol></li><li><ol start="2"><li>极线交于极点： 通过最小二乘误差拟合</li></ol></li><li><ol start="3"><li>svd计算 极点</li></ol></li></ul><hr><blockquote><p>在求得极点e,e’后，如果极点在水平方向上不是无限的，说明图片没有平行，如果点是无限的，说明图片平行了；</p></blockquote><p>因此，我们的目的：</p><ul><li><strong>寻找一对单应性矩阵H1,H2,使得极点无穷，即两张图片平行；</strong></li></ul><hr><p>(1). <strong>寻找H2：令e’在水平方向上无限,即为点（f,0,0）</strong></p><ul><li>将第二幅图的中心移动到(0,0,1)在齐次坐标系下；<br>这个平移矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f15f7e8f6c1d82a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>应用一个旋转矩阵：使极点坐标旋转到水平坐标轴上，变为(f, 0, 1)</strong></p><ul><li>如果e‘在平移后Te’的坐标为：(e1’,e2’,1)，旋转矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2b8848d72443787d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-33ebdcfefbcfc87e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(3). <strong>将极点坐标由(f,0,1)==&gt;(f,0,0)</strong></p><ul><li>只需要变换矩阵：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4cf916086e001850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>经过上面几个步骤。我们可以得到无限极点：这个单应性变换H2为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eceae870c337bd04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><ul><li><strong>为了寻找单应性矩阵H1,,需要最小化两个图片对应点的均方差之和来获得H1</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ebe437f9682f42c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求导后，可以得到：</p><p>!<img src="https://upload-images.jianshu.io/upload_images/5361608-dffe23f713cf43f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算式子中的未知参数：</p><p>(1). <strong>首先计算M</strong></p><ul><li><p>任意3*3的斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ca1aac7031b398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>因为任何向量的叉积矩阵 是一个斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58e56509b18c3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图，a向量的叉乘矩阵为斜对称矩阵；</p><p>因此，前面公式中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e933426be143035d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>合并后，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb430c0d0009a532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果M每一列缩放e，则F也需要变化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c2760d1d20996d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8d6728c7d829f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>计算Ha矩阵中的参数a</strong></p><ul><li>已经知道了H2, M，如果将图片1中的点p变换到图片2中，然后经过H2变换：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d3dd8c3950e7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b26168a6bf4b3003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这两个点应该是最近点，然后使用最小二乘发来最小化误差：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c45f913af4b55069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设两个点齐次坐标为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c7c39a32c60e82ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最小化式子为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03f84d774d3fede2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为最后一项两个点在水平线上，则为常数</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2548833df47c882f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终，这个问题变成了解决最小二乘问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd8f6953623efa08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4b3993661018b687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求得a的参数后，得到了HA,H2,M三个矩阵，根据上面的式子：<br>最终可以求得H1；</p><hr><h2 id="2-2-python-实现"><a href="#2-2-python-实现" class="headerlink" title="2.2 python 实现"></a>2.2 python 实现</h2><p>在经过上面的了解：</p><h3 id="一、-计算极点"><a href="#一、-计算极点" class="headerlink" title="一、 计算极点"></a>一、 计算极点</h3><pre><code class="Python">def compute_epipole(points1, points2, F):    # F.Tp2 = l, 求得p2到p1面上的映射直线    line = F.T.dot(points2.T)  # 3 * N    lineT = line.T      # N * 3    u, s, vt = np.linalg.svd(lineT)    e = vt[-1, :]       # 最优解    e /= e[2]       # 齐次坐标（x, y, 1）    return e</code></pre><h3 id="二、-计算-H1-H2"><a href="#二、-计算-H1-H2" class="headerlink" title="二、 计算 H1,H2"></a>二、 计算 H1,H2</h3><pre><code class="Python">def compute_matching_homographies(e2, F, im2, points1, points2):    # 首先计算H2    W = im2.shape[1]    H = im2.shape[0]    # 平移矩阵T    T = np.identity(3)    T[0, 2] = -1.0 * W /2    T[1, 2] = -1.0 * H /2    # 旋转矩阵R    e = T.dot(e2)   # 极点平移过后形成（x&#39;,y&#39;,1）    e_x = e[0]    e_y = e[1]    if e_x &gt;= 0:        alpha = 1.0    else:        alpha = -1.0    # 旋转矩阵alpha 正负判断    R = np.identity(3)    R[0, 0] = alpha * e_x / np.sqrt(e_x**2 + e_y**2)    R[0, 1] = alpha * e_y / np.sqrt(e_x**2 + e_y**2)    R[1, 0] = -alpha * e_y / np.sqrt(e_x**2 + e_y**2)    R[1, 1] = alpha * e_x / np.sqrt(e_x**2 + e_y**2)    # 矩阵G    f = R.dot(e)[0]     # R变换之后，e==&gt;(f,0,1)    G = np.identity(3)    G[2, 0] = -1.0 / f    H2 = np.linalg.inv(T).dot(G.dot(R.dot(T)))     # H2 = T^-1 G R T    # ===============================    # 计算H1 , H1 = HaH2M    # 首先计算M    e_p = np.zeros((3, 3))    e_p[0, 1] = - e2[2]    e_p[0, 2] = e2[1]    e_p[1, 0] = e2[2]    e_p[1, 2] = - e2[0]    e_p[2, 0] = - e2[1]    e_p[2, 1] = e2[0]   # skew-symmetric 矩阵    v = np.array([1, 1, 1])    M = e_p.dot(F) + np.outer(e2, v)    # e2*VT = (3,3)    # 计算Ha    p1_hat = H2.dot(M.dot(points1.T)).T     # p1_hat = H2Mp  3 * N,转置之后 N * 3    p2_hat = H2.dot(points2.T).T            # pe_hat = H2p&#39; , 3 * N ,转置之后 N * 3    W = p1_hat / p1_hat[:, 2].reshape(-1, 1)    # 齐次坐标系    b = (p2_hat / p2_hat[:, 2].reshape(-1, 1))[:, 0]    # 最小二乘问题    a1, a2, a3 = np.linalg.lstsq(W, b, rcond=None)[0]    HA = np.identity(3)    HA[0] = np.array([a1, a2, a3])    H1 = HA.dot(H2).dot(M)      # H1 = HaH2M    return H1, H2</code></pre><h3 id="三、-主函数"><a href="#三、-主函数" class="headerlink" title="三、 主函数"></a>三、 主函数</h3><pre><code class="Python">if __name__ == &#39;__main__&#39;:    # Read in the data    im_set = &#39;data/set1&#39;    im1 = imread(im_set+&#39;/image1.jpg&#39;)    im2 = imread(im_set+&#39;/image2.jpg&#39;)    points1 = get_data_from_txt_file(im_set+&#39;/pt_2D_1.txt&#39;)    points2 = get_data_from_txt_file(im_set+&#39;/pt_2D_2.txt&#39;)    assert (points1.shape == points2.shape)    F = normalized_eight_point_alg(points1, points2)    e1 = compute_epipole(points1, points2, F)    e2 = compute_epipole(points2, points1, F.transpose())    print(&quot;e1&quot;, e1)    print(&quot;e2&quot;, e2)    # Find the homographies needed to rectify the pair of images    H1, H2 = compute_matching_homographies(e2, F, im2, points1, points2)    print(&quot;H1:\n&quot;, H1)    print    print(&quot;H2:\n&quot;, H2)    # Transforming the images by the homographies    new_points1 = H1.dot(points1.T)    new_points2 = H2.dot(points2.T)    new_points1 /= new_points1[2,:]    new_points2 /= new_points2[2,:]    new_points1 = new_points1.T    new_points2 = new_points2.T    rectified_im1, offset1 = compute_rectified_image(im1, H1)    rectified_im2, offset2 = compute_rectified_image(im2, H2)    new_points1 -= offset1 + (0,)    new_points2 -= offset2 + (0,)    # Plotting the image    F_new = normalized_eight_point_alg(new_points1, new_points2)    plot_epipolar_lines_on_images(new_points1, new_points2, rectified_im1, rectified_im2, F_new)    plt.show()</code></pre><h3 id="四、-结果"><a href="#四、-结果" class="headerlink" title="四、 结果"></a>四、 结果</h3><pre><code>e1 [-1.30071143e+03 -1.42448272e+02  1.00000000e+00]e2 [1.65412463e+03 4.53021078e+01 1.00000000e+00]H1: [[-1.20006316e+01 -4.15501447e+00 -1.23476881e+02] [ 1.41006481e+00 -1.48704147e+01 -2.84177469e+02] [-9.21889298e-03 -2.19184511e-03 -1.23033440e+01]]H2: [[ 8.09798131e-01 -1.22036874e-01  7.99331183e+01] [-3.00186699e-02  1.01581538e+00  3.63604348e+00] [-6.99360915e-04  1.05393946e-04  1.15205554e+00]]</code></pre><p>调整过后的图片为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d76d7018232d0b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A-Homework-2.1</title>
      <link>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</link>
      <guid>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</guid>
      <pubDate>Sat, 23 Jun 2018 09:35:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A-Homework-2:ps-code2-part-1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、-从对应点估计基础矩阵&quot;&gt;&lt;a href=&quot;#一、-从对应点估计基础矩阵&quot; class=&quot;headerlink&quot; title
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A-Homework-2:ps-code2-part-1</p></blockquote><h1 id="一、-从对应点估计基础矩阵"><a href="#一、-从对应点估计基础矩阵" class="headerlink" title="一、 从对应点估计基础矩阵"></a>一、 从对应点估计基础矩阵</h1><ul><li><p>本题要求从对应点估计基础矩阵，使用二种方法：</p><ul><li>线性最小二乘法的八点算法</li><li>归一化八点算法</li></ul></li><li><p>笔记：</p><ul><li><a href="https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/">对极几何</a><h2 id="1-1-八点算法–-基础矩阵求解过程"><a href="#1-1-八点算法–-基础矩阵求解过程" class="headerlink" title="1.1 八点算法– 基础矩阵求解过程"></a>1.1 八点算法– 基础矩阵求解过程</h2></li></ul></li><li><p>给予两张图片，没有相机内外参数；</p></li><li><p>求出基本矩阵</p></li><li><p>方法： ‘<em>Eight-Point 算法</em> ‘</p></li></ul><hr><ol><li>至少8对 对应点</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-750407be55d3a189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>则每队对对应点满足：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-39605f51776577d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>即：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b2ab3e15ad77b5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>展开，可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-321f94cfacb01aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于所有对应点，使用一下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c3ec40ba81b3477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>简写为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5766d9a159915312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>W ： N*9 矩阵 ， N: 对应对的数量</li><li>f: 基本矩阵</li></ul><hr><ul><li>使用svd分解</li><li>w: 非满秩的</li><li>f: 真实的基本矩阵秩为2 </li><li>#<a href="https://blog.csdn.net/kokerf/article/details/72630863?locationNum=2&amp;fps=1" target="_blank" rel="noopener">基本矩阵的基本解法之8点算法</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-67d92e80c6b464f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这里进行了两次SVD分解；</li><li>首先获得F矩阵的近似；</li><li>第二次获得RANK为2的F;</li></ul><pre><code class="python"># points1, points2 都是np.arraydef lls_eight_point_alg(points1, points2):    len = points1.shape[0]    W = np.zeros((len, 9))   # 37 * 9 齐次矩阵    for i in range(len):        u1 = points1[i, 0]        v1 = points1[i, 1]        u2 = points2[i, 0]        v2 = points2[i, 1]        W[i] = np.r_[u1*u2, u2*v1, u2, v2*u1, v1*v2, v2, u1, v1, 1]    # SVD    U, S, VT = np.linalg.svd(W, full_matrices=True)    f = VT[-1, :]   # 最后一行为最优解    F_hat = np.reshape(f, (3, 3))    # 最小二乘的近似    # 计算rank =2 的F    U, S_hat, VT = np.linalg.svd(F_hat, full_matrices=True)    s = np.zeros((3, 3))   # sigma 矩阵    s[0, 0] = S_hat[0]    s[1, 1] = S_hat[1]  # sigma 的Rank为2    F = np.dot(U, np.dot(s, VT))    return F</code></pre><h2 id="2-归一化八点算法"><a href="#2-归一化八点算法" class="headerlink" title="2. 归一化八点算法"></a>2. 归一化八点算法</h2><p>标准的8点算法存在的问题：</p><ul><li>p点， 和通过基本矩阵将点p’映射到的极线上l= Fp’，两者的距离很大；点和极线之间的均值误差如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-091b3647c850b792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>8个对应点组成的矩阵W： 最好只有一个奇异值为0或者近似为0,其他的都为非零；这样能够使得svd效果好；</li><li>像素值的范围过大；如pi = (1832; 1023;)</li></ul><hr><p>解决方法：</p><ul><li>归一化像素点<ul><li><ol><li>新坐标系的原点应该位于图像点的质心处（平移）；<br>表示为：</li></ol></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6349e1ccc32f9d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>其次，变换后的图像点距原点的均方距离应为2像素（缩放）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a06c93ec30ac32aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图所示，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-446adabfc4846b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后用新坐标系下的图像应用8点算法计算出Fq；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97bf6c2a7e7c0064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后通过反归一化，获得真实的基本矩阵；</p><hr><p>整个算法分为三个步骤：</p><ul><li>归一化，对每个点进行缩放</li><li>八点算法计算Fq,</li><li>反归一化</li></ul><p>(1) 归一化： 先平移到新坐标系，在缩放<br><img src="http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%20%26s_%7Bx%7D%20%260%20%26s_%7Bx%7Dt_%7Bx%7D%5C%5C%20%260%20%26s_%7By%7D%20%26s_%7By%7Dt_%7By%7D%5C%5C%20%260%20%260%20%261%20%5Cend%7Bbmatrix%7D%20*%20%5Cbegin%7Bbmatrix%7D%20x%5C%5C%20y%5C%5C%201%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20s_%7Bx%7D%28x&plus;t_%7Bx%7D%29%5C%5C%20s_%7By%7D%28y&plus;t_%7By%7D%29%5C%5C%201%20%5Cend%7Bbmatrix%7D" alt=""></p><p>其中，缩放系数为：<br><img src="http://latex.codecogs.com/gif.latex?%5Csqrt%7B2/%28%5Csum_%7Bi%3D0%7D%5E%7Bn%7D%28x_%7Bi%7D%20-%20%5Coverline%7Bx%7D%29%5E%7B2%7D%20/%20N%29%20%7D" alt=""></p><p>代码为：</p><pre><code class="python">def normalized_eight_point_alg(points1, points2):    N = points1.shape[0]    points1_uv = points1[:, 0:2]    points2_uv = points2[:, 0:2]    # 取x,y 坐标    #    # 取坐标均值    points1_mean = np.mean(points1_uv, axis=0)    points2_mean = np.mean(points2_uv, axis=0)    # 点集的到中心的差    points1_new = points1_uv - points1_mean    points2_new = points2_uv - points2_mean    # 计算缩放参数    scale = np.sqrt(np.sum(points1_new**2)/N)    scale1 = np.sqrt(2 / (np.sum(points1_new**2)/N * 1.0))    scale2 = np.sqrt(2 / (np.sum(points2_new**2)/N * 1.0))    # 归一化矩阵    T1 = np.array([        [scale1, 0, -points1_mean[0] * scale1],        [0, scale1, -points1_mean[1] * scale2],        [0, 0, 1]    ])    T2 = np.array([        [scale2, 0, -points2_mean[0] * scale2],        [0, scale2, -points2_mean[1] * scale2],        # 在看到的别人答案中别人取_mean[0]，我觉得应该取[1],因为是y的差        [0, 0, 1]    ])    # 对坐标点变换    q1 = T1.dot(points1.T).T    # N * 3    q2 = T2.dot(points2.T).T    # N * 3    # 八点算法    Fq = lls_eight_point_alg(q1, q2)    #反归一化    F = T2.T.dot(Fq).dot(T1)    return F</code></pre><h2 id="3-计算平均距离"><a href="#3-计算平均距离" class="headerlink" title="3. 计算平均距离"></a>3. 计算平均距离</h2><ul><li>通过公式将p2的点映射成为p1面上的一条直线—极线</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-47c66c9adca14dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>可以通过点到直线的距离公式计算平均距离：</li></ul><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=930595087,3467127615&amp;fm=58" alt=""></p><p>代码为：</p><pre><code class="python">def compute_distance_to_epipolar_lines(points1, points2, F):    # F.Tp2 = l, 求得p2到p1面上的映射直线    line = F.T.dot(points2.T)  # 3 * N    dis_sum = 0    N = points1.shape[0]    for i in range(N):        x = points1[i, 0]        y = points1[i, 1]        A = line[0, i]        B = line[1, i]        C = line[2, i]        dis_sum += np.abs(A*x + B*y + C) / np.sqrt(A**2 + B**2)    return dis_sum / N      # 平均距离</code></pre><h2 id="4-画出极线"><a href="#4-画出极线" class="headerlink" title="4. 画出极线"></a>4. 画出极线</h2><pre><code class="python">    plt.subplot(1, 2, 1)  # 建立1*2 的图    line1 = F.T.dot(points2.T)   # p2到p1面上的极线     3 * N    N1 = line1.shape[1]     # 极线的数量    for i in range(N1):        A = line1[0, i]        B = line1[1, i]        C = line1[2, i]  # 极线的参数: Ax + By + C =0; ==&gt; y = (-A/B)x - (C/B)        W = im1.shape[1]    # 图片width，        y1 = -C/B       # (0,y1)        y2 = -(A * W + C) / B   # (W, y2)        plt.plot([0, W], [y1, y2], &#39;r&#39;)     # 画出每一条极线        plt.plot([points1[i, 0]], [points1[i, 1]], &quot;b*&quot;)    # 画出 每个极点的（x，y）坐标    plt.imshow(im1, cmap=&#39;gray&#39;)    # 第二幅图片    plt.subplot(1, 2, 2)    line2 = F.dot(points1.T)    N2 = line2.shape[1]    for i in range(N1):        A = line2[0, i]        B = line2[1, i]        C = line2[2, i]  # 极线的参数: Ax + By + C =0; ==&gt; y = (-A/B)x - (C/B)        W = im1.shape[1]    # 图片width，        y1 = -C/B       # (0,y1)        y2 = -(A * W + C) / B   # (W, y2)        plt.plot([0, W], [y1, y2], &#39;r&#39;)     # 画出每一条极线        plt.plot([points2[i, 0]], [points2[i, 1]], &quot;b*&quot;)    # 画出 每个极点的（x，y）坐标    plt.imshow(im2, cmap=&#39;gray&#39;)</code></pre><p>结果为：</p><pre><code>Set: data/set1--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[ 1.55218081e-06 -8.18161523e-06 -1.50440111e-03] [-5.86997052e-06 -3.02892219e-07 -1.13607605e-02] [-3.52312036e-03  1.41453881e-02  9.99828068e-01]]Distance to lines in image 1 for LLS: 28.025662937533877Distance to lines in image 2 for LLS: 25.162875800036915p&#39;^T F p = 0.03156399064220228Fundamental Matrix from normalized 8-point algorithm: [[ 5.93261511e-07 -5.08492255e-06  8.76427688e-05] [-4.66834735e-06 -3.20108624e-07 -6.12207138e-03] [-7.74714403e-04  8.42028676e-03  1.25311400e-01]]Distance to lines in image 1 for normalized: 0.9431072572196602Distance to lines in image 2 for normalized: 0.8719800541568359--------------------------------------------------------------------------------Set: data/set2--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[-5.63087200e-06  2.74976583e-05 -6.42650411e-03] [-2.77622828e-05 -6.74748522e-06  1.52182033e-02] [ 1.07623595e-02 -1.22519240e-02 -9.99730547e-01]]Distance to lines in image 1 for LLS: 9.701438829435915Distance to lines in image 2 for LLS: 14.568227190498229p&#39;^T F p = 0.03149037056281445Fundamental Matrix from normalized 8-point algorithm: [[-1.53880961e-07  2.46528633e-06 -1.57563630e-04] [ 3.50323566e-06  3.08159735e-07  6.82243058e-03] [ 2.42265054e-04 -8.27925885e-03 -4.08002117e-03]]Distance to lines in image 1 for normalized: 0.8955997529976532Distance to lines in image 2 for normalized: 0.8959928005846117</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ce26c6c5b0b7826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
