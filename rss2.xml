<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Mon, 25 Jun 2018 08:32:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CS231A-Homework-2.3</title>
      <link>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/</link>
      <guid>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/</guid>
      <pubDate>Mon, 25 Jun 2018 08:28:37 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs231A Homework-2:ps-code2-part-3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;三、-The-Factorization-Method&quot;&gt;&lt;a href=&quot;#三、-The-Factorization
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs231A Homework-2:ps-code2-part-3</p></blockquote><hr><h1 id="三、-The-Factorization-Method"><a href="#三、-The-Factorization-Method" class="headerlink" title="三、 The Factorization Method"></a>三、 The Factorization Method</h1><ul><li>此方法用来解决SFM问题；</li></ul><h1 id="一、-算法过程"><a href="#一、-算法过程" class="headerlink" title="一、 算法过程"></a>一、 算法过程</h1><ul><li><p>Tomasi &amp; Kanade algorithm </p></li><li><p>分为两步：</p><ul><li>Data centering</li><li>Factorization</li></ul></li></ul><h2 id="1-centering-step"><a href="#1-centering-step" class="headerlink" title="1. centering step"></a>1. centering step</h2><ul><li>居中数据： 对于一张图片中的每个点，定义新的坐标点，通过减去图片中心点：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eb8a7a929e736702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>并且可知：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-386ec29786e6939a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上述两个式子可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb9796ccae27a7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>居中后的3D点和居中后的图片点通过一个2*3矩阵A相关；</p></li><li><p>但是，只知道图片中的点，不知道A和X;</p></li></ul><h2 id="2、-建立D矩阵"><a href="#2、-建立D矩阵" class="headerlink" title="2、 建立D矩阵"></a>2、 建立D矩阵</h2><p>通过建立一个处理矩阵D，由m个相机的n个观察点组成；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8b77c687821f7a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>M：2m*3</li><li>S: 3 * n</li><li>D = M * S </li><li>rank(D) = 3</li></ul><h2 id="3-因素化"><a href="#3-因素化" class="headerlink" title="3. 因素化"></a>3. 因素化</h2><p>通过使用SVD方法将D分解为运动矩阵M和结构矩阵S：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4f364584f1225c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>因为D的秩为3， 但是由于噪声和仿射变换近似，rank(D) &gt;3, 但是只需要取3仍然是最好的近似；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8a2bc38962294ff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>Tomasi and Kanade 的方法： </p><p>最佳因素化选择：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-be770447488c70bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>【问题】</p><ul><li>怎么得到M : 2m * 3? 难道其他元素为0？</li><li>S也是类似？<ul><li>因为M,S两个矩阵最大秩为3，所以两个矩阵的乘积Rank=3；实际中，D的rank大于3，但是rank为3是最佳近似；</li><li>由于D有秩为3，将分解为（2m <em> 3）(3 </em> 3)(3 * n)的三个矩阵；</li></ul></li></ul><h1 id="二、-python实现"><a href="#二、-python实现" class="headerlink" title="二、 python实现"></a>二、 python实现</h1><h2 id="1-因素化方法"><a href="#1-因素化方法" class="headerlink" title="1.因素化方法"></a>1.因素化方法</h2><pre><code class="Python">def factorization_method(points_im1, points_im2):    N = points_im1.shape[0]    points_sets = [points_im1, points_im2]      # 2* (N * 3)    # 建立D矩阵    D = np.zeros((4, N))    for i in range(len(points_sets)):   # len : 2        points = points_sets[i]        # N * 3        # 中心化点        centroid = 1.0 / N * points.sum(axis=0)     # 均值 (x,y),        points[:, 0] -= centroid[0] * np.ones(N)    # x        points[:, 1] -= centroid[1] * np.ones(N)    # y        D[2*i:2*i+2, :] = points[:, 0:2].T    # 每一副图片的(x,y)复制到D中    # svd分解D矩阵    u, s, vt = np.linalg.svd(D)    print(u.shape, s.shape, vt.shape)    print(s)    M = u[:, 0:3]      # Motion    S = np.diag(s)[0:3, 0:3].dot(vt[0:3, :])        # structure    return S, M</code></pre><p>在svd分解后，直接使用u作为M运动矩阵，S = singa*vT,作为结构矩阵；其实可以选择上面最后的最佳选择；</p><h2 id="2-主函数"><a href="#2-主函数" class="headerlink" title="2. 主函数"></a>2. 主函数</h2><pre><code class="Python">import numpy as npfrom scipy.misc import imreadimport matplotlib.pyplot as pltimport scipy.io as sioimport matplotlib.gridspec as gridspecfrom epipolar_utils import *if __name__ == &#39;__main__&#39;:    for im_set in [&#39;data/set1&#39;, &#39;data/set1_subset&#39;]:        # Read in the data        im1 = imread(im_set+&#39;/image1.jpg&#39;)        im2 = imread(im_set+&#39;/image2.jpg&#39;)        points_im1 = get_data_from_txt_file(im_set + &#39;/pt_2D_1.txt&#39;)        points_im2 = get_data_from_txt_file(im_set + &#39;/pt_2D_2.txt&#39;)        points_3d = get_data_from_txt_file(im_set + &#39;/pt_3D.txt&#39;)        assert (points_im1.shape == points_im2.shape)        # Run the Factorization Method        structure, motion = factorization_method(points_im1, points_im2)        # Plot the structure        fig = plt.figure()        ax = fig.add_subplot(121, projection = &#39;3d&#39;)        scatter_3D_axis_equal(structure[0,:], structure[1,:], structure[2,:], ax)        ax.set_title(&#39;Factorization Method&#39;)        ax = fig.add_subplot(122, projection = &#39;3d&#39;)        scatter_3D_axis_equal(points_3d[:,0], points_3d[:,1], points_3d[:,2], ax)        ax.set_title(&#39;Ground Truth&#39;)        plt.show()</code></pre><h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><pre><code>(4, 4) (4,) (37, 37)[959.5852216  540.47613178 184.43174791  27.9151956 ](4, 4) (4,) (18, 18)[264.54396508 210.06072009   7.21921783   5.12857709]</code></pre><p>图对比：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-88e8a61ad5260eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A-Homework-2.2</title>
      <link>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/</link>
      <guid>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/</guid>
      <pubDate>Mon, 25 Jun 2018 02:32:43 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs231A Homework-2:ps-code2-part-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;2-图片校正-之-单应性匹配&quot;&gt;&lt;a href=&quot;#2-图片校正-之-单应性匹配&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs231A Homework-2:ps-code2-part-2</p></blockquote><hr><h1 id="2-图片校正-之-单应性匹配"><a href="#2-图片校正-之-单应性匹配" class="headerlink" title="2 图片校正 之 单应性匹配"></a>2 图片校正 之 单应性匹配</h1><h2 id="2-1-求解过程"><a href="#2-1-求解过程" class="headerlink" title="2.1 求解过程"></a>2.1 求解过程</h2><p> 校正两个图片不需要就知道相机的内参K和外参矩阵R,T，只需要通过基础矩阵计算极线；<br>然后计算所以极线的交点—极点；由于噪点的干扰，不可能交于一点，因此计算极点，利用最小二乘方法求得极线拟合一点；<br>并且在极线上的每一点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-041355bcb93319ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-70ef22c82e308bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果定义极线集合：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ad1cd071a0b7c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-80295e9834fc1d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因此整个步骤为：</p><ul><li><ol><li>通过归一化8点算法获取基本矩阵</li></ol></li><li><ol start="2"><li>极线交于极点： 通过最小二乘误差拟合</li></ol></li><li><ol start="3"><li>svd计算 极点</li></ol></li></ul><hr><blockquote><p>在求得极点e,e’后，如果极点在水平方向上不是无限的，说明图片没有平行，如果点是无限的，说明图片平行了；</p></blockquote><p>因此，我们的目的：</p><ul><li><strong>寻找一对单应性矩阵H1,H2,使得极点无穷，即两张图片平行；</strong></li></ul><hr><p>(1). <strong>寻找H2：令e’在水平方向上无限,即为点（f,0,0）</strong></p><ul><li>将第二幅图的中心移动到(0,0,1)在齐次坐标系下；<br>这个平移矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f15f7e8f6c1d82a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>应用一个旋转矩阵：使极点坐标旋转到水平坐标轴上，变为(f, 0, 1)</strong></p><ul><li>如果e‘在平移后Te’的坐标为：(e1’,e2’,1)，旋转矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2b8848d72443787d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-33ebdcfefbcfc87e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(3). <strong>将极点坐标由(f,0,1)==&gt;(f,0,0)</strong></p><ul><li>只需要变换矩阵：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4cf916086e001850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>经过上面几个步骤。我们可以得到无限极点：这个单应性变换H2为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eceae870c337bd04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><ul><li><strong>为了寻找单应性矩阵H1,,需要最小化两个图片对应点的均方差之和来获得H1</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ebe437f9682f42c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求导后，可以得到：</p><p>!<img src="https://upload-images.jianshu.io/upload_images/5361608-dffe23f713cf43f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算式子中的未知参数：</p><p>(1). <strong>首先计算M</strong></p><ul><li><p>任意3*3的斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ca1aac7031b398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>因为任何向量的叉积矩阵 是一个斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58e56509b18c3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图，a向量的叉乘矩阵为斜对称矩阵；</p><p>因此，前面公式中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e933426be143035d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>合并后，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb430c0d0009a532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果M每一列缩放e，则F也需要变化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c2760d1d20996d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8d6728c7d829f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>计算Ha矩阵中的参数a</strong></p><ul><li>已经知道了H2, M，如果将图片1中的点p变换到图片2中，然后经过H2变换：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d3dd8c3950e7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b26168a6bf4b3003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这两个点应该是最近点，然后使用最小二乘发来最小化误差：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c45f913af4b55069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设两个点齐次坐标为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c7c39a32c60e82ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最小化式子为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03f84d774d3fede2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为最后一项两个点在水平线上，则为常数</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2548833df47c882f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终，这个问题变成了解决最小二乘问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd8f6953623efa08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4b3993661018b687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求得a的参数后，得到了HA,H2,M三个矩阵，根据上面的式子：<br>最终可以求得H1；</p><hr><h2 id="2-2-python-实现"><a href="#2-2-python-实现" class="headerlink" title="2.2 python 实现"></a>2.2 python 实现</h2><p>在经过上面的了解：</p><h3 id="一、-计算极点"><a href="#一、-计算极点" class="headerlink" title="一、 计算极点"></a>一、 计算极点</h3><pre><code class="Python">def compute_epipole(points1, points2, F):    # F.Tp2 = l, 求得p2到p1面上的映射直线    line = F.T.dot(points2.T)  # 3 * N    lineT = line.T      # N * 3    u, s, vt = np.linalg.svd(lineT)    e = vt[-1, :]       # 最优解    e /= e[2]       # 齐次坐标（x, y, 1）    return e</code></pre><h3 id="二、-计算-H1-H2"><a href="#二、-计算-H1-H2" class="headerlink" title="二、 计算 H1,H2"></a>二、 计算 H1,H2</h3><pre><code class="Python">def compute_matching_homographies(e2, F, im2, points1, points2):    # 首先计算H2    W = im2.shape[1]    H = im2.shape[0]    # 平移矩阵T    T = np.identity(3)    T[0, 2] = -1.0 * W /2    T[1, 2] = -1.0 * H /2    # 旋转矩阵R    e = T.dot(e2)   # 极点平移过后形成（x&#39;,y&#39;,1）    e_x = e[0]    e_y = e[1]    if e_x &gt;= 0:        alpha = 1.0    else:        alpha = -1.0    # 旋转矩阵alpha 正负判断    R = np.identity(3)    R[0, 0] = alpha * e_x / np.sqrt(e_x**2 + e_y**2)    R[0, 1] = alpha * e_y / np.sqrt(e_x**2 + e_y**2)    R[1, 0] = -alpha * e_y / np.sqrt(e_x**2 + e_y**2)    R[1, 1] = alpha * e_x / np.sqrt(e_x**2 + e_y**2)    # 矩阵G    f = R.dot(e)[0]     # R变换之后，e==&gt;(f,0,1)    G = np.identity(3)    G[2, 0] = -1.0 / f    H2 = np.linalg.inv(T).dot(G.dot(R.dot(T)))     # H2 = T^-1 G R T    # ===============================    # 计算H1 , H1 = HaH2M    # 首先计算M    e_p = np.zeros((3, 3))    e_p[0, 1] = - e2[2]    e_p[0, 2] = e2[1]    e_p[1, 0] = e2[2]    e_p[1, 2] = - e2[0]    e_p[2, 0] = - e2[1]    e_p[2, 1] = e2[0]   # skew-symmetric 矩阵    v = np.array([1, 1, 1])    M = e_p.dot(F) + np.outer(e2, v)    # e2*VT = (3,3)    # 计算Ha    p1_hat = H2.dot(M.dot(points1.T)).T     # p1_hat = H2Mp  3 * N,转置之后 N * 3    p2_hat = H2.dot(points2.T).T            # pe_hat = H2p&#39; , 3 * N ,转置之后 N * 3    W = p1_hat / p1_hat[:, 2].reshape(-1, 1)    # 齐次坐标系    b = (p2_hat / p2_hat[:, 2].reshape(-1, 1))[:, 0]    # 最小二乘问题    a1, a2, a3 = np.linalg.lstsq(W, b, rcond=None)[0]    HA = np.identity(3)    HA[0] = np.array([a1, a2, a3])    H1 = HA.dot(H2).dot(M)      # H1 = HaH2M    return H1, H2</code></pre><h3 id="三、-主函数"><a href="#三、-主函数" class="headerlink" title="三、 主函数"></a>三、 主函数</h3><pre><code class="Python">if __name__ == &#39;__main__&#39;:    # Read in the data    im_set = &#39;data/set1&#39;    im1 = imread(im_set+&#39;/image1.jpg&#39;)    im2 = imread(im_set+&#39;/image2.jpg&#39;)    points1 = get_data_from_txt_file(im_set+&#39;/pt_2D_1.txt&#39;)    points2 = get_data_from_txt_file(im_set+&#39;/pt_2D_2.txt&#39;)    assert (points1.shape == points2.shape)    F = normalized_eight_point_alg(points1, points2)    e1 = compute_epipole(points1, points2, F)    e2 = compute_epipole(points2, points1, F.transpose())    print(&quot;e1&quot;, e1)    print(&quot;e2&quot;, e2)    # Find the homographies needed to rectify the pair of images    H1, H2 = compute_matching_homographies(e2, F, im2, points1, points2)    print(&quot;H1:\n&quot;, H1)    print    print(&quot;H2:\n&quot;, H2)    # Transforming the images by the homographies    new_points1 = H1.dot(points1.T)    new_points2 = H2.dot(points2.T)    new_points1 /= new_points1[2,:]    new_points2 /= new_points2[2,:]    new_points1 = new_points1.T    new_points2 = new_points2.T    rectified_im1, offset1 = compute_rectified_image(im1, H1)    rectified_im2, offset2 = compute_rectified_image(im2, H2)    new_points1 -= offset1 + (0,)    new_points2 -= offset2 + (0,)    # Plotting the image    F_new = normalized_eight_point_alg(new_points1, new_points2)    plot_epipolar_lines_on_images(new_points1, new_points2, rectified_im1, rectified_im2, F_new)    plt.show()</code></pre><h3 id="四、-结果"><a href="#四、-结果" class="headerlink" title="四、 结果"></a>四、 结果</h3><pre><code>e1 [-1.30071143e+03 -1.42448272e+02  1.00000000e+00]e2 [1.65412463e+03 4.53021078e+01 1.00000000e+00]H1: [[-1.20006316e+01 -4.15501447e+00 -1.23476881e+02] [ 1.41006481e+00 -1.48704147e+01 -2.84177469e+02] [-9.21889298e-03 -2.19184511e-03 -1.23033440e+01]]H2: [[ 8.09798131e-01 -1.22036874e-01  7.99331183e+01] [-3.00186699e-02  1.01581538e+00  3.63604348e+00] [-6.99360915e-04  1.05393946e-04  1.15205554e+00]]</code></pre><p>调整过后的图片为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d76d7018232d0b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/25/CS231A-Homework-2-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A-Homework-2.1</title>
      <link>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</link>
      <guid>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</guid>
      <pubDate>Sat, 23 Jun 2018 09:35:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A-Homework-2:ps-code2-part-1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、-从对应点估计基础矩阵&quot;&gt;&lt;a href=&quot;#一、-从对应点估计基础矩阵&quot; class=&quot;headerlink&quot; title
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A-Homework-2:ps-code2-part-1</p></blockquote><h1 id="一、-从对应点估计基础矩阵"><a href="#一、-从对应点估计基础矩阵" class="headerlink" title="一、 从对应点估计基础矩阵"></a>一、 从对应点估计基础矩阵</h1><ul><li><p>本题要求从对应点估计基础矩阵，使用二种方法：</p><ul><li>线性最小二乘法的八点算法</li><li>归一化八点算法</li></ul></li><li><p>笔记：</p><ul><li><a href="https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/">对极几何</a><h2 id="1-1-八点算法–-基础矩阵求解过程"><a href="#1-1-八点算法–-基础矩阵求解过程" class="headerlink" title="1.1 八点算法– 基础矩阵求解过程"></a>1.1 八点算法– 基础矩阵求解过程</h2></li></ul></li><li><p>给予两张图片，没有相机内外参数；</p></li><li><p>求出基本矩阵</p></li><li><p>方法： ‘<em>Eight-Point 算法</em> ‘</p></li></ul><hr><ol><li>至少8对 对应点</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-750407be55d3a189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>则每队对对应点满足：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-39605f51776577d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>即：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b2ab3e15ad77b5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>展开，可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-321f94cfacb01aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于所有对应点，使用一下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c3ec40ba81b3477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>简写为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5766d9a159915312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>W ： N*9 矩阵 ， N: 对应对的数量</li><li>f: 基本矩阵</li></ul><hr><ul><li>使用svd分解</li><li>w: 非满秩的</li><li>f: 真实的基本矩阵秩为2 </li><li>#<a href="https://blog.csdn.net/kokerf/article/details/72630863?locationNum=2&amp;fps=1" target="_blank" rel="noopener">基本矩阵的基本解法之8点算法</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-67d92e80c6b464f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这里进行了两次SVD分解；</li><li>首先获得F矩阵的近似；</li><li>第二次获得RANK为2的F;</li></ul><pre><code class="python"># points1, points2 都是np.arraydef lls_eight_point_alg(points1, points2):    len = points1.shape[0]    W = np.zeros((len, 9))   # 37 * 9 齐次矩阵    for i in range(len):        u1 = points1[i, 0]        v1 = points1[i, 1]        u2 = points2[i, 0]        v2 = points2[i, 1]        W[i] = np.r_[u1*u2, u2*v1, u2, v2*u1, v1*v2, v2, u1, v1, 1]    # SVD    U, S, VT = np.linalg.svd(W, full_matrices=True)    f = VT[-1, :]   # 最后一行为最优解    F_hat = np.reshape(f, (3, 3))    # 最小二乘的近似    # 计算rank =2 的F    U, S_hat, VT = np.linalg.svd(F_hat, full_matrices=True)    s = np.zeros((3, 3))   # sigma 矩阵    s[0, 0] = S_hat[0]    s[1, 1] = S_hat[1]  # sigma 的Rank为2    F = np.dot(U, np.dot(s, VT))    return F</code></pre><h2 id="2-归一化八点算法"><a href="#2-归一化八点算法" class="headerlink" title="2. 归一化八点算法"></a>2. 归一化八点算法</h2><p>标准的8点算法存在的问题：</p><ul><li>p点， 和通过基本矩阵将点p’映射到的极线上l= Fp’，两者的距离很大；点和极线之间的均值误差如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-091b3647c850b792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>8个对应点组成的矩阵W： 最好只有一个奇异值为0或者近似为0,其他的都为非零；这样能够使得svd效果好；</li><li>像素值的范围过大；如pi = (1832; 1023;)</li></ul><hr><p>解决方法：</p><ul><li>归一化像素点<ul><li><ol><li>新坐标系的原点应该位于图像点的质心处（平移）；<br>表示为：</li></ol></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6349e1ccc32f9d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>其次，变换后的图像点距原点的均方距离应为2像素（缩放）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a06c93ec30ac32aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图所示，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-446adabfc4846b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后用新坐标系下的图像应用8点算法计算出Fq；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97bf6c2a7e7c0064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后通过反归一化，获得真实的基本矩阵；</p><hr><p>整个算法分为三个步骤：</p><ul><li>归一化，对每个点进行缩放</li><li>八点算法计算Fq,</li><li>反归一化</li></ul><p>(1) 归一化： 先平移到新坐标系，在缩放<br><img src="http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%20%26s_%7Bx%7D%20%260%20%26s_%7Bx%7Dt_%7Bx%7D%5C%5C%20%260%20%26s_%7By%7D%20%26s_%7By%7Dt_%7By%7D%5C%5C%20%260%20%260%20%261%20%5Cend%7Bbmatrix%7D%20*%20%5Cbegin%7Bbmatrix%7D%20x%5C%5C%20y%5C%5C%201%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20s_%7Bx%7D%28x&plus;t_%7Bx%7D%29%5C%5C%20s_%7By%7D%28y&plus;t_%7By%7D%29%5C%5C%201%20%5Cend%7Bbmatrix%7D" alt=""></p><p>其中，缩放系数为：<br><img src="http://latex.codecogs.com/gif.latex?%5Csqrt%7B2/%28%5Csum_%7Bi%3D0%7D%5E%7Bn%7D%28x_%7Bi%7D%20-%20%5Coverline%7Bx%7D%29%5E%7B2%7D%20/%20N%29%20%7D" alt=""></p><p>代码为：</p><pre><code class="python">def normalized_eight_point_alg(points1, points2):    N = points1.shape[0]    points1_uv = points1[:, 0:2]    points2_uv = points2[:, 0:2]    # 取x,y 坐标    #    # 取坐标均值    points1_mean = np.mean(points1_uv, axis=0)    points2_mean = np.mean(points2_uv, axis=0)    # 点集的到中心的差    points1_new = points1_uv - points1_mean    points2_new = points2_uv - points2_mean    # 计算缩放参数    scale = np.sqrt(np.sum(points1_new**2)/N)    scale1 = np.sqrt(2 / (np.sum(points1_new**2)/N * 1.0))    scale2 = np.sqrt(2 / (np.sum(points2_new**2)/N * 1.0))    # 归一化矩阵    T1 = np.array([        [scale1, 0, -points1_mean[0] * scale1],        [0, scale1, -points1_mean[1] * scale2],        [0, 0, 1]    ])    T2 = np.array([        [scale2, 0, -points2_mean[0] * scale2],        [0, scale2, -points2_mean[1] * scale2],        # 在看到的别人答案中别人取_mean[0]，我觉得应该取[1],因为是y的差        [0, 0, 1]    ])    # 对坐标点变换    q1 = T1.dot(points1.T).T    # N * 3    q2 = T2.dot(points2.T).T    # N * 3    # 八点算法    Fq = lls_eight_point_alg(q1, q2)    #反归一化    F = T2.T.dot(Fq).dot(T1)    return F</code></pre><h2 id="3-计算平均距离"><a href="#3-计算平均距离" class="headerlink" title="3. 计算平均距离"></a>3. 计算平均距离</h2><ul><li>通过公式将p2的点映射成为p1面上的一条直线—极线</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-47c66c9adca14dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>可以通过点到直线的距离公式计算平均距离：</li></ul><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=930595087,3467127615&amp;fm=58" alt=""></p><p>代码为：</p><pre><code class="python">def compute_distance_to_epipolar_lines(points1, points2, F):    # F.Tp2 = l, 求得p2到p1面上的映射直线    line = F.T.dot(points2.T)  # 3 * N    dis_sum = 0    N = points1.shape[0]    for i in range(N):        x = points1[i, 0]        y = points1[i, 1]        A = line[0, i]        B = line[1, i]        C = line[2, i]        dis_sum += np.abs(A*x + B*y + C) / np.sqrt(A**2 + B**2)    return dis_sum / N      # 平均距离</code></pre><h2 id="4-画出极线"><a href="#4-画出极线" class="headerlink" title="4. 画出极线"></a>4. 画出极线</h2><pre><code class="python">    plt.subplot(1, 2, 1)  # 建立1*2 的图    line1 = F.T.dot(points2.T)   # p2到p1面上的极线     3 * N    N1 = line1.shape[1]     # 极线的数量    for i in range(N1):        A = line1[0, i]        B = line1[1, i]        C = line1[2, i]  # 极线的参数: Ax + By + C =0; ==&gt; y = (-A/B)x - (C/B)        W = im1.shape[1]    # 图片width，        y1 = -C/B       # (0,y1)        y2 = -(A * W + C) / B   # (W, y2)        plt.plot([0, W], [y1, y2], &#39;r&#39;)     # 画出每一条极线        plt.plot([points1[i, 0]], [points1[i, 1]], &quot;b*&quot;)    # 画出 每个极点的（x，y）坐标    plt.imshow(im1, cmap=&#39;gray&#39;)    # 第二幅图片    plt.subplot(1, 2, 2)    line2 = F.dot(points1.T)    N2 = line2.shape[1]    for i in range(N1):        A = line2[0, i]        B = line2[1, i]        C = line2[2, i]  # 极线的参数: Ax + By + C =0; ==&gt; y = (-A/B)x - (C/B)        W = im1.shape[1]    # 图片width，        y1 = -C/B       # (0,y1)        y2 = -(A * W + C) / B   # (W, y2)        plt.plot([0, W], [y1, y2], &#39;r&#39;)     # 画出每一条极线        plt.plot([points2[i, 0]], [points2[i, 1]], &quot;b*&quot;)    # 画出 每个极点的（x，y）坐标    plt.imshow(im2, cmap=&#39;gray&#39;)</code></pre><p>结果为：</p><pre><code>Set: data/set1--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[ 1.55218081e-06 -8.18161523e-06 -1.50440111e-03] [-5.86997052e-06 -3.02892219e-07 -1.13607605e-02] [-3.52312036e-03  1.41453881e-02  9.99828068e-01]]Distance to lines in image 1 for LLS: 28.025662937533877Distance to lines in image 2 for LLS: 25.162875800036915p&#39;^T F p = 0.03156399064220228Fundamental Matrix from normalized 8-point algorithm: [[ 5.93261511e-07 -5.08492255e-06  8.76427688e-05] [-4.66834735e-06 -3.20108624e-07 -6.12207138e-03] [-7.74714403e-04  8.42028676e-03  1.25311400e-01]]Distance to lines in image 1 for normalized: 0.9431072572196602Distance to lines in image 2 for normalized: 0.8719800541568359--------------------------------------------------------------------------------Set: data/set2--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[-5.63087200e-06  2.74976583e-05 -6.42650411e-03] [-2.77622828e-05 -6.74748522e-06  1.52182033e-02] [ 1.07623595e-02 -1.22519240e-02 -9.99730547e-01]]Distance to lines in image 1 for LLS: 9.701438829435915Distance to lines in image 2 for LLS: 14.568227190498229p&#39;^T F p = 0.03149037056281445Fundamental Matrix from normalized 8-point algorithm: [[-1.53880961e-07  2.46528633e-06 -1.57563630e-04] [ 3.50323566e-06  3.08159735e-07  6.82243058e-03] [ 2.42265054e-04 -8.27925885e-03 -4.08002117e-03]]Distance to lines in image 1 for normalized: 0.8955997529976532Distance to lines in image 2 for normalized: 0.8959928005846117</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ce26c6c5b0b7826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6_Epipolar_Geomotry_2</title>
      <link>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/</link>
      <guid>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/</guid>
      <pubDate>Fri, 22 Jun 2018 02:38:18 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节许多问题没有看懂，o(╥﹏╥)o&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquo
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><blockquote><p>本章节许多问题没有看懂，o(╥﹏╥)o</p></blockquote><hr><blockquote><p>主题： 图片校正 Image Rectification</p></blockquote><p>#1 问题</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8cc0457621c6e56b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>两个图片平行的问题<ul><li>无旋转 R = I</li><li>平移： 假设在x 轴上平移</li></ul></li></ul><p>那么 本质矩阵为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-208521e7cc7aff33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算极线的方向：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a2d105ea0a781cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="="></p><p>可知，两张图片的极线是水平的；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9b6f663493447819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得知，两点是共享同一个坐标轴 v的；</p><h1 id="2-Rectification-making-two-images-“parallel”"><a href="#2-Rectification-making-two-images-“parallel”" class="headerlink" title="2  Rectification:    making    two    images    “parallel”"></a>2  Rectification:    making    two    images    “parallel”</h1><ul><li>平行图片的优点</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b726092d63e282c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-1-三角化"><a href="#2-1-三角化" class="headerlink" title="2.1 三角化"></a>2.1 三角化</h2><ul><li>point triangulation</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-38908e5c54eec044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>距离计算<br><img src="https://upload-images.jianshu.io/upload_images/5361608-71094389014fe2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-862088c7ad288ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-对应性问题"><a href="#2-2-对应性问题" class="headerlink" title="2.2 对应性问题"></a>2.2 对应性问题</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97cac06011167479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c61637121427c095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-2-1-对应性方法"><a href="#2-2-1-对应性方法" class="headerlink" title="2.2.1 对应性方法"></a>2.2.1 对应性方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-caa07270e4d57480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>两个图片共享v轴，只在u轴上变化；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a26a241aae147875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这种方法造成强度的改变；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5ef88878c2c0ff5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>窗口大小不同的结果为；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-24873393b76fdbc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>存在四个不同的问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-11b0d26911a7843d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-364455beb480ae7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6359e1f4480583c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-063b28dd23947fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9d707c9d5df7a41f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9baeaa8d9a32d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="3-校正两张图片"><a href="#3-校正两张图片" class="headerlink" title="3 校正两张图片"></a>3 校正两张图片</h2><p> 校正两个图片不需要就知道相机的内参K和外参矩阵R,T，只需要通过基础矩阵计算极线；<br>然后计算所以极线的交点—极点；由于噪点的干扰，不可能交于一点，因此计算极点，利用最小二乘方法求得极线拟合一点；<br>并且在极线上的每一点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-70ef22c82e308bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果定义极线集合：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ad1cd071a0b7c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-80295e9834fc1d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因此整个步骤为：</p><ul><li><ol><li>通过归一化8点算法获取基本矩阵</li></ol></li><li><ol start="2"><li>极线交于极点： 通过最小二乘误差拟合</li></ol></li><li><ol start="3"><li>svd计算 极点</li></ol></li></ul><hr><blockquote><p>在求得极点e,e’后，如果极点在水平方向上不是无限的，说明图片没有平行，如果点是无限的，说明图片平行了；</p></blockquote><p>因此，我们的目的：</p><ul><li><strong>寻找一对单应性矩阵H1,H2,使得极点无穷，即两张图片平行；</strong></li></ul><hr><p>(1). <strong>寻找H2：令e’在水平方向上无限,即为点（f,0,0）</strong></p><ul><li>将第二幅图的中心移动到(0,0,1)在齐次坐标系下；<br>这个平移矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f15f7e8f6c1d82a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>应用一个旋转矩阵：使极点坐标旋转到水平坐标轴上，变为(f, 0, 1)</strong></p><ul><li>如果e‘在平移后Te’的坐标为：(e1’,e2’,1)，旋转矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2b8848d72443787d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-33ebdcfefbcfc87e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(3). <strong>将极点坐标由(f,0,1)==&gt;(f,0,0)</strong></p><ul><li>只需要变换矩阵：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4cf916086e001850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>经过上面几个步骤。我们可以得到无限极点：这个单应性变换H2为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eceae870c337bd04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><ul><li><strong>为了寻找单应性矩阵H1,,需要最小化两个图片对应点的均方差之和来获得H1</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ebe437f9682f42c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求导后，可以得到：</p><p>!<img src="https://upload-images.jianshu.io/upload_images/5361608-dffe23f713cf43f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算式子中的未知参数：</p><p>(1). <strong>首先计算M</strong></p><ul><li><p>任意3*3的斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ca1aac7031b398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>因为任何向量的叉积矩阵 是一个斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58e56509b18c3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图，a向量的叉乘矩阵为斜对称矩阵；</p><p>因此，前面公式中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e933426be143035d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>合并后，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb430c0d0009a532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果M每一列缩放e，则F也需要变化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c2760d1d20996d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8d6728c7d829f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>计算Ha矩阵中的参数a</strong></p><ul><li>已经知道了H2, M，如果将图片1中的点p变换到图片2中，然后经过H2变换：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d3dd8c3950e7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b26168a6bf4b3003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这两个点应该是最近点，然后使用最小二乘发来最小化误差：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c45f913af4b55069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设两个点齐次坐标为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c7c39a32c60e82ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最小化式子为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03f84d774d3fede2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为最后一项两个点在水平线上，则为常数</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2548833df47c882f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终，这个问题变成了解决最小二乘问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd8f6953623efa08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4b3993661018b687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求得a的参数后，得到了HA,H2,M三个矩阵，根据上面的式子：<br>最终可以求得H1；</p>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3_Single_View_Metrology</title>
      <link>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/</link>
      <guid>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/</guid>
      <pubDate>Fri, 22 Jun 2018 02:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-2d中的变换&quot;&gt;&lt;a href=&quot;#1-2d中的变换&quot; class=&quot;headerlink&quot; title=&quot;1  2
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><h1 id="1-2d中的变换"><a href="#1-2d中的变换" class="headerlink" title="1  2d中的变换"></a>1  2d中的变换</h1><h2 id="1-1-几何变换"><a href="#1-1-几何变换" class="headerlink" title="1.1 几何变换"></a>1.1 几何变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4293a9fb6318994b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-相似变换"><a href="#1-2-相似变换" class="headerlink" title="1.2 相似变换"></a>1.2 相似变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0b1c1de2d8270f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-仿射变换"><a href="#1-3-仿射变换" class="headerlink" title="1.3 仿射变换"></a>1.3 仿射变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1e1629e3eaf9aec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-4-投影变换"><a href="#1-4-投影变换" class="headerlink" title="1.4 投影变换"></a>1.4 投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1a1297c41268f109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>投影变换4个共线点的交叉率：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2d65709b5e37222b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="2-vanishing-points-and-lines-灭点"><a href="#2-vanishing-points-and-lines-灭点" class="headerlink" title="2 vanishing points and lines (灭点)"></a>2 vanishing points and lines (灭点)</h1><h2 id="2-1-无穷点"><a href="#2-1-无穷点" class="headerlink" title="2.1 无穷点"></a>2.1 无穷点</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ed0a8848567585d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于两条直线的交点：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-033b9e87e41a0f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但是，如果两条平行直线的交点，在齐次坐标系进行计算：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5d1a8ee50373adf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在欧氏坐标系下， 这个点是无穷的；</li><li>两条线段的交点也是无穷的；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ffddc1e05ba0b6f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-无穷线"><a href="#2-2-无穷线" class="headerlink" title="2.2 无穷线"></a>2.2 无穷线</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0fa9ecc24c3b48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-3-无穷点的投影变换"><a href="#2-3-无穷点的投影变换" class="headerlink" title="2.3 无穷点的投影变换"></a>2.3 无穷点的投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-42a7f1de720f48a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-4-无穷线的投影变换"><a href="#2-4-无穷线的投影变换" class="headerlink" title="2.4 无穷线的投影变换"></a>2.4 无穷线的投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b58b22ded0124c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-3d中的点和面"><a href="#3-3d中的点和面" class="headerlink" title="3 3d中的点和面"></a>3 3d中的点和面</h1><ul><li><p>点<br><img src="https://upload-images.jianshu.io/upload_images/5361608-df33547dc5b37f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>线段<br><img src="https://upload-images.jianshu.io/upload_images/5361608-1a498638def1cfff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h2 id="3-1-3d中的无穷点"><a href="#3-1-3d中的无穷点" class="headerlink" title="3.1 3d中的无穷点"></a>3.1 3d中的无穷点</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-81e985560c732f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-2-vanishing-points"><a href="#3-2-vanishing-points" class="headerlink" title="3.2 vanishing points"></a>3.2 vanishing points</h2><p>无穷点的投影变换不在是无穷的；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-01071f0955aeb371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给定一个相机参数K,R,T,得到灭点：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义一个平行线的超集为一个平面，每对平行线的交点都是无穷点，这些无穷点组成的线段就是无穷线，这个平面的无穷线经过投影变换<code>H</code>后不再是无穷的，被称为<code>vanishing line 或者 horizon line</code>，可以通过以下计算：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0346133f45da09b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例如：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-19aabed436274ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>橙色的是水平线，两个铁轨的交点在水平线，那么这两条铁轨就是水平线；</li></ul><h2 id="3-3-面"><a href="#3-3-面" class="headerlink" title="3.3 面"></a>3.3 面</h2><p>通过3d的平面法线n和对应的水平线，可以得到以下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f823386978ec4821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/5361608-f85ca24a96846ad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>如果相机的参数已知晓，那么可以得到水平线相关的平面的方向；</li></ul><h2 id="3-4-无穷面"><a href="#3-4-无穷面" class="headerlink" title="3.4 无穷面"></a>3.4 无穷面</h2><ul><li>定义：2个或多个无穷线组成的平面</li><li>在齐次坐标系下用<code>[0 0 0 1]T</code>表示</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a38031e839a04718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设两对平行线的灭点为v1,v2, 平行线的方向分别为d1,d2，那么这两个方向的夹角为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-3f0fee0cbccdce69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-344f019d6232aca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0888390d19d82e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以同时扩展到平面：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-e388a2ec9b5c1e0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-5-投影变换-总结"><a href="#3-5-投影变换-总结" class="headerlink" title="3.5  投影变换 总结"></a>3.5  投影变换 总结</h2><ul><li>使用投影变换，可以将无穷点投影为灭点；</li><li>无穷线投影为水平线；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-4d2c94fdc767a451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2af4fad907d2ad90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e5c3d841693d5796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
