<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Wed, 18 Jul 2018 08:16:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>STL_并发_高级接口</title>
      <link>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/</link>
      <guid>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/</guid>
      <pubDate>Wed, 18 Jul 2018 08:16:26 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发_线程间共享数据</title>
      <link>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <guid>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <pubDate>Wed, 18 Jul 2018 08:16:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c++ 标准库 (第二版)&lt;br&gt;c++并发编程(第三版)&lt;br&gt;cplusplus.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>c++ 标准库 (第二版)<br>c++并发编程(第三版)<br>cplusplus.com</p></blockquote><hr><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ul><li>数据共享–只读 ： 没有问题</li><li>数据共享– 修改： 破坏不变量</li></ul><h2 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h2><ul><li>修改线程之间共享数据的潜在问题： 破坏不变量</li><li>有问题的竞争条件：导致不变量被破坏</li></ul><h2 id="1-2-避免"><a href="#1-2-避免" class="headerlink" title="1.2 避免"></a>1.2 避免</h2><ul><li><ol><li>保护机制封装数据结构</li></ol></li><li><ol start="2"><li>修改数据结构的设计和不变量（无锁编程）</li></ol></li><li><ol start="3"><li>软件事务内存</li></ol></li></ul><h1 id="二、-互斥元-概述"><a href="#二、-互斥元-概述" class="headerlink" title="二、 互斥元 概述"></a>二、 互斥元 概述</h1><ul><li>c++ 提供的保护共享数据的最基本机制：互斥元</li><li><code>&lt;mutex&gt;</code>头文件</li></ul><p>c++ 提供的锁：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2c4eb30b79c8cd89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Mutex type: 锁的类型</li><li>locks: 管理锁的对象</li><li>Functions : <ul><li>同时锁定多个锁 <code>try_lock</code>,<code>lock</code>, 和执行一次<code>call_one</code></li></ul></li></ul><h2 id="2-1-mutex-和lock"><a href="#2-1-mutex-和lock" class="headerlink" title="2.1 mutex 和lock"></a>2.1 mutex 和lock</h2><ul><li><code>std::mutex</code>：创建互斥元</li><li><code>lock()</code> :锁定</li><li><code>unlock()</code>：解锁</li><li><code>std::lock_guard类模板</code>实现互斥元</li></ul><pre><code>std::mutex mtx;           // mutex for critical sectionvoid print_block (int n, char c) {  // critical section (exclusive access to std::cout signaled by locking mtx):  mtx.lock();  for (int i=0; i&lt;n; ++i) { std::cout &lt;&lt; c; }  std::cout &lt;&lt; &#39;\n&#39;;  mtx.unlock();}</code></pre><ul><li>直接调用成员函数是不推荐的，所以使用上面的类模板来管理；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-17e2b2f1b2f113b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>将 lock限制在代码块中，保证lock被限制在最短周期内；</li></ul><h2 id="2-2-递归锁-Recursive-mutex"><a href="#2-2-递归锁-Recursive-mutex" class="headerlink" title="2.2 递归锁(Recursive_mutex)"></a>2.2 递归锁(Recursive_mutex)</h2><p>例如，一个对象的数据结构</p><pre><code>class dataAccess{private:    std::mutex dbMutex;    ...public:    void insertdata(...){        std::lock_guard&lt;std::mutex&gt; lg(dbMutex);        ...    }    void createdata(...){        std::lock_guard&lt;std::mutex&gt; lg(dbMutex);        ...    }    void createandInsertdata(...){        std::lock_guard&lt;std::mutex&gt; lg(dbMutex);        ...        createdata(...);   // ERROR ，错误，死锁，dbMutex已经被锁定了    }};</code></pre><ul><li><p>class中创建一个普通mutex,但是成员函数中调用其他成员函数的情况，就会导致死锁；</p></li><li><p>第二次lock抛出：<code>std::system_error</code></p></li><li><p>因此，使用<code>recursive_mutex</code>将没问题</p></li></ul><pre><code>class dataAccess{private:    std::recursive_mutex dbMutex;    ...    public:    void insertdata(...){        std::lock_guard&lt;std::recursive_mutex&gt; lg(dbMutex);        ...    }    void createdata(...){        std::lock_guard&lt;std::recursive_mutex&gt; lg(dbMutex);        ...    }        void createandInsertdata(...){        std::lock_guard&lt;std::recursive_mutex&gt; lg(dbMutex);        ...        createdata(...);   // 没问题    }};</code></pre><h2 id="2-3-尝试性的lock-和-带时间的lock"><a href="#2-3-尝试性的lock-和-带时间的lock" class="headerlink" title="2.3 尝试性的lock 和 带时间的lock"></a>2.3 尝试性的lock 和 带时间的lock</h2><h3 id="2-3-1-try-lock"><a href="#2-3-1-try-lock" class="headerlink" title="2.3.1 try_lock"></a>2.3.1 try_lock</h3><ul><li>有时候程序想要获得一个lock，如果不成功，但是不想永远阻塞；</li><li><code>try_lock()</code>：成功返回true,失败返回false</li></ul><pre><code>// try_lock// try_lock 可能假性失败，即没被使用但也返回false/*    std::adopt_lock : 告诉 std::lock_guard 该互斥元被锁定，    沿用互斥元上锁的所有权*/std::mutex m;while(m.try_lock() == false ){    dosomething();}std::lock_guard&lt;std::mutex&gt; lg(m, std::adopt_lock);</code></pre><h3 id="2-3-2-带时间的lock"><a href="#2-3-2-带时间的lock" class="headerlink" title="2.3.2 带时间的lock"></a>2.3.2 带时间的lock</h3><p>分为两种：</p><ul><li><code>timed_lock</code></li><li><code>recursive_timed_lock</code><br>对于带时间的lock,可以使用</li><li><code>try_lock_for()</code></li><li><code>try_lock_until()</code><br>来等待某个时间段；</li><li>但是这两个函数在处理系统时间调整的时候，有差异；</li></ul><pre><code>std::timed_lock m;if(m.try_lock_for(std::chrono::secondes(1))){    std::lock_guard&lt;std::timed_lock&gt; lg(m, std::adopt_lock);    ...}else{    couldnotgetthelock();  // 不能获取lock}</code></pre><h2 id="2-4-处理多个lock"><a href="#2-4-处理多个lock" class="headerlink" title="2.4 处理多个lock"></a>2.4 处理多个lock</h2><h3 id="2-4-1-使用std-lock"><a href="#2-4-1-使用std-lock" class="headerlink" title="2.4.1 使用std::lock"></a>2.4.1 使用std::lock</h3><pre><code>// 处理多个lock/*    std::adopt_lock : 告诉 std::lock_guard 该互斥元被锁定，    沿用互斥元上锁的所有权*/std::mutex m1;std::mutex m2;...{    std::lock(m1,m2);  // 同时锁定成功，或者失败    std::lock_guard&lt;std::mutex&gt; lockM1(m1,std::adopt_lock);    std::lock_guard&lt;std::mutex&gt; lockM2(m2,std::adopt_lock);    ...} // 自动释放所有锁</code></pre><ul><li>使用std::lock锁定所有mutex</li></ul><h3 id="2-4-2-使用try-lock"><a href="#2-4-2-使用try-lock" class="headerlink" title="2.4.2 使用try_lock"></a>2.4.2 使用try_lock</h3><ul><li>“尝试取得多个lock”且“如果部分lock可用也不造成阻塞”<br>-std::try_lock()会在取得所有的lock情况下返回-1;否则返回失败的lock的索引（从0开始），并且成功的lock被unlock;</li></ul><pre><code>//try_lockstd::mutex m1;std::mutex m2;...int idx = std::try_lock(m1,m2); if(idx &lt; 0){  // 所有锁成功    std::lock_guard&lt;std::mutex&gt; lockM1(m1, std::adopt_lock);    std::lock_guard&lt;std::mutex&gt; lockM2(m2, std::adopt_lock);    ...} // 自动释放所有锁else{    // idx是失败的lock的索引}</code></pre><h2 id="2-5-注意"><a href="#2-5-注意" class="headerlink" title="2.5 注意"></a>2.5 注意</h2><ul><li>在所有例子中，使用<code>lock_guard</code>在出了程序段后自动释放；</li></ul><p>但是如果不使用上述函数类模板,mutex为被释放；</p><pre><code>// mutex仍会锁定std::mutex m1;std::mutex m2;...{    std::lock(m1,m2);    // no lock adopted}... // mutex 仍在</code></pre><h2 id="2-6-unique-lock"><a href="#2-6-unique-lock" class="headerlink" title="2.6 unique_lock"></a>2.6 unique_lock</h2><ul><li>unique_lock 和 lock_guard 提供的接口相同</li><li>并且能够通过<code>owns_lock()</code>和<code>bool()</code>来查询是否被锁住</li><li>优点：<ul><li>如果析构时候mutex仍被锁住，析构函数自动调用unlock();</li></ul></li></ul><pre><code>// 构造函数// 1. 传递try_to_lock,表示企图锁定mutex但不希望阻塞std::unique_lock&lt;std::mutex&gt; lock(mutex, std::try_to_lock);// 2. 传递一个时间段，表示尝试一段时间内锁定std::unique_lock&lt;std::mutex&gt; lock(mutex, std::chrono::secondes(1));if(lock){ // 判断是否锁住    ...}// 3. 传递defer_lock, 表示初始化这一lock对象，但尚未打算锁住mutex;std::unique_lock&lt;std::mutex&gt; lock(mutex, std::defer_lock);</code></pre><p>延迟锁：</p><pre><code>// 稍后锁住std::mutex m1;std::mutex m2;std::unique_lock&lt;std::mutex&gt; lockM1(m1, std::defer_lock);std::unique_lock&lt;std::mutex&gt; lockM2(m2, std::defer_lock);...std::loc(m1,m2);  // 延迟锁住</code></pre><h2 id="2-7-只调用一次"><a href="#2-7-只调用一次" class="headerlink" title="2.7 只调用一次"></a>2.7 只调用一次</h2><p>有时候 某些技能被某个线程使用后，其他线程再也不需要它；</p><ul><li>典型例子： lazy initialization (延迟初始化)</li></ul><pre><code>// 延迟初始化// 单线程bool initialized  = false;...if(!initialized){    init();  // 某初始化操作    initialized = true;}</code></pre><p>但是在多线程中，会出现问题；<br>c++解决方案：</p><pre><code>std::once_flag oc; // 全局标志...std::call_once(oc, init); // 如果没有初始化 就执行</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发_线程管理简介</title>
      <link>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B/</link>
      <guid>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B/</guid>
      <pubDate>Wed, 18 Jul 2018 08:15:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c++ 标准库 (第二版)&lt;br&gt;c++并发编程(第三版)&lt;br&gt;cplusplus.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>c++ 标准库 (第二版)<br>c++并发编程(第三版)<br>cplusplus.com</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li><p><code>std::thread</code>用来启动和表现线程；</p></li><li><p>thread对象和线程之间的关联式将一个callable objects（例如，函数，函数对象）</p></li></ul><p>关联的状态：<br>使用<code>joinable()</code>判断：</p><ul><li>true ： 已经连接到一个线程</li><li>false ： 未关联线程</li></ul><p>在判断关联状态后，只可调用一次一下方法：</p><ul><li>join():等待已连接的线程返回结果</li><li>detach(): 失去对线程的关联</li></ul><h1 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2 操作函数"></a>2 操作函数</h1><h2 id="2-1-成员类型和成员函数"><a href="#2-1-成员类型和成员函数" class="headerlink" title="2.1 成员类型和成员函数"></a>2.1 成员类型和成员函数</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-90df511b3502839a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>部分函数的解释：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b341ea469784d628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>另一个静态函数</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cd911df5f841d07f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h2><p>声明了两个函数，第二个函数传递引用；</p><pre><code>void increase_global (int n) ;void increase_reference (std::atomic&lt;int&gt;&amp; variable, int n) ;</code></pre><p>(1)  默认构造函数</p><pre><code> std::vector&lt;std::thread&gt; threads;</code></pre><p>（2) 传递给线程一个带参数的函数</p><ul><li>参数作为thread的实参<pre><code>std::thread(increase_global,1000);</code></pre>(3) 传递给线程一个参数为引用的函数</li><li>使用标准库函数<code>std::ref()</code>传递引用</li></ul><pre><code>std::atomic&lt;int&gt; foo(0);std::thread(increase_reference,std::ref(foo),1000);</code></pre><p>上述例子中实现了thread的三种构造函数;</p><h2 id="2-3-joinable-join-detach"><a href="#2-3-joinable-join-detach" class="headerlink" title="2.3 joinable(),join(),detach()"></a>2.3 joinable(),join(),detach()</h2><p>(1) <code>joinable()</code></p><pre><code>bool joinable() const noexcept;</code></pre><ul><li>判断线程是否已经连接</li><li>线程不可连接的情况：<ul><li>默认构造的线程</li><li>move过的线程</li><li><code>join</code>或者<code>detach</code>后的线程；</li></ul></li></ul><p>(2) <code>join()</code></p><pre><code>void join();</code></pre><ul><li>函数在线程执行完成后返回；</li></ul><pre><code>// example for thread::join#include &lt;iostream&gt;       // std::cout#include &lt;thread&gt;         // std::thread, std::this_thread::sleep_for#include &lt;chrono&gt;         // std::chrono::secondsvoid pause_thread(int n) {  std::this_thread::sleep_for (std::chrono::seconds(n));  std::cout &lt;&lt; &quot;pause of &quot; &lt;&lt; n &lt;&lt; &quot; seconds ended\n&quot;;}int main() {  std::cout &lt;&lt; &quot;Spawning 1 threads...\n&quot;;  std::thread t1 (pause_thread,1);  std::cout &lt;&lt; &quot;Done spawning threads. Now waiting for them to join:\n&quot;;  t1.join();  std::cout &lt;&lt; &quot;All threads joined!\n&quot;;  return 0;}</code></pre><p>结果为：</p><pre><code>Spawning 1 threads...Done spawning threads. Now waiting for them to join:pause of 1 seconds endedAll threads joined!</code></pre><p><code>join</code>让主线程必须等待其他线程返回后才能继续执行；</p><ul><li>返回后的线程的<code>joinable</code>返回false,不可被连接，能够安全释放；</li></ul><p>(3) <code>detach()</code></p><pre><code>void detach();</code></pre><ul><li>分离线程</li><li>在分离过后，线程在后台运行，thread对象不能引用，<code>joinable</code>变成不可被连接，能不安全释放；</li></ul><h2 id="2-4-转移线程的所有权"><a href="#2-4-转移线程的所有权" class="headerlink" title="2.4 转移线程的所有权"></a>2.4 转移线程的所有权</h2><ul><li>线程是可移动的(movable)，但是不可复制的(copyable)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3a0087121f1a0dca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><ol><li>启动一个新线程关联到t1</li></ol></li><li><ol start="2"><li>通过std::move()显式移动所有权，t1不在拥有相关线程；</li></ol></li><li><ol start="3"><li>启动一个线程关联到临时的thread对象，然后将线程所有权移交给t1;</li></ol></li><li><ol start="4"><li>默认构造一个t3;</li></ol></li><li><ol start="5"><li>将t2的关联线程移交给t3;</li></ol></li><li><ol start="6"><li>将t3关联的线程所有权移交给t1,但是t1已经有线程，所以会调用<code>std::terminate()</code>来终止程序；</li></ol></li></ul><p>因此，不能只通过向管理一个线程的thread对象赋值一个新的值来“舍弃”一个线程；</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MTProxy：专为Telegram打造的代理工具</title>
      <link>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <guid>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Sun, 15 Jul 2018 09:23:50 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://lala.im/3598.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lala.im/3598.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>转载自：<a href="https://lala.im/3598.html" target="_blank" rel="noopener">https://lala.im/3598.html</a></p></blockquote><hr><blockquote><p>记录一下操作</p></blockquote><hr><p>接着我们按键盘组合键Ctrl+C退出运行。<br>现在来创建一个系统服务，可以在往后更方便的管理和运行MTProxy。</p><p>新建服务文件：</p><pre><code>vi /etc/systemd/system/MTProxy.service</code></pre><p>写入：</p><pre><code>[Unit]Description=MTProxyAfter=network.target[Service]Type=simpleWorkingDirectory=/root/MTProxyExecStart=/root/MTProxy/objs/bin/mtproto-proxy -u nobody -p 8888 -H 2333 -S 密匙 --aes-pwd /root/MTProxy/objs/bin/proxy-secret /root/MTProxy/objs/bin/proxy-multi.conf -M 1Restart=on-failure[Install]WantedBy=multi-user.target</code></pre><p>注：</p><p>1、确保WorkingDirectory以及ExecStart内正确写明mtproto-proxy可执行文件的绝对路径。<br>以及指定proxy-secret、proxy-multi.conf的路径也是绝对路径。如果你是按照我的这篇文章来一字不动部署的，那么可以直接看第2点注意说明。</p><p>2、“密匙”改为之前你生成的密匙。</p><p>重加载，让新的服务文件生效：</p><pre><code>systemctl daemon-reload</code></pre><p>现在就可以启动MTProxy了：</p><pre><code>systemctl start MTProxy.service</code></pre><p>查看运行状态：</p><pre><code>systemctl status MTProxy.service</code></pre><p>如图所示是Active就说明MTProxy运行正常：</p><p><img src="https://lala.im/wp-content/uploads/2018/06/lala.im_2018-06-11-00-795.png" alt=""></p><p>把MTProxy设为开机启动：</p><pre><code>systemctl enable MTProxy.service</code></pre><p>停止MTProxy的运行：</p><pre><code>systemctl stop MTProxy.service</code></pre><p>OK，到这里，MTProxy的服务端就部署完成了，</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/15/MTProxy%EF%BC%9A%E4%B8%93%E4%B8%BATelegram%E6%89%93%E9%80%A0%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS131_Homework_2</title>
      <link>https://jingxa.github.io/2018/07/14/CS131-Homework-2/</link>
      <guid>https://jingxa.github.io/2018/07/14/CS131-Homework-2/</guid>
      <pubDate>Sat, 14 Jul 2018 11:07:30 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs131 hw2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;part-1-canny-Edge-Detector&quot;&gt;&lt;a href=&quot;#part-1-canny-Edge-Detector&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs131 hw2</p></blockquote><hr><h1 id="part-1-canny-Edge-Detector"><a href="#part-1-canny-Edge-Detector" class="headerlink" title="part 1 canny Edge Detector"></a>part 1 canny Edge Detector</h1><ul><li>canny 算子可以分为以下五步：<ul><li>Smoothing</li><li>Finding gradients</li><li>Non-maximum supperession</li><li>Double thredsholding</li><li>Edge tracking by hysterisis</li></ul></li></ul><h2 id="1-1-Smoothing"><a href="#1-1-Smoothing" class="headerlink" title="1.1 Smoothing"></a>1.1 Smoothing</h2><p>平滑一张图片，可以使用（Gaussian kernel）高斯核来卷积；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d9ecc61140d81a3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def conv(image, kernel):    Hi, Wi = image.shape    Hk, Wk = kernel.shape    out = np.zeros((Hi, Wi)).    pad_width0 = Hk // 2    pad_width1 = Wk // 2    pad_width = ((pad_width0,pad_width0),(pad_width1,pad_width1))    padded = np.pad(image, pad_width, mode=&#39;edge&#39;)    # 卷积过程    kernel = np.flip(np.flip(kernel, 0), 1)  # 上下翻转，在左右翻转    for i in range(Hi):        for j in range(Wi):            out[i, j] = np.sum(padded[i:(i + Hk), j:(j + Wk)] * kernel)    return outdef gaussian_kernel(size, sigma):    kernel = np.zeros((size, size))    # size = 2k+1    k = size // 2    for i in range(size):        for j in range(size):            kernel[i, j] = np.exp(-(((i-k)**2 + (j-k)**2))/2*sigma**2) / (2 * np.pi * (sigma**2))    return kernel</code></pre><p>输出为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8446400e3eb433ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>[问题] What is the effect of the kernel_size and sigma?</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c58b1092a531d5d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9aa6973c4104d788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>高斯核的sigma和size越大，就越模糊；</li></ul><hr><h2 id="1-2-Finding-gradients"><a href="#1-2-Finding-gradients" class="headerlink" title="1.2 Finding gradients"></a>1.2 Finding gradients</h2><h3 id="1-2-1-偏导数"><a href="#1-2-1-偏导数" class="headerlink" title="1.2.1 偏导数"></a>1.2.1 偏导数</h3><ul><li>图片的偏导数可以计算为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bcd31befb666ccfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>对于一张图片，我们需要给图片添加一层为0 的padding:</li></ul><pre><code>def partial_x(img):    out = None    # Hi, Wi = img.shape    # padd = np.zeros((Hi, Wi+2))    # padd[:, 1:Wi+1] = img    #    # out = np.zeros((Hi, Wi))    # for i in range(Wi):    #     out[:, i] = (padd[:, i+2] - padd[:, i]) / 2    # 使用卷积    kernel = np.array([[1, 0, -1]]) / 2    out = conv(img, kernel)    return outdef partial_y(img):    out = None    # Hi, Wi = img.shape    # padd = np.zeros((Hi + 2, Wi))    # padd[1:Hi+1, :] = img    #    # out = np.zeros((Hi, Wi))    # for i in range(Hi):    #     out[i, :] = (padd[i+2, :] - padd[i, :]) / 2    kernel = np.array([[1, 0, -1]]).T / 2    out = conv(img, kernel)    return out</code></pre><p>结果为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-364f1442bad2fc12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>[问题]：What is the reason for performing smoothing prior to computing the gradients?</li><li>在计算导数之前先进行smoothing,是为了降低噪声；</li></ul><h3 id="1-2-2-导数"><a href="#1-2-2-导数" class="headerlink" title="1.2.2 导数"></a>1.2.2 导数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-be899d6188d15932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Hint: Use np.arctan2 to compute</li><li>the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.)</li></ul><pre><code>def gradient(img):    G = np.zeros(img.shape)    theta = np.zeros(img.shape)    gx = partial_x(img)    gy = partial_y(img)    G = np.sqrt(gx**2 + gy**2)    theta = np.arctan2(gy, gx)  # (-pi/2, pi/2)    theta = (np.rad2deg(np.arctan2(gy, gx)) + 180) % 360    return G, theta</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-994c7f22bda0fd31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-3-Non-maximum-suppression"><a href="#1-3-Non-maximum-suppression" class="headerlink" title="1.3 Non - maximum suppression"></a>1.3 Non - maximum suppression</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f8507e47aeebd8e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在八个方向上[0,45,90,135,180,225,270,315]比较;</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ec4621ad6dad900f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def non_maximum_suppression(G, theta):    H, W = G.shape    out = np.zeros((H, W))    # Round the gradient direction to the nearest 45 degrees    theta = np.floor((theta + 22.5) / 45) * 45  # 方向定位    # 添加一层padding    padd = np.zeros((H+2,W +2))    padd[1:H+1, 1:W+1] = G    for m in range(1, H+1):        for n in range(1, W+1):            # 题目定义为顺时针方向，和逆时针相反,y方向相反            rad = np.deg2rad(theta[m-1, n-1])            i =int(np.around(np.sin(rad)))   # 行            j =int(np.around(np.cos(rad)))   # 列            p1 = padd[m+i, n+j]            p2 = padd[m-i, n-j]            if(padd[m, n] &gt; p1 and padd[m, n] &gt; p2): # 一个方向上                out[m-1, n-1] = padd[m, n]            else:                out[m-1, n-1] = 0    return out</code></pre><p>结果为：</p><pre><code>Thetas: 0[[0.  0.  0.6] [0.  0.  0.7] [0.  0.  0.6]]Thetas: 45[[0.  0.  0.6] [0.  0.  0.7] [0.4 0.5 0.6]]Thetas: 90[[0.4 0.  0. ] [0.  0.  0.7] [0.4 0.  0. ]]Thetas: 135[[0.4 0.5 0.6] [0.  0.  0.7] [0.  0.  0.6]]</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6f7d04485316dfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-4-Double-Thresholding"><a href="#1-4-Double-Thresholding" class="headerlink" title="1.4 Double Thresholding"></a>1.4 Double Thresholding</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-632e6d73905542c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-32612e1f72d9e762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>阈值假设：</li><li>定义两个阈值：low High</li><li>如果 小于low,不是一个边</li><li>如果大于High, 就是一条强边</li><li>如果在low和High之间，弱边</li></ul><p>使用 <code>np.where</code>:<a href="https://blog.csdn.net/sloanqin/article/details/51612618" target="_blank" rel="noopener">np.where</a></p><pre><code>def double_thresholding(img, high, low):    strong_edges = np.zeros(img.shape)    weak_edges = np.zeros(img.shape)    strong_edges = np.where(img&gt;=high,1,0)    weak_edges = np.where(img&gt;=low,1,0)    weak_edges = weak_edges-strong_edges    return strong_edges, weak_edges</code></pre><hr><h2 id="1-5-Edge-tracking"><a href="#1-5-Edge-tracking" class="headerlink" title="1.5 Edge tracking"></a>1.5 Edge tracking</h2><ul><li>strong edges : 确定的边</li><li>weak edges: 只有和strong edges相连的边才是正确的边， 其他的就是噪点；</li></ul><pre><code>def get_neighbors(y, x, H, W):    # 返回(y,x)周围等于(y,x)的邻居的坐标列表[(i,j),(i2,j2)..]    neighbors = []    for i in (y-1, y, y+1):        for j in (x-1, x, x+1):            if i &gt;= 0 and i &lt; H and j &gt;= 0 and j &lt; W:                if (i == y and j == x):                    continue                neighbors.append((i, j))    return neighborsdef link_edges(strong_edges, weak_edges):    # 寻找强边像素相连的弱边像素    H, W = strong_edges.shape    indices = np.stack(np.nonzero(strong_edges)).T    edges = np.zeros((H, W))    ### YOUR CODE HERE    edges = np.copy(strong_edges)    for i in range(1, H-1):        for j in range(1, W-1):            neighbors = get_neighbors(j, i, H, W)            if weak_edges[i, j] and np.any(edges[x, y] for x, y in neighbors):                edges[i, j] = True    ### END YOUR CODE    return edges</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-000d8d5790513651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-6-Canny-edge-detector"><a href="#1-6-Canny-edge-detector" class="headerlink" title="1.6 Canny edge detector"></a>1.6 Canny edge detector</h2><ul><li>实现canny算子</li></ul><pre><code>def canny(img, kernel_size=5, sigma=1.4, high=20, low=15):    ### YOUR CODE HERE    kernel = gaussian_kernel(kernel_size, sigma)  # 1. smoothing    smoothed = conv(img,kernel)    G, theta = gradient(smoothed)                 # 2. 梯度计算    nms = non_maximum_suppression(G,theta)        # 3. non-maximum_suppression    strong_edges, weak_edges = double_thresholding(nms, low,high) #double thresholding    edge = link_edges(strong_edges,weak_edges)    # link    ### END YOUR CODE    return edge</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c03f9c9fc21f90d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="Part-2-Lane-Detection"><a href="#Part-2-Lane-Detection" class="headerlink" title="Part 2 Lane Detection"></a>Part 2 Lane Detection</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7a261fb12aceb969.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>检测平面<br>算法：</li><li>使用canny算子检测边</li><li>提取兴趣区域的边</li><li>运行Hough transform  来检测平面</li></ul><h2 id="2-1-边检测"><a href="#2-1-边检测" class="headerlink" title="2.1 边检测"></a>2.1 边检测</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8f938b5f48dda00e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-Extracting-region-of-interest-ROI"><a href="#2-2-Extracting-region-of-interest-ROI" class="headerlink" title="2.2 Extracting region of interest (ROI)"></a>2.2 Extracting region of interest (ROI)</h2><ul><li>提取兴趣区域</li><li>使用一个二位掩码来定义兴趣区域；然后提取兴趣区域的边；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b234885744b5cd69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-3-Fitting-lines-using-Hough-transform"><a href="#2-3-Fitting-lines-using-Hough-transform" class="headerlink" title="2.3 Fitting lines using Hough transform"></a>2.3 Fitting lines using Hough transform</h2><ul><li>边检测的输出为连接点的集合；</li><li><p>使用hough变换来检测一条直线；</p></li><li><p>直线 y =ax + b 被表示为：(a,b),这种方式不能表示垂直线段；</p></li><li>因此，使用极方程表示：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-26385475a7a120de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1e7e069710553bb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>def hough_transform(img):    &quot;&quot;&quot; Transform points in the input image into Hough space.    Use the parameterization:        rho = x * cos(theta) + y * sin(theta)    to transform a point (x,y) to a sine-like function in Hough space.    Args:        img: binary image of shape (H, W)    Returns:        accumulator: numpy array of shape (m, n)        rhos: numpy array of shape (m, )        thetas: numpy array of shape (n, )    &quot;&quot;&quot;    # Set rho and theta ranges    W, H = img.shape    diag_len = int(np.ceil(np.sqrt(W * W + H * H)))  # 对角线长度，np.ceil 向大取整    rhos = np.linspace(-diag_len, diag_len, diag_len * 2.0 + 1) # 2倍，等差数列    thetas = np.deg2rad(np.range(-90.0, 90.0))    # Cache some reusable values    cos_t = np.cos(thetas)    sin_t = np.sin(thetas)    num_thetas = len(thetas)    # Initialize accumulator in the Hough space    accumulator = np.zeros((2 * diag_len + 1, num_thetas), dtype=np.uint64)    ys, xs = np.nonzero(img)    # Transform each point (x, y) in image    # Find rho corresponding to values in thetas    # and increment the accumulator in the corresponding coordiate.    ### YOUR CODE HERE    for i, j in zip(ys, xs):        for idx in range(thetas.shape[0]):            r = j * cos_t[idx] + i * sin_t[idx]            accumulator[int(r + diag_len), idx] += 1    ### END YOUR CODE    return accumulator, rhos, thetas</code></pre><p>结果为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-9dc4fdd0fc83ed97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3 参考资料"></a>3 参考资料</h1><ol><li><a href="https://github.com/mikucy/CS131/tree/master/hw2_release" target="_blank" rel="noopener">mikucy/CS131</a></li><li><a href="https://github.com/wwdguu/CS131_homework/tree/master/hw2_release" target="_blank" rel="noopener">wwdguu/CS131_homework</a></li></ol><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/14/CS131-Homework-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
