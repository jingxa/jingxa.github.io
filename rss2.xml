<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Thu, 05 Jul 2018 13:47:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>STL_非非标准_slist</title>
      <link>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:42 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;STL list是一个双向链表&lt;/li&gt;
&lt;li&gt;slist不在STL标准中，是一个单向链表；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;差别：&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>STL list是一个双向链表</li><li>slist不在STL标准中，是一个单向链表；</li></ul><p>差别：</p><ul><li>slist 的迭代器是单向的ForwardIterator</li><li>list的迭代器是 双向的BidrectionalIterator</li></ul><p>共同特点：</p><ul><li>插入，移除，接合不会造成原有迭代器失效</li></ul><h1 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c69d236d1d012e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>// 节点struct __slist_node_base{    __slist_node_base* next;};// 节点结构template&lt;class T&gt;struct __slist_node : public __slist_node_base{    T data;};// 全局函数// 已知道某一节点， 插入新节点于其后inline __slist_node_base* __slist_make_link(            __slist_node_base* prev_node,                __slist_node_base* new_node){    // 令new节点的下一个节点为prev节点的下一个节点    new_node-&gt;next = prev_node-&gt;next;    prev_node-&gt;next = new_node;  // prev指向new节点    return new_node;}// 全局函数 单向链表的大小inline size_t __slist_size(__slist_node_base* node){    size_t result = 0;    for(;node !=0; node = node-&gt;next)        ++result;    return result;}</code></pre><h1 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2d9e4831ec4892b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>/**    slist的迭代器*/struct __slist_iterator_base{    typedef size_t size_type;    typedef    ptrdiff_t difference_type;    typedef forward_iterator_tag  iterator_category;  // 单向链表的大小    __slist_node_base* node;  // 指向节点基本结构    __slist_node_base(__slist_node_base* x):node(x){}    void incr(){        node = node -&gt;next;  // 前进一个节点    }    bool operator== (const __slist_iterator_base&amp; x) const{        return node == x.node;    }    bool operator!= (const __slist_iterator_base&amp; x) const{        return node != x.node;    }};// 单向链表的迭代器结构template&lt;class T, class Ref , class Ptr&gt;struct _slist_iterator: public __slist_iterator_base{    typedef __slist_iterator&lt;T,T&amp;,T*&gt;                 iterator;    typedef __slist_iterator&lt;T,const T&amp;, const T*&gt;   const_iterator;    typedef __slist_iterator&lt;T,Ref,Ptr&gt;                self;    typedef T                                        value_type;    typedef Ptr                                        pointer;    typedef    Ref                                        reference;    typedef    __slist_node&lt;T&gt;                         list_node;    __slist_iterator(list_node&amp; x):__slist_iterator_base(x){}    // 调用slist&lt;T&gt;::end()会造成 __slist_iterator_base(0)    __slist_iterator():__slist_iterator_base(0){}    __slist_iterator(const iterator&amp; x):__slist_iterator_base(x.node){}    reference operator*()const{ return ((list_node*)node)-&gt;data;}    pointer  operator-&gt;() const{ return &amp;((operator*());}    self&amp; operator++(){        incr();        return *this;    }    self operator++(int){        self tmp = *this;        incr();        return tmp;    }    // 没有实现operator-- ,因为这是一个forward iterator};</code></pre><h1 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h1><pre><code>/**    slist 数据结构*/template&lt;class T, class Alloc = alloc&gt;class slist{public:    typedef T                            value_type;    typedef value_type*                    pointer;    typedef    const value_type*            const_pointer;    typedef    value_type&amp;                 reference;    typedef    const value_type&amp;            const_reference;    typedef size_t                        size_type;    typedef    ptrdiff_t                    difference_type;    typedef    __slist_iterator&lt;T,T&amp;,T*&gt;    iterator;    typedef    __slist_iterator&lt;T,const T&amp;, const T*&gt;    const_iterator;private:    typedef    __slist_node&lt;T&gt;        list_node;    typedef    __slist_node_base   list_node_base;    typedef    __slist_iterator_base    iterator_base;    typedef    simple_alloc&lt;list_node, Alloc&gt;  list_node_allocator;    static list_node* create_node(const value_type&amp; x){        list_node* node = list_node_allocator::allocate(); // 配置一个节点        __STL_TRY{            construct(&amp;node-&gt;data,x);            node-&gt;next = 0;        }        __STL_UNWIND(list_node_allocator::deallocate(node)):        return node;    }    static void destroy_node(list_node* node){        destroy(&amp;node-&gt;data);   // 析构元素        list_node_allocator::deallocate(node);  // 释放空间    }private:    list_node_base     head;   // 头部，不是指针，是对象public:    slist(){head.next =0;}    ~slist(){clear();}public:    // 基本操作    iterator begin(){return iterator((list_node*)head.next);}    iterator end() {return iterator(0);}    size_type size()const{return __slist_size(head.next);}    bool empty() const {return head.next == 0;}    // 两个slist互换    void swap(slist&amp; L){        list_node_base * tmp = head.next;        head.next = L.head.next;        L.head.next = tmp;    }public:    // 取头部元素    reference front(){return ((list_node*)head.next)-&gt;data;}    // 从头部插入元素    void push_front(const value_type&amp; x){        __slist_make_link(&amp;head, create_node(x));    }    // 从头部取走元素；    void pop_front(){        list_node* node = (list_node*) head.next;        head.next = node-&gt;next;        destroy_node(node);    }    ...};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_heap</title>
      <link>https://jingxa.github.io/2018/07/05/STL-heap/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-heap/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:16 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；</li></ul><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-binary-heap"><a href="#1-1-binary-heap" class="headerlink" title="1.1 binary heap"></a>1.1 binary heap</h2><ul><li>一种 complete binary tree (完全二叉树)的存储方式</li><li>使用vector作为存储空间</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-00622adba11ef4f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-heap的隐式表述法-implicit-representation"><a href="#1-2-heap的隐式表述法-implicit-representation" class="headerlink" title="1.2 heap的隐式表述法(implicit representation)"></a>1.2 heap的隐式表述法(implicit representation)</h2><ul><li>将数组的#0元素保留</li><li>那么在数组中，位于数组i处的节点的左子节点为2i，右子节点为(2*i +1)<br>-【SGI STL 并未使用这个方法】</li></ul><h2 id="1-3-max-heap"><a href="#1-3-max-heap" class="headerlink" title="1.3 max-heap"></a>1.3 max-heap</h2><ul><li>STL实现的是大根堆</li></ul><h1 id="2-heap算法"><a href="#2-heap算法" class="headerlink" title="2 heap算法"></a>2 heap算法</h1><h2 id="2-1-push-heap-算法"><a href="#2-1-push-heap-算法" class="headerlink" title="2.1 push_heap 算法"></a>2.1 push_heap 算法</h2><ul><li>新加入的元素位于最下一层作为叶节点，也就是插入到vector的end()处；</li><li>通过和父节点进行比较，如果值比父节点大，就父子对换位置，一直上溯，直到不需要对换或者到根节点为止；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58668b0e78d9e076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>push_heap</li></ul><pre><code>// push_heaptemplate&lt;class RandomAccessIterator&gt;inline void push_heap(RandomAccessIterator first, RandomAccessIterator last){    // 此函数调用的时候 新元素已经置于容器底部    __push_heap_aux(first,last,distance_type(first),value_type(first));}</code></pre><ul><li>使用<strong>push_heap_aux 和 </strong>push_heap作为内部函数；</li></ul><pre><code>template&lt;class RandomAccessIterator, class Distance, class T&gt;inline void __push_heap_aux(RandomAccessIterator first,                RandomAccessIterator last, Distance*, T*){    // 新值在容器最尾端，位置： （last -first）-1    // 隐式表述法 ,根节点编号从0开始    __push_heap(first, Distance(last - first)-1, Distance(0), T(*(last -1)));}// 一下这组push_back()不允许指定&#39;大小比较标准&#39;template&lt;class RandomAccessIterator, class Distance, class T&gt;void __push_heap(RandomAccessIterator first, Distance holeIndex,             Distance topIndex, T value){    Distance parent = (holeIndex -1) /2; // 找出父节点    while(holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value){  // 大根堆调整        // 尚未到达顶端并且父节点小于新值        *(first + holeIndex) = *(first + parent); // 令洞位置为父节点        holeIndex = parent; // 调整洞号， 向上提升        parent = (holeIndex - 1) /2;   // 新父节点        }   // 调整完成    *(first + holeIndex) = value;  // 赋值}</code></pre><h2 id="2-2-pop-heap算法"><a href="#2-2-pop-heap算法" class="headerlink" title="2.2 pop_heap算法"></a>2.2 pop_heap算法</h2><ul><li>先将根节点和最下一层的最右边的叶节点对换位置；然后调整除了最后一个节点的vector的first,last-1]的堆；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f729a93c0e6b8d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>pop_heap</li></ul><pre><code>/**    pop_heap    1. 取走根节点    2. 满足完全二叉树的条件，将最下一层的最右边的叶节点拿掉*/template&lt;class RandomAccessIterator&gt;inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last){    __pop_heap_aux(first, last, value_type(first));}</code></pre><ul><li>使用了__pop_heap_aux作为内部函数：</li></ul><pre><code>// 根据隐式表述法， pop操作的结果为底部容器的第一个元素// 首先将首值和尾节点互换，然后重新调整[first, last -1)template&lt;class RandomAccessIterator , class T&gt;inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last,                            T*){    __pop_heap(first,last-1, last-1, T(*(last - 1), distance_type(first));                            }template&lt;class RandomAccessIterator, class T, class Distance&gt;inline void __pop_heap(RandomAccessIterator first,                         RandomAccessIterator last,                        RandomAccessIterator result,                         T value, Distance*){    *result = * first;   // 设定尾值为首值                          //然后后面可以由容器pop_back()取出    // 重新调整heap    __adjust_heap(first,Distance(0), Distance(last -first), value);}</code></pre><ul><li>heap的调整算法：<code>__adjust_heap</code><br><code>`</code></li></ul><p>template<class randomaccessiterator,="" class="" distance,="" t=""><br>void __adjust_heap(RandomAccessIterator first, Distance holeIndex,<br>                    Distance len, T value){</class></p><pre><code>Distance topIndex = holeIndex; Distance secondChild = 2*holeIndex +2;  // 洞节点的右子节点while(secondChild &lt; len){    // 比较洞节点的两个子节点， 然后secondChild代替较大子节点    if(*(first + secondChild) &lt; *(first(secondChild -1))){        secondChild --;    }    *(first + holeIndex ) = *(first + secondChild);  // 替换父节点和子节点    holeIndex = secondChild;    secondChild = 2*(secondChild +1);  // 下一层}if(secondChild == len){  // 没有右子节点 ，只有左节点    // 令左子值为洞值，在令洞号移动左子节点处    *(first + holeIndex ) = *(first +(secondChild -1));    holeIndex = secondChild -1;}// 将要调整的洞号填入目前的洞号，// 此时已经满足次序性// 可直接为*（first + holeIndex) = value;__push_heap(first, holeIndex, topIndex,value);</code></pre><p>}</p><pre><code>## 2.3 sort_heap 算法- pop_heap每次将最大元素放到尾端，那么通过持续调用pop_heap算法就可以得到逆序序列；</code></pre><p>/**<br>    sort_heap</p><pre><code>1. pop_heap 每次取出一个最大值，持续pop，可得逆序序列；</code></pre><p>*/</p><p>template<class randomaccessiterator=""><br>void sort_heap(RandomAccessIterator first,<br>                RandomAccessIterator last){<br>    // 没执行一次pop_heap(),极值放在尾端<br>    while(last - first &gt;1){<br>        pop_heap(first,last–); // 执行一次，操作范围缩小一点<br>    }<br>}</class></p><pre><code>## 2.4 make_heap算法- 将一段现有数据转化一个heap</code></pre><p>/*<em><br>    make_heap: 将一段数据转化为堆</em>/<br>template<clss randomaccessiterator=""><br>inline void make_heap(RandomAccessIterator first, RandomAccessIterator last){<br>    __make_heap(first,last, value_type(first),distance_type(first));<br>}</clss></p><p>template<class randomaccessiterator,="" class="" t,="" distance=""><br>void __make_heap(RandomAccessIterator first,<br>                RandomAccessIterator    last, T<em>, Distance</em>)<br>{<br>    if(last - first &lt; 2) return ; // 长度0或1 不用重新排列<br>    Distance len = last - first;</class></p><pre><code>// 找出第一个需要重新排列的子树头部，以parent标出，Distance parent = (len -2 ) /2;while(true){    // 重新排列parent为首的子树，len为了让__adjust_heap()判断操作范围    __adjust_heap(first,parent,len,T(*(first+parent)));    if(parent == 0) return ; // 走完根节点就结束；    parent --; // 重排子树的头部向前一个节点；}</code></pre><p>}<br><code>`</code></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-heap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_适配器</title>
      <link>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <pubDate>Thu, 05 Jul 2018 13:43:51 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-适配器-（adapter）&quot;&gt;&lt;a href=&quot;#1-适配器-（adapter）&quot; class=&quot;headerlink&quot; title=&quot;1 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><h1 id="1-适配器-（adapter）"><a href="#1-适配器-（adapter）" class="headerlink" title="1 适配器 （adapter）"></a>1 适配器 （adapter）</h1><ul><li>“修改某物接口，形成另一个风貌者”的性质，称为adapter；</li></ul><p>STL的适配器：</p><ul><li>stack</li><li>queue</li></ul><h1 id="2-stack"><a href="#2-stack" class="headerlink" title="2 stack"></a>2 stack</h1><ul><li>以deque或者 list作为底层容器</li><li>先进后出</li><li>stack没有迭代器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f525a94e3884b2a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>emplate&lt;class T, Sequence = deque&lt;T&gt;&gt;class stack{    // __STL_NULL_TMPL_ARGS 展开为&lt;&gt;    friend bool operator== __STL_NULL_TMPL_ARGS(const stack&amp;, const stack&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(const stack&amp;, const stack&amp;);public:    typedef typename Sequence::value_type value_type;    typedef typename Sequence:size_type     size_type;    typedef typename Sequence::reference    reference;    typedef    typename Sequence::const_reference    const_reference;protected:    Sequence c;  // 底层容器public:    // 一下完全利用Sequence c 的操作，完成stack的操作    bool empty()const{return c.empty();}    size_type    size() const{return c.size();}    reference top(){returnc.back();}    const_reference top() const{return c.back();}    // stack末端进，末端出    void push(const value_type&amp; x){c.push_back(x);}    void pop(){c.pop_back();}};template&lt;class T, class Sequence&gt;bool operator==(const stack&lt;T,Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){    return x.c = y.c;}template&lt;class T ,class Sequence&gt;bool operator&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){    return x.c &lt; y.c;}</code></pre><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3 queue"></a>3 queue</h1><ul><li>以deque或者list作为底层容器</li><li>先进先出的结构</li><li>不允许有遍历行为，没有迭代器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c3723b2ba1434db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>/**    queue: 先进先出    1. 不允许遍历    2. deque作为底层容器*/template&lt;class T, class Sequence = deque&lt;T&gt; &gt;class queue{    // __STL_NULL_TMPL_ARGS展开为&lt;&gt;    friend bool operator== __STL_NULL_TMPL_ARGS(const queue&amp; x, const queue&amp; y);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(const queue&amp; x, const queue&amp; y);public:    typedef typename    Sequence::value_type    value_type;    typedef    typename    Sequence::size_type        size_type;    typedef    typename    Sequence::reference        reference;    typedef    typename    Sequence::const_reference    const_reference;protected:    Sequence c;  // 底层容器public:    bool empty() const{return c.empty();}    size_type size() const{return c.size();}    reference front(){return c.front();}    const_reference front() const{return c.front();}    reference back(){return c.back();}    const_reference back(){return c.back();}    // queue 末端进，前端出    void push(const value_type&amp; x){c.push_back(x);}    void pop(){c.pop_front();}};template&lt;class T, class Sequence&gt;bool operator==(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T,Sequence&gt;&amp; y){    return x.c == y.c;}template&lt;class T, class Sequence&gt;bool operator,(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T,Sequence&gt;&amp; y){    return x.c , y.c;}</code></pre><h1 id="4-priority-queue"><a href="#4-priority-queue" class="headerlink" title="4 priority_queue"></a>4 priority_queue</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h2><ul><li>带有权值观念的queue;</li><li>按照权值排列；</li><li>缺省情况下priority_queue利用max_heap完成；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a4a3bd8124fc1325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-2-定义"><a href="#4-2-定义" class="headerlink" title="4.2 定义"></a>4.2 定义</h2><ul><li>priority_queue内部以vector为底层容器；</li><li>使用泛型算法<code>push_heap</code>、<code>pop_heap</code>  、<code>mmake_heap</code>；</li></ul><pre><code>template&lt;class T, class Sequence = vector&lt;T&gt;,     class Compare = less&lt;typename Sequence::value_type&gt; &gt;class priority_queue{public:    typedef typename Sequence::value_type  value_type;    typedef typename Sequence::size_type     size_type;    typedef    typename Sequence::reference    reference;    typedef    typename Sequence::const_reference    const_reference;protected:    Sequence c; // 底层容器    Compare    comp;  // 元素比较器pubic:priority_queue(): c(){}explicit priority_queue(const Compar&amp; x):c(),comp(x){}    // 一下用到 make_heap()，push_heap(),pop_heap()都是泛型算法    // 注意，任一个构造函数都立刻于底层容器内产生一个隐式表述法的heap    template&lt;class InputIterator&gt;    priority_queue(InputIterator first, InputIterator last,    const Compar&amp; x):c(first,last), comp(x){        make_heap(c.begin(),c.end(),comp);    }    template&lt;class InputIterator&gt;    priority_queue(InputIterator first, InputIterator last)        :c(first,last){            make_heap(c.begin(),c.end(),comp);        }    bool empty() const{return c.empty();}    size_type size() const{return c.size();}    const_reference top() const{return c.front();}    void push(const value_type&amp; x){        __STL_TRY{            // push_heap 是泛型算法，先利用底层容器的push_back()将xnyrsu            // 推入末端，在重排heap            c.push_back(x);            push_heap(c.begin(),c.end(),comp);  // push_heap 是泛型算法        }        __STL_UNWIND(c.clear())；    }    void pop(){        __STL_TRY{            // pop_heap 是泛型算法， 从heap内取出一个元素，它并不是真正将            // 元素弹出，而是重排heap,然后再以底层容器pop_back()取得被弹出的元素            pop_heap(c.begin(),c.end(),comp);            c.pop_back();        }        __STL_UNWIND(c.clear());    }};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_容器_deque_2</title>
      <link>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-2/</link>
      <guid>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-2/</guid>
      <pubDate>Wed, 04 Jul 2018 08:54:21 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;3-4-deque的元素操作&quot;&gt;&lt;a href=&quot;#3-4-deque的元素操作&quot; class=&quot;headerlink&quot; title=&quot;3.4 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><h2 id="3-4-deque的元素操作"><a href="#3-4-deque的元素操作" class="headerlink" title="3.4 deque的元素操作"></a>3.4 deque的元素操作</h2><h3 id="3-4-1-deque的前和尾部删除"><a href="#3-4-1-deque的前和尾部删除" class="headerlink" title="3.4.1 deque的前和尾部删除"></a>3.4.1 deque的前和尾部删除</h3><ul><li>pop_back()</li><li>pop_front()</li></ul><pre><code>    // pop     void pop_back(){        if(finish.cur != finish.start){ // 最后缓冲区还有一个以上的元素            -- finish.cur;  // 调整指针；            destroy(finish.cur);// 最后元素析构        }else{             // 最后缓冲区没有元素            pop_back_aux(); //  释放缓冲区        }    }    void pop_front(){        if(start.cur != start.last -1){// 第一缓冲区还有多个元素            destroy(start.cur);            ++ start.cur;        }else{  // 第一缓冲区只有一个元素            pop_front_aux();  // 释放缓冲区        }    }</code></pre><p>这两个函数依然是借助了辅助函数：</p><pre><code>    // pop_back_aux    void pop_back_aux(){        deallocate_node(finish.first); // 释放最后一个缓冲区        finish.set_node(finish.node -1); // 调整finish的指向        finish.cur = finish.last -1;        destroy(finish.cur);   // 析构该元素    }    //pop_front_aux    void pop_front_aux(){        destroy(start.first);  // 第一缓冲区第一个元素析构        deallocate_node(start.first) ;  // 释放第一缓冲区        start.set_node(start.node + 1);        start.cur = start.first;  // 下一个缓冲区第一个元素    }</code></pre><ul><li>在删除元素的时候，也要考虑缓冲区的释放</li></ul><h3 id="3-4-2-clear"><a href="#3-4-2-clear" class="headerlink" title="3.4.2 clear()"></a>3.4.2 clear()</h3><pre><code>// 清除deque，保留一个缓冲区    void clear(){        // 针对头和尾部中间的缓冲区，都是饱满的        for(map_pointer node = start.node +1; node&lt;finish.node ; ++node){            // 析构所有元素            destroy(*node, *node+buffer_size());            // 释放缓冲区            data_allocator::deallocate(*node,buffer_size());        }        if(start.node !=finish.node){  // 还有头和尾部两个缓冲区            destroy(start.cur, start.last);   // 将头部缓冲区所有元素析构            destroy(finish.first, finish.cur); // 尾部缓冲区析构            // 释放掉尾部缓冲区，头部缓冲区保留            data_allocator::deallocate(finish.start, buffer_size());        }else{  // 只有一个缓冲区            destroy(start.cur, finish.cur); // 所有元素析构            finish = start; // 调整状态        }    }</code></pre><h3 id="3-4-3-erase"><a href="#3-4-3-erase" class="headerlink" title="3.4.3 erase"></a>3.4.3 erase</h3><pre><code>    // erase 操作    iterator erase(iterator pos){        iterator next = pos;        ++next;        difference_type index = pos - next;  // 清除点之前的元素个数        if(index &lt;(size() &gt;&gt;1 )){            copy_backward(start,pos, next); // 移动清除之前的元素            pop_front();  // 消除最前的一个元素        }else{            copy(next, finish, pos);  // 移动清除之后的元素            pop_back();        }        return start+ index;    }    // erase  [first, last)    void erase(iterator first, iterator last){        if(first == start &amp;&amp; last == finish){  // 如果是清除整个deque            clear();            return finish;        }else{            difference_type n = last - first;            difference_type elems_before = first - start;  // 清除区间前方的元素个数            if(elems_before &lt; (size() -n) /2){ // 前方元素比较少                copy_backward(start, first, last);                iterator new_start = start +n;   // 新起点                destroy(start, new_start);       // 移动完毕，冗余元素析构                for(map_pointer cur = start.node; cur&lt;new_start.node; ++cur){                    data_allocator::deallocate(*cur, buffer_size());                }                start = new_start; // 设定deque的新起点            }else{                copy(last,finish, first);  // 向前移动后方元素                iterator new_finish = finish - n;                 destroy(new_finish , finish);   // 移动完成冗余析构                for(map_pointer cur = new_finish.node +1;cur &lt;=finish.node; ++cur){                    data_allocator::deallocate(*cur, buffer_size());                }                finish = new_finish ; // deque 新尾部            }            return start + elems_before;        }    }</code></pre><h1 id="4-迭代器的操作"><a href="#4-迭代器的操作" class="headerlink" title="4 迭代器的操作"></a>4 迭代器的操作</h1><pre><code>/**    deque 的迭代器*/template&lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator{    typedef __deque_iterator&lt;T, T&amp;,T*, BufSiz&gt;                iterator;    typedef    __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator;    static    size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T));}    // 未继承std::iterator, 必须自行添加iterator_category    typedef random_access_iterator_tag              iterator_category;    typedef T                                        value_type;    typedef Ptr                                        pointer;    typedef    Ref                                        reference;    typedef    size_t                                    size_type;    typedef    ptrdiff_t                                difference_type;    typedef T**                                        map_pointer;    typedef    __deque_iterator                        self;    // 保持与容器的联结    T*    cur;  // 迭代器指向缓冲区的current 元素    T*  first;    // 指向缓冲区的头；    T*  last;     // 指向缓冲区的尾巴（含备用空间）    map_pointer node;   // 指向管理中心public:    void set_node(map_pointer new_node){        node = new_node;        first =*new_node;    // 缓冲区开头        last = first + difference_type(buffer_size());    }    // 运算符重载    reference operator*() const{return *cur;}    pointer operator-&gt;() const{return &amp;(operator*());}    difference_type operator-(const self&amp; x) const{        return difference_type(buffer_size()) * (node - x.node -1) +             (cur - first) + ( x.last - x.cur);    }    self&amp; operator++(){        ++cur;        if(cur == last){ // 到达尾部， 切换到下一节点            set_node(node+1);            cur = first;        }        return *this;    }    self operator++(int){        self tmp  = *this;        ++*this;        return tmp;    }    self operator--(){        if(cur == first){            set_node(node -1);            cur = last;        }        -- cur;        return *this;    }    self operator--(int){        self tmp = *this;        -- *this;        return tmp;    }    // 随机存取    self&amp; operator+= (difference_type n){        difference_type offset = n +(cur - first);        //  first&lt; cur -n &lt;= offset &lt;= cur +n &lt; last         // 目标位置在同一缓冲区        if(offset &gt;= &amp;&amp; offset &lt; difference_type(buffer_size())){             cur += n;        }else{        // 目标的位置不在同一缓冲区            difference_type node_offset =                 offset &gt; 0 ? offset / difference_type(buffer_size())                    : difference_type((-offset - 1) / buffer_size()) -1;            // 切换到正确的节点            set_node(node + node_offset);            // 切换到正确的元素            cur = first + (offset - node_offset * difference_type(buffer_size()))        }        return *this;    }    self operator+(difference_type n) const{        self  tmp = *this;        return tmp += n;    }    self&amp; operator -=(difference_type n){        return *this += -n;    }    self operator-(difference_type n ){        self tmp = *this;        return tmp -= n;    }    // 随机存取[]    reference operator[] (difference_type n) const {        return *(*this + n);    }    bool operator== (const self&amp; x)const{        return cur == x.cur;    }    bool operator!=(const self&amp; x)const{        return !(*this == x);    }    boll operator&lt;(const self&amp; x)const{        return (node == x.node) ? (cur &lt; x.cur) :(node &lt; x.node);    }};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_容器_deque_1</title>
      <link>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-1/</link>
      <guid>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-1/</guid>
      <pubDate>Wed, 04 Jul 2018 08:54:10 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;&lt;i
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-aae0b52efc3e2986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>deque 和vector的差异：</p><ul><li>deque 允许常数时间的插入或删除</li><li>deque 没有所谓的容量(capacity)概念</li></ul></li><li><p>deque是有分段的连续空间组合而成；</p></li><li><p>vector的空间不足再分配情况在deque上面是不会发生的；</p></li><li><p>deque的排序： 现将deque复制到vector，在vector排序后在复制到deque;</p></li></ul><h1 id="2-deque-的组成"><a href="#2-deque-的组成" class="headerlink" title="2 deque 的组成"></a>2 deque 的组成</h1><ul><li>deque有分段的连续空间组成；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-083527a9d98f0b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="2-1-deque的中控"><a href="#2-1-deque的中控" class="headerlink" title="2.1 deque的中控"></a>2.1 deque的中控</h1><ul><li>采用一块map作为主控，其中map是一块连续空间，每个元素(此处称为节点,node)都是指针，指向分段的连续空间，称为缓冲区</li><li>缓冲区才是存储空间主题，默认值0 表示使用512bytes缓冲区；</li></ul><pre><code>template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;class deque{    public:    typedef T                         value_type;    typedef value_type*             pointer;    typedef size_t                    size_type;protected:    // 元素的指针的指针    typedef pointer*                 map_pointer;public:    typedef __deque_iterator&lt;T, T&amp;,T*,BufSiz&gt; iterator;protected:    //  data  member    iterator     start;    // 表示第一个节点    iterator    finish;   // 表示最后一个节点    map_pointer map;    // 指向map, map是连续空间，每个元素是指针，指向一块缓冲区    size_type map_size;    // map空间大小...</code></pre><h2 id="2-2-deque-的迭代器"><a href="#2-2-deque-的迭代器" class="headerlink" title="2.2 deque 的迭代器"></a>2.2 deque 的迭代器</h2><ul><li>deque的迭代器提供了4个成员<blockquote><p>T<em>    cur;  // 迭代器指向缓冲区的current 元素<br>  T</em>  first;    // 当前指向的缓冲区的头；<br>  T*  last;     // 当前指向的缓冲区的尾巴（含备用空间）<br>  map_pointer node;   // 指向管理中心的node</p></blockquote></li></ul><pre><code>template&lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator{    typedef __deque_iterator&lt;T, T&amp;,T*, BufSiz&gt;                iterator;    typedef    __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator;    static    size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T));}    // 未继承std::iterator, 必须自行添加iterator_category    typedef random_access_iterator_tag              iterator_category;    typedef T                                        value_type;    typedef Ptr                                        pointer;    typedef    Ref                                        reference;    typedef    size_t                                    size_type;    typedef    ptrdiff_t                                difference_type;    typedef T**                                        map_pointer;    typedef    __deque_iterator                        self;    // 保持与容器的联结    T*    cur;  // 迭代器指向缓冲区的current 元素    T*  first;    // 指向缓冲区的头；    T*  last;     // 指向缓冲区的尾巴（含备用空间）    map_pointer node;   // 指向管理中心...</code></pre><p>其中 <code>buffer_size()</code> 中调用全局函数：</p><pre><code>/**     全局函数  __deque_buf_size    1. 如果n 不为0， 传回n， bcui buffer size 有用户自定义    2. 如果n 为0， 表示buffer size 使用默认值        - 如果sz（元素大小，sizeof(value_type)）小于512， 传回512/sz        - 如果sz 不小于 512 ， 传回1*/inline  size_t  __deque_buf_size(size_t n, size_t sz){    return n!=0 ? n : (sz &lt; 512 ? size_t(512/sz) : size_t(1));}</code></pre><h2 id="2-3-deque的数据结构"><a href="#2-3-deque的数据结构" class="headerlink" title="2.3 deque的数据结构"></a>2.3 deque的数据结构</h2><ul><li>deque维护了一个map</li><li>还有start,finish 两个迭代器，指向第一个缓冲区的第一个元素和最后一个缓冲区的最后一个元素的下一个位置；</li><li>如果map空间不足，就重新分配更大的map;</li></ul><pre><code>template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;class deque{    public:    typedef T                         value_type;    typedef value_type*             pointer;    typedef size_t                    size_type;protected:    // 元素的指针的指针    typedef pointer*                 map_pointer;public:    typedef __deque_iterator&lt;T, T&amp;,T*,BufSiz&gt; iterator;protected:    //  data  member    iterator     start;    // 表示第一个节点    iterator    finish;   // 表示最后一个节点    map_pointer map;    // 指向map, map是连续空间，每个元素是指针，指向一块缓冲区    size_type map_size;    // map空间大小protected:    // 专属空间配置器  ,每次配置一个元素大小    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;    // 每次配置一个指针大小    typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;...</code></pre><h1 id="3-deque-的操作"><a href="#3-deque-的操作" class="headerlink" title="3 deque 的操作"></a>3 deque 的操作</h1><h2 id="3-1-deque-基本操作"><a href="#3-1-deque-基本操作" class="headerlink" title="3.1 deque 基本操作"></a>3.1 deque 基本操作</h2><pre><code>public:    // 基本访问    iterator begin(){return start;}    iterator end(){return finish;}    reference operator[](size_type n){        return start[difference_type(n)];  // 调用__deque_iterator&lt;&gt;::operator[]    }    reference front(){return *start;}    reference back() {        iterator tmp = finish;        --tmp;        // 调用 __deque_iterator&lt;&gt;::operator--        return *tmp;    }    size_type size() const{return finish - start;}    size_type max_size() const{return size_type(-1);} // ??不明白这个函数    bool empty() const{return finish == start; }</code></pre><p>##3.2  deque的构造和内存管理</p><h3 id="3-2-1-构造"><a href="#3-2-1-构造" class="headerlink" title="3.2.1 构造"></a>3.2.1 构造</h3><ul><li>在前面deque的数据结构中，可以发现deque定义了个空间分配器，一个是用来分配map的空间，一个是用来分配存储空间；</li></ul><p>deque 的一个构造函数如：</p><pre><code>public:    // 构造函数    deque(int n, const value_type&amp; value)        : start(),finish(), map(0), map_size(0){            fill_initialize(n, value);        }protected:    void fill_initialize(size_type n, const value_type&amp; value){        create_map_and_nodes(n);   // 吧deque的结构都产生冰球安排好        map_pointer cur;        __STL_TRY{            // 为每个节点的缓冲区设定初始值            for(cur = start.node;cur&lt; finish.node; ++cur){                uninitialized_fill(*cur, *cur+buffer_size(),value);            }            // 最后一个节点的设定不同（尾部备用空间不用设定初始值）            uninitialized_fill(finish.first,finish.cur,value);        }catch(...){            ...        }    }protected:    //负责产生并且安排好deque的结构    void create_map_and_nodes(size_type num_elements){        // 需要节点数= （元素个数 / 每个缓冲区的大小） +         // 刚好整除，多陪一个节点        size_type num_nodes = num_elements / buffer_size() +1;        // 一个map管理的节点，最少为8个，最多是“所需节点+2”        // 前后预留一个，扩充时使用        map_size = max(initial_map_size(),num_nodes +2);        map = map_allocator::allocate(map_size);        // 令nstart和nfinish指向map拥有的全部节点的中间区段        // 保持在中央，可是头尾两端的扩充能量一样大，        map_pointer nstart = map + (map_size - num_nodes) /2;        map_pointer nfinish = nstart + num_nodes -1;        map_pointer cur;        __STL_TRY{            // 为map内的每个节点配置缓冲区，            for(cur = nstart; cur &lt;=nfinish; ++cur){                *cur = allocate_node();            }        }catch(...){            // &quot;commit of rollback&quot;            ...        }        start.set_node(nstart);        finish.set_node(nfinish);        start.cur  = start.first;        finish.cur = finish.first + num_elements % buffer_size();    }    </code></pre><p>例如：创建一个deque,初始化后，插入了三个值：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3db6dcdabc25be18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-2-2-插入"><a href="#3-2-2-插入" class="headerlink" title="3.2.2 插入"></a>3.2.2 插入</h3><ul><li>push_front()</li><li>push_back()</li></ul><pre><code>public:    void push_back(const value_type&amp; t){        if(finish.cur != finish.last-1){            // 最后缓冲有一个以上的备用空间            construct(finish.cur,t);            ++finish.cur;    // 调整最后缓冲区的状态        }else{  // 最后缓冲区只剩一个备用空间            push_back_aux(t);        }    }    void push_front(const value_type&amp; t){        if(start.cur != start.first){            construct(start.cur -1, t);  // 直接在备用空间构建元素            -- start.cur;        }else{            push_front_aux(t);        }    }</code></pre><p>这两个函数接住了两个辅助函数：</p><pre><code>    // push_bac_aux 先配置一整块新的缓冲区，然后设置新元素，更改finish    void push_bac_aux(const value_type&amp; t){        value_type t_copy=t;        reserve_map_at_back();  // 若符合条件重现换一个map        *(finish.node + 1) = allocate_node(); // 新配置一个节点        __STL_TRY{            construct(finish.cur,t_copy);            finish.set_node(finish.node + 1);  // 改变finish,指向新节点            finish.cur = finish.first;        }        __STL_UNWIND(deallocate_node(*(finish.node + 1)));    }    // push_front_aux 第一缓冲区无备用空间    void push_front_aux(const value_type&amp; t){        value_type t_copy = t;        reserve_map_at_front();   // 若符合条件重现换一个map        *（start.node -1) = allocate_node();  // 配置新节点        __STL_TRY{            start.set_node(start.node - 1);            start.cur = start.last - 1; // 设定start的状态            construct(start.cur, t_copy);        }catch(...){            // &quot;commit or rollback&quot;            start.set_node(start.node + 1);            start.cur = start.first;            deallocate_node(*(start.node - 1);        }    }</code></pre><p>如图：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-85db4fdfb5a59956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-2-3-map的更新"><a href="#3-2-3-map的更新" class="headerlink" title="3.2.3  map的更新"></a>3.2.3  map的更新</h3><ul><li>在插入过程中，导致创建新的缓冲区，因此map的更新：</li></ul><pre><code>protected:    // map 重新配置    void reserve_map_at_back()size_type node_to_add =1){        if(node_to_add +1 &gt; map_size - (finish.node - map)){            // 如果map尾端的节点空间不足，重新配置更大的map空间            reallocate_map(node_to_add,false);        }    }    void reserve_map_at_front(size_type node_to_add =1){        if(node_to_add &gt; start.node - map){            reallocate_map(node_to_add, true);        }    }    // 重新配置map    void reallocate_map(size_type node_to_add, bool add_to_front){        size_type old_num_nodes = finish.node - start.node;        size_type new_num_nodes = old_num_nodes + node_to_add;        map_pointer new_nstart;        if(map_size &gt; 2*new_num_nodes){ // 原来空间足够大，中间平移            new_nstart = map + (map_size - new_num_nodes) /2                        + (add_to_front ? node_to_add  : 0); //             if(new_nstart &lt;start.node){                copy(start.node, finish.node + 1,new_nstart);            }else{                copy_backward(start.node,finish.node, new_nstart + old_num_nodes);            }        }else{            size_type new_map_size = map_size + max(map_size, node_to_add) + 2);            // 配置一块新的空间            map_pointer new_map = map_allocator::allocate(new_map_size);            new_nstart = new_map + (new_map_size - new_num_nodes) /2                        + (add_to_front? node_to_add : 0);            // 把原来map内容拷贝过来            copy(start.node, finish.node+1, new_nstart);            // 释放原来map            map_allocator::deallocate(map, map_size);            map = new_map;            map_size = new_map_size;        }        // 重新设定迭代器        start.set_node(new_nstart);        finish.set_node(new_nstart + old_num_nodes -1);    }</code></pre><h3 id="3-2-4-insert"><a href="#3-2-4-insert" class="headerlink" title="3.2.4 insert()"></a>3.2.4 insert()</h3><pre><code>    // insert         iterator isnert(iterator position, const value_type&amp; x){        if(position.cur == start.cur){// 插入最前端            push_front(x);            return start;        }else if(position.cur = finish.cur){  // 冲入最尾部            push_back(x);            iterator tmp = finish;            --tmp;            return tmp;        }else{            return insert_aux(position, x);        }    }</code></pre><p>辅助函数：</p><pre><code>    // insert_aux    iterator insert_aux(iterator pos, const value_type&amp; x){        difference_type index = pos - start; // 插入之间的元素个数        value_type x_copy = x;        if(index &lt; size() /2 ){  // 插入之前的元素个数较少            push_front(front());   // 在最前端加入与第一元素同值的元素            iterator front1 = start;            ++front1;            iterator front2 = front1;            ++front2;            pos = start + index;            iterator pos1 = pos;            ++pos1;            copy(front2, pos1, front1);  // 元素移动         }else{  // 插入点之后元素比较少            push_back(back());   // 尾端插入与最后一个元素一样的元素            iterator back1 = finish;            -- back1;            iterator back2 = back1;            -- back2;             pos = start + index;            copy(pos, back2, back1);  // 元素移动        }        *pos = x_copy;        return pos;    }</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/04/STL-%E5%AE%B9%E5%99%A8-deque-1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
