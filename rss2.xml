<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Tue, 23 Oct 2018 03:41:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CS231A-Homework-3.1</title>
      <link>https://jingxa.github.io/2018/10/22/CS231A-Homework-3-1/</link>
      <guid>https://jingxa.github.io/2018/10/22/CS231A-Homework-3-1/</guid>
      <pubDate>Mon, 22 Oct 2018 13:05:31 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cs231A Homework-3:ps3_code-space_carving&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一、-Space-carving&quot;&gt;&lt;a href=&quot;#一、-Space-carving&quot; class=
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>cs231A Homework-3:ps3_code-space_carving</p></blockquote><hr><h1 id="一、-Space-carving"><a href="#一、-Space-carving" class="headerlink" title="一、 Space carving"></a>一、 Space carving</h1><p>本节内容实现一个有效的Space carving 框架的部分。<br>实现过程的步骤划分如下：</p><ol><li>生成初始体素网格</li><li>实现一个视图下的carving</li><li>多视图下的carving</li><li>提高准确率</li><li>验证</li></ol><h2 id="1-生成初始体素网格：form-initial-voxels"><a href="#1-生成初始体素网格：form-initial-voxels" class="headerlink" title="1. 生成初始体素网格：form_initial_voxels()"></a>1. 生成初始体素网格：form_initial_voxels()</h2><p>函数参数</p><ul><li>xlim:x轴大小：<code>[xmin, xmax]</code></li><li>ylim: y轴大小：<code>[ymin, ymax]</code></li><li>zlim: z轴大小：<code>[zmin, zmax]</code></li><li>num_voxels: voxels的数量</li></ul><p>返回值：</p><ul><li>voxels: <code>(N,3)</code> 数组，返回N个体素的位置</li><li>voxel_size: 每个voxel的size</li></ul><blockquote><p>计算voxel_size: 即求得整个立方体体积除去数量，但是可能由于不能除尽</p><ol><li>计算每个voxel的体积，然后开三次方根，得到size</li><li>获得网格中心数组，使用<code>np.linspace</code>和<code>np.meshgrid</code><br>注意小数问题</li></ol></blockquote><ul><li><code>np.linspace(min,max,gap)</code>:在<code>[min,max]</code>区间以gap获得一个数组</li><li><a href="https://blog.csdn.net/lllxxq141592654/article/details/81532855?utm_source=blogxgwz0" target="_blank" rel="noopener">np.meshgrid</a>:获得网格矩阵</li></ul><pre><code class="python">def form_initial_voxels(xlim, ylim, zlim, num_voxels):    x_dim = xlim[1] - xlim[0]    y_dim = ylim[1] - ylim[0]    z_dim = zlim[1] - zlim[0]   # 获取三轴的长度    total_vol = x_dim * y_dim * z_dim  # 体积    one_vol = float(total_vol / num_voxels)    voxel_size = np.cbrt(one_vol)                   # 三次方根    x_voxel_num = np.round(x_dim / voxel_size)      # x轴的cube 数量,round 取整    y_voxel_num = np.round(y_dim / voxel_size)    z_voxel_num = np.round(z_dim / voxel_size)    x = np.linspace(xlim[0] + 0.5 * voxel_size,                    xlim[0] + (0.5 + x_voxel_num - 1) * voxel_size, x_voxel_num )     # 只取前 num_voxels个    y = np.linspace(ylim[0] + 0.5 * voxel_size,                    ylim[0] + (0.5 + y_voxel_num - 1) * voxel_size, y_voxel_num)     # 只取前 num_voxels个    z = np.linspace(zlim[0] + 0.5 * voxel_size,                    zlim[0] + (0.5 + z_voxel_num - 1) * voxel_size, z_voxel_num)     # 只取前 num_voxels个    XX, YY, ZZ = np.meshgrid(x, y, z)    voxels = np.r_[(XX.reshape(-1), YY.reshape(-1), ZZ.reshape(-1))].reshape(3, -1).T   # N *3    return voxels, voxel_size</code></pre><p>提示： 相关的函数：<code>np.meshgrid, np.repeat, np.tile</code></p><h2 id="2-裁剪一个视图中不属于物体的体素：carve"><a href="#2-裁剪一个视图中不属于物体的体素：carve" class="headerlink" title="2. 裁剪一个视图中不属于物体的体素：carve()"></a>2. 裁剪一个视图中不属于物体的体素：carve()</h2><p>函数参数：</p><ul><li>voxels: 体素数组</li><li>camera： 相机位置，存储数据： “silhouette” 矩阵， “image”, 和projection matrix “P”</li></ul><p>返回：</p><ul><li>voxels</li></ul><p>首先需要将3D体素投影到2D图片，移除不属于</p><pre><code class="python">def carve(voxels, camera):    N = voxels.shape[0]    homo_voxels = np.c_[voxels, np.ones((N, 1))].T  # 4 * N    voxel_index = np.arange(0, N)    P = camera.P        # 投影矩阵 3 * 4    img_voxels = P.dot(homo_voxels)   # 3 * N  , 投影到图片    img_voxels /= img_voxels[2, :]   # 归一化    img_voxels = img_voxels[0:2, :].T     # 去掉z轴 N*2    sli = camera.silhouette  # 从camera文件中了解相关信息    sli_idx = np.nonzero(sli)    xmin, xmax = np.min(sli_idx[1]), np.max(sli_idx[1])     # 列    ymin, ymax = np.min(sli_idx[0]), np.max(sli_idx[0])     # 行    voxelX = img_voxels[:, 0]    voxelY = img_voxels[:, 1]    x_filter = np.all([voxelX &gt; xmin, voxelX &lt; xmax], axis=0)       # 一个轴上的逻辑与运算    y_filter = np.all([voxelY &gt; ymin, voxelY &lt; ymax], axis=0)    filter = np.all([x_filter, y_filter], axis=0)    img_voxels = img_voxels[filter, :]      # 过滤大于轮廓矩阵的像素点    voxel_index = voxel_index[filter]     # 过滤掉序号    img_voxels = img_voxels.astype(int)     # 由于归一化，可能有小数，转为整数    sli_filter = (sli[img_voxels[:, 1], img_voxels[:, 0]] == 1)     # (x,y)是否在轮廓矩阵中    voxel_index = voxel_index[sli_filter]    return voxels[voxel_index, :]</code></pre><h2 id="3-获得更好的边界：get-voxel-bounds"><a href="#3-获得更好的边界：get-voxel-bounds" class="headerlink" title="3. 获得更好的边界：get_voxel_bounds()"></a>3. 获得更好的边界：get_voxel_bounds()</h2><p>在初始版本中的方法中，获得voxel的边界是根据相机的位置来计算的【暂时没看明白】</p><p>如果需要获得更好的边界，可以先对初始的立方体进行初始剪切一遍，然后获取得到的voxels，取得最大和最小的点，作为边界值</p><pre><code class="python">def get_voxel_bounds(cameras, estimate_better_bounds = False, num_voxels = 4000):    camera_positions = np.vstack([c.T for c in cameras])    print(camera_positions.shape)    print(&quot;0:&quot;, camera_positions[0])    xlim = [camera_positions[:,0].min(), camera_positions[:,0].max()]    ylim = [camera_positions[:,1].min(), camera_positions[:,1].max()]    zlim = [camera_positions[:,2].min(), camera_positions[:,2].max()]    # For the zlim we need to see where each camera is looking.     camera_range = 0.6 * np.sqrt(diff( xlim )**2 + diff( ylim )**2)    for c in cameras:        viewpoint = c.T - camera_range * c.get_camera_direction()        zlim[0] = min( zlim[0], viewpoint[2] )        zlim[1] = max( zlim[1], viewpoint[2] )    # Move the limits in a bit since the object must be inside the circle    xlim = xlim + diff(xlim) / 4 * np.array([1, -1])    ylim = ylim + diff(ylim) / 4 * np.array([1, -1])    if estimate_better_bounds:        voxels, voxel_size  = form_initial_voxels(xlim, ylim, zlim, num_voxels)        for c in cameras:            voxels = carve(voxels, c)        min_point = np.min(voxels, axis=0) - voxel_size        max_point = np.max(voxels, axis=0) + voxel_size        xlim[0], ylim[0], zlim[0] = min_point[0], min_point[1], min_point[2]        xlim[1], ylim[1], zlim[1] = max_point[0], max_point[1], max_point[2]    return xlim, ylim, zlim</code></pre><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><h3 id="4-1-form-initial-voxels形成一个初始立方体"><a href="#4-1-form-initial-voxels形成一个初始立方体" class="headerlink" title="4.1 form_initial_voxels形成一个初始立方体"></a>4.1 form_initial_voxels形成一个初始立方体</h3><p><img src="/imgages/cs231a/ps3/space_c_a.png" alt="iniital_voxels"></p><h3 id="4-2-carving-一个视角的裁剪"><a href="#4-2-carving-一个视角的裁剪" class="headerlink" title="4.2 carving : 一个视角的裁剪"></a>4.2 carving : 一个视角的裁剪</h3><p><img src="/imgages/cs231a/ps3/space_c_b.png" alt="one_carving"></p><h3 id="4-3-没有优化边界的多视角裁剪"><a href="#4-3-没有优化边界的多视角裁剪" class="headerlink" title="4.3 没有优化边界的多视角裁剪"></a>4.3 没有优化边界的多视角裁剪</h3><p><img src="/imgages/cs231a/ps3/space_c_c.png" alt="muliti_carving"></p><h3 id="4-4-优化边界的多视角裁剪"><a href="#4-4-优化边界的多视角裁剪" class="headerlink" title="4.4 优化边界的多视角裁剪"></a>4.4 优化边界的多视角裁剪</h3><p><img src="imgages/cs231a/ps3/space_c_d.png" alt="best_carving"></p><h2 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3. 参考文章"></a>3. 参考文章</h2><ol><li><a href="https://github.com/zyxrrr/cs231a/blob/master/ps3/space_carving/main.py" target="_blank" rel="noopener">zyxrrr/cs231a</a></li><li><a href="https://github.com/mikucy/CS231A/blob/master/ps3_code/space_carving/main.py" target="_blank" rel="noopener">CS231A/ps3_code/space_carving</a></li><li><a href="https://github.com/chizhang529/cs231a/tree/master/Homework/PS3" target="_blank" rel="noopener">cs231a/Homework/PS3/</a></li></ol><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/10/22/CS231A-Homework-3-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CS231A_说明</title>
      <link>https://jingxa.github.io/2018/10/22/CS231A-%E8%AF%B4%E6%98%8E/</link>
      <guid>https://jingxa.github.io/2018/10/22/CS231A-%E8%AF%B4%E6%98%8E/</guid>
      <pubDate>Mon, 22 Oct 2018 13:01:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;h3 id=&quot;课程相关&quot;&gt;&lt;a href=&quot;#课程相关&quot; class=&quot;headerlink&quot; title=&quot;课程相关&quot;&gt;&lt;/a&gt;课程相关&lt;/h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h3 id="课程相关"><a href="#课程相关" class="headerlink" title="课程相关"></a>课程相关</h3><ul><li><a href="http://web.stanford.edu/class/cs231a/index.html" target="_blank" rel="noopener">CS231A: Computer Vision, From 3D Reconstruction to Recognition</a></li></ul><h3 id="本人解答过程"><a href="#本人解答过程" class="headerlink" title="本人解答过程"></a>本人解答过程</h3><ul><li>具体过程查看博客</li></ul><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><ul><li><a href="https://github.com/chizhang529/cs231a" target="_blank" rel="noopener">chizhang529/cs231a</a></li><li><a href="https://github.com/mikucy/CS231A" target="_blank" rel="noopener">mikucy/CS231A</a></li><li><a href="https://github.com/zyxrrr/cs231a" target="_blank" rel="noopener">zyxrrr/cs231a</a></li></ul><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/10/22/CS231A-%E8%AF%B4%E6%98%8E/#disqus_thread</comments>
    </item>
    
    <item>
      <title>kali linux 循环登录</title>
      <link>https://jingxa.github.io/2018/09/25/kali-loop-login/</link>
      <guid>https://jingxa.github.io/2018/09/25/kali-loop-login/</guid>
      <pubDate>Tue, 25 Sep 2018 07:24:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;想要安装一个kali linux学习，但是虚拟机测过，太卡了， 不能满足需求，因此，只能安装多系统主机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电脑： 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>想要安装一个kali linux学习，但是虚拟机测过，太卡了， 不能满足需求，因此，只能安装多系统主机。</p><ul><li>电脑： 电脑上已经安装了win10,ubuntu18.04；</li></ul><p>在网上找过一些安装三系统的教程，但是说的似是而非，干脆破罐子破摔，直接上！（看了几个教程都说Ultraiso好像不行，因此直接使用Win32DiskImager）</p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol><li><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华大学软件站</a> 下载kali系统</li><li><code>Win32DiskImager</code>制作U盘启动盘</li><li>先在<code>win10</code>下进行分区，压缩出一块空间不要格式化</li><li>直接重启然后选择<code>boot</code>选项，u盘启动</li><li>然后将<code>kali</code>安装到预留的磁盘</li><li>在安装过程中，会识别到win10，ubuntu的启动项，直接选择已经有的启动项</li><li>然后重启后直接进入kali的启动项，不过win10和ubuntu的启动项都在！(没有遇到什么win10和ubuntu的启动项消失的状况)</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>电脑是台式机机器，安装完成后，在登录界面出现问题，账号密码正确，但是不能登录进去！</li></ol><p>解决办法：</p><ul><li><p>首先 <code>ctrl + alt + F1</code>，【其中F1~F6都可以进入命令终端模式】,<code>ctrl+alt+F7</code>:回到窗口模式</p></li><li><p>然后，需要更新系统</p></li></ul><pre><code class="bash">sudo apt-get updatesudo apt-get upgrade -f</code></pre><ul><li><code>reboot</code>即可</li></ul><h1 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h1><ul><li>本人的环境是wifi环境，使用了USB的wifi连接器，然后连接wifi.</li></ul><p>命令模式下的wifi连接方式：</p><ul><li><code>wpa_cli</code>:这个工具比较方便</li></ul><p>简单的使用教程：</p><pre><code class="bash">&gt; wpa_cli            # 终端中直接输入# 一般默认的wlan为wlan0,即无线网卡的名字&gt; add_network        # 这个就是创建一个新的网络连接&gt; 0                    # 默认创建的网络连接编号&gt; set_network 0 ssid &quot;mywifi&quot;    # 通过set_network给 连接0 添加 ssid ,引号中为wifi名称&gt; set_network 0 psk  &quot;12345678&quot;  # 添加密码 psk, 密码为引号中：12345678&gt; enable_network 0                 # 启动连接0# 输入 q 退出 wpa_cli&gt; q# 在终端中，打开连接~#: dhclient wlan0                 # 刚刚在wlan0上创建的连接</code></pre><ul><li>不知道是我的wifi信号不好还是怎么回事？几分钟后连接必然断开，因此，选择另一种做法！</li></ul><ol><li>如果没有<code>wpa_cli</code>，可能需要安装：</li></ol><pre><code class="bash">sudo apt-get install wireless-tools</code></pre><ol start="2"><li>配置网络：<code>修改/etc/network/interfaces文件</code></li></ol><p>在这个文件中添加需要的部分</p><pre><code class="bash">auto loiface lo inet loopbackauto eth0iface eth0 inet dhcpallow-hotplug wlan0auto wlan0iface wlan0 inet dhcp    wpa-ssid YOUR-SSID-HERE    wpa-psk YOUR-PASSWORD-HERE</code></pre><ul><li>替换上面<code>YOUR-SSID-HERE</code>： 为自己的wifi名称</li><li><code>YOUR-PASSWORD-HERE</code>: 为自己的wifi密码</li></ul><ol start="3"><li>重启连接</li></ol><pre><code class="bash">/etc/init.d/networking restart# or: service networking restart</code></pre><ul><li>如果启动失败，使用<code>journalctl -xe</code>查看系统日志，我发现我使用wpa_cli的时候启动了一个进程，杀掉相关的进程就可以了！</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://superuser.com/questions/987969/cant-login-in-kali-linux" target="_blank" rel="noopener">Can’t login in Kali Linux</a></li><li><a href="https://segmentfault.com/a/1190000011579147" target="_blank" rel="noopener">wpa_supplicant及wpa_cli使用方法</a></li><li><a href="http://imchao.wang/2014/01/02/make-you-raspberrypi-auto-connect-to-wifi/" target="_blank" rel="noopener">让你的树莓派连上WiFi</a></li><li><a href="https://www.jianshu.com/p/69807d3d4474" target="_blank" rel="noopener">Debian 9 下折腾 usb 无线网卡上网</a></li></ol><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/09/25/kali-loop-login/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4_后台开发_编译</title>
      <link>https://jingxa.github.io/2018/08/03/4-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-%E7%BC%96%E8%AF%91/</link>
      <guid>https://jingxa.github.io/2018/08/03/4-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-%E7%BC%96%E8%AF%91/</guid>
      <pubDate>Fri, 03 Aug 2018 02:53:19 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;来自于《后台开发: 核心技术与应用实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361608-dd8945f71619
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>来自于《后台开发: 核心技术与应用实践》</p></blockquote><hr><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd8945f716198740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-1-预处理"><a href="#1-1-预处理" class="headerlink" title="1.1 预处理"></a>1.1 预处理</h2><pre><code>g++ -E helloworld.cpp -o helloworld.i</code></pre><ul><li><code>-E</code> : 只进行预处理</li></ul><h3 id="1-1-1-删除-define"><a href="#1-1-1-删除-define" class="headerlink" title="1.1.1 删除 #define"></a>1.1.1 删除 <code>#define</code></h3><ul><li>第一步 删除所有#define, 展开所有宏定义；</li></ul><h3 id="1-1-2-处理所有条件预编译指令"><a href="#1-1-2-处理所有条件预编译指令" class="headerlink" title="1.1.2 处理所有条件预编译指令"></a>1.1.2 处理所有条件预编译指令</h3><ul><li>比如 <code>#if , #ifdef, #elif, #else, #endif</code></li></ul><h3 id="1-1-3-处理-include指令"><a href="#1-1-3-处理-include指令" class="headerlink" title="1.1.3 处理#include指令"></a>1.1.3 处理#include指令</h3><ul><li>将被包含的文件插入到该预编译指令的位置；</li><li>递归进行的；</li></ul><h3 id="1-1-4-过滤所有的注释"><a href="#1-1-4-过滤所有的注释" class="headerlink" title="1.1.4 过滤所有的注释 //,/**/"></a>1.1.4 过滤所有的注释 <code>//,/**/</code></h3><h3 id="1-1-5-添加行号和文件名标识"><a href="#1-1-5-添加行号和文件名标识" class="headerlink" title="1.1.5 添加行号和文件名标识"></a>1.1.5 添加行号和文件名标识</h3><ul><li>以便于编译时编译器产生调试用的行的信息以及编译时产生编译错误或警告是能够显示行号</li></ul><h3 id="1-1-6-保留所有的-pragma-编译指令"><a href="#1-1-6-保留所有的-pragma-编译指令" class="headerlink" title="1.1.6 保留所有的#pragma 编译指令"></a>1.1.6 保留所有的#pragma 编译指令</h3><ul><li>因为编译器需要使用它们</li></ul><hr><h2 id="1-2-编译"><a href="#1-2-编译" class="headerlink" title="1.2 编译"></a>1.2 编译</h2><pre><code>g++ -S helloworld.i -o helloworld.s</code></pre><ul><li><p><code>-S</code>（大写）: 只执行到源代码到汇编代码的转换</p></li><li><p>编译过程为六步：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-df312848ad15a3ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>源代码优化</li><li>代码生成</li><li>目标代码优化</li></ul><h2 id="1-3-链接"><a href="#1-3-链接" class="headerlink" title="1.3 链接"></a>1.3 链接</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-069ee5091b3fc008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>重定位入口</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-403708008eb9430f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-3-1-静态链接"><a href="#1-3-1-静态链接" class="headerlink" title="1.3.1 静态链接"></a>1.3.1 静态链接</h3><ul><li>编译时期完成的链接；</li></ul><pre><code>g++ -c add.cppg++ -c sub.cpp</code></pre><ul><li><code>-c</code> : 只执行到编译，输出目标文件</li><li>生成<code>add.o ，sub.o</code>文件</li></ul><p>静态链接库：</p><pre><code>ar cr libmy.a sub.o add.o</code></pre><ul><li>生成libmy.a 文件</li><li><code>ar</code>: 显示库文件 中的.o 文件<ul><li><code>ar 选项 c</code>: 在库中插入模块（替换），当库中的模块存在，就替换同名的模块；如果插入的模块不存在，ar显示错误信息；默认新的成员添加库的末尾；</li><li><code>ar 选项 r</code>：创建一个库，不管库是否存在；</li><li><code>ar 选项 tv</code>: <code>ar tv xx.a</code>,可以查看库中包含哪些目标文件模块；</li></ul></li></ul><p>将静态库连接到程序中，</p><pre><code>g++ -o main main.cpp -L. -lmylib</code></pre><ul><li><code>-L.</code>: 标记告诉G++函数库可能位于当前目录</li><li><code>-lmylib</code>:连接库 mylib</li></ul><p>最终生成main文件</p><h3 id="1-3-2-动态链接"><a href="#1-3-2-动态链接" class="headerlink" title="1.3.2 动态链接"></a>1.3.2 动态链接</h3><ul><li>程序运行时的链接；</li><li>扩展名为<code>.so</code>;</li></ul><p>例子：<br>四个文件：</p><ul><li><code>add.h add.cpp, sub.h , sub.cpp, main.cpp</code></li></ul><p>生成动态库文件：</p><pre><code>g++ -fPIC -o add.o -c add.cppg++ -fPIC -o sub.o -c sub.cppg++ -shared -o libmymath.so add.o sub.o</code></pre><ul><li><code>fPIC</code>: 表示编译为位置独立的代码：不用此选项编译后的代码是位置相关的，所以动态载入时通过代码复制的方式来满足不用进程的需要，不能达到真正代码段共享的目的；</li><li><code>Lpath</code>: 表示在path目标中搜索库文件，如<code>-L.</code>：表示在当前目标</li><li><code>Ipath</code>: 表示在path目标搜索头文件</li><li><p><code>Itest</code>: 编译器查找动态链接库时隐含的命名规则，即在给出的名字前面加上lib， 后面加上.so来确定库的名称；</p></li><li><p>链接库找不到问题</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3a1ddd775cfeb506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>动态库与静态库重名问题</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6df474809dbeecf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8bcd2dddbd22bb10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>静态库和动态库的特点</li></ul><ol><li>动态库有利于进程间资源共享；</li><li>程序升级变得简单；静态库需要重新编译</li><li>链接载入完成有程序员在程序代码中控制；</li><li>静态库速度快</li></ol><h2 id="1-4-g-和gcc的区别"><a href="#1-4-g-和gcc的区别" class="headerlink" title="1.4 g++ 和gcc的区别"></a>1.4 g++ 和gcc的区别</h2><h3 id="1-4-1-后缀-c和cpp"><a href="#1-4-1-后缀-c和cpp" class="headerlink" title="1.4.1 后缀 .c和cpp"></a>1.4.1 后缀 <code>.c</code>和<code>cpp</code></h3><ul><li>gcc: 当做c程序</li><li>g++ : 当做c++程序</li><li><code>cpp</code>：都当做c++程序，并且语法规则检查严格；</li></ul><h3 id="1-4-2-编译阶段"><a href="#1-4-2-编译阶段" class="headerlink" title="1.4.2 编译阶段"></a>1.4.2 编译阶段</h3><ul><li>g++ 调用gcc : 对于c++代码，两个等价，但是 gcc不过自动和c++程序使用的库连接，所有使用g++完成链接；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a5b6b4faf576e6e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/08/03/4-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-%E7%BC%96%E8%AF%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Inside_Cplusplus_data</title>
      <link>https://jingxa.github.io/2018/07/25/Inside-Cplusplus-data/</link>
      <guid>https://jingxa.github.io/2018/07/25/Inside-Cplusplus-data/</guid>
      <pubDate>Wed, 25 Jul 2018 03:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度探索c++对象模型第三章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;pre&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>深度探索c++对象模型第三章</p></blockquote><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>class A{};class B: public virtual A{};class C: public virtual A{};class D: public B, public C{ char c;};   cout&lt;&lt;&quot;A:&quot;&lt;&lt;sizeof(A)&lt;&lt;endl;   cout&lt;&lt;&quot;B:&quot;&lt;&lt;sizeof(B)&lt;&lt;endl;   cout&lt;&lt;&quot;C:&quot;&lt;&lt;sizeof(C)&lt;&lt;endl;   cout&lt;&lt;&quot;D:&quot;&lt;&lt;sizeof(D)&lt;&lt;endl;</code></pre><p>结果为：</p><pre><code>A:1B:4C:4D:12</code></pre><ul><li><p>一个空类，<code>sizeof(A) == 1 byte</code>（这是编译器安插的一个char,是这个class对象在内存中有独一的地址）</p></li><li><p>当虚拟继承一个类的时候，类中存放了指向<code>virtual base class subobject</code>的相关的指针(本编译器指针为4bytes):</p><ul><li>但是，B,C为什么为4 bytes不为5bytes ? 因为，指向virtual base class的指针占据了类的开头，有了成员，则不需要编译器安插一个char；</li></ul></li><li><p>Alignment的限制；在32位计算机上，为了使bus的效率达到最高，一般采取内存对齐的方式；如B,C刚好4bytes，</p></li><li><p>对于类D:</p><ul><li>一个<code>virtual base class subobject</code>只会在派生类中存在一份实体</li><li>被大家共享的A只有一个实体， 大小为1bytes;(有了成员就会忽略)</li><li>B和C加起来为8bytes;</li><li>class D中有一个<code>char</code>  1byte;<br>因此，D中（两个指针，一个char），对齐后为12bytes;</li></ul></li></ul><p>如图中， X:为A, Y,Z为B,C;<br><img src="https://upload-images.jianshu.io/upload_images/5361608-9d9ed4f62b0d8c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="1-data-member-的绑定"><a href="#1-data-member-的绑定" class="headerlink" title="1. data member 的绑定"></a>1. data member 的绑定</h1><pre><code>typedef    int length;class Point3d{public:    // length 被决议为global length    void mumble(length val){_val = val;}    length mumble(){return _val;}    //...private:    // length 的声明要放在“本class 对它的第一个参考之前”    // 这个length会导致前面的操作 非法    typedef float length;    length _val;    // ...};</code></pre><h1 id="2-data-member-的布局"><a href="#2-data-member-的布局" class="headerlink" title="2. data member 的布局"></a>2. data member 的布局</h1><ol><li>Nonstatic data member在class object 的<pre><code> 同一access section（public, private, protected）中的排列顺序和声明顺序一样</code></pre></li></ol><pre><code>// 例子class Point3d{public:    // ..private:    float x;    static List&lt;Point3d*&gt; *freeeList;    float y;    static const int chunksize = 250;    float z;}; // 等价于class Point3d{public:    // ..private:    float x;    static List&lt;Point3d*&gt; *freeeList;private:    float y;    static const int chunksize = 250;private:    float z;}; </code></pre><h1 id="3-data-Member-的存取"><a href="#3-data-Member-的存取" class="headerlink" title="3. data Member 的存取"></a>3. data Member 的存取</h1><p>对于一个</p><pre><code>    Point3d origin, *pt = &amp;origin;    origin.x  = 0.0;    pt -&gt; x = 0.0;</code></pre><p>这两种存取方式的差异</p><ul><li>如果point3d是一个派生类，在其继承结构中有一个virtual base class，并且被存取的是一个virtual base class 中继承来的member时， 必须要等待执行器才能确定pt指向哪一种class type; </li></ul><ul><li>static data member 的存取<br>static data member 存放在 global data segment中， 取static data member 的地址得到的是一个指向static data的指针；</li></ul><h1 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h1><h2 id="4-1-只继承没有多态"><a href="#4-1-只继承没有多态" class="headerlink" title="4.1 只继承没有多态"></a>4.1 只继承没有多态</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-581623f1f3ac1e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-294830430c13f41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>继承中的问题：<ul><li>把一个class 分解成多个层继承，导致class 膨胀；</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-871ea6f095a60a46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于图中的类，我们可以定义三个层级的继承；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bd4e21e54c753ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>继承的布局为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7af278ee7d673e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>如图所示，每个类由于内存对齐，有了很多的padding;</li></ul><p>但是，如果把padding去掉，破坏“<code>base class subobject</code>”的完整性，导致的后果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-aa0c26f7447bfd19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-2-加上多态"><a href="#4-2-加上多态" class="headerlink" title="4.2 加上多态"></a>4.2 加上多态</h2><h3 id="4-2-1-多态继承"><a href="#4-2-1-多态继承" class="headerlink" title="4.2.1 多态继承"></a>4.2.1 多态继承</h3><ul><li>对于虚函数，类必须产生一个vptr指向虚函数表；</li></ul><pre><code>struct no_virts{    int d1,d2;};class has_virts: public no_virts{public:    virtual void foo();    // ...private:    int d3;};</code></pre><p>内存布局为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-a85603d750f45665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="4-2-2-vptr的内存布局"><a href="#4-2-2-vptr的内存布局" class="headerlink" title="4.2.2  vptr的内存布局"></a>4.2.2  vptr的内存布局</h3><p>vptr的布局一般放在class object 的开头或者结尾；</p><ul><li><p>结尾：能够保留<code>base class C struct</code>的对象布局，因而能够在c程序代码中使用；</p></li><li><p>前端： “在多重继承下， 通过指向class members的指针调用virtual function”，会有帮助；</p></li></ul><h3 id="4-2-3-多重继承"><a href="#4-2-3-多重继承" class="headerlink" title="4.2.3 多重继承"></a>4.2.3 多重继承</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9721f7d43e638aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><code>point2d</code> ,<code>Vertex</code>两个类含有virtual接口<br>内存布局为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-57cc458f7cbe08d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-3-虚拟继承"><a href="#4-3-虚拟继承" class="headerlink" title="4.3 虚拟继承"></a>4.3 虚拟继承</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e374d8b25ef6a23a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><code>Vertex</code>和<code>Point3d</code>虚拟继承Point2d</li><li>·<code>Vertex3d</code>普通继承两个类；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9f0e2f2fc058764f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>对于<code>virtual base class</code>：</li></ul><p>【方法一】：</p><ul><li>在每个<code>vritual base class</code> 的派生类中加入一个指针，指向<code>virtual base class</code><ul><li>如图3.5a</li></ul></li></ul><p>【方法二】：</p><ul><li>c++在<code>virtual function table</code> 中放置<code>virtual base class</code>的offset,<code>virtual function table</code>通过正负索引来判断；</li><li>索引为正值，索引到虚函数</li><li>索引为负值，索引到<code>virtual base class</code>的offsets</li></ul><p>如图所示:<br><img src="https://upload-images.jianshu.io/upload_images/5361608-aaa028bbf0650183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/25/Inside-Cplusplus-data/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
