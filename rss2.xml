<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sun, 22 Jul 2018 07:24:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Inside_Cplusplus_构构造_copy</title>
      <link>https://jingxa.github.io/2018/07/22/Inside-Cplusplus-%E6%9E%84%E6%9E%84%E9%80%A0-copy/</link>
      <guid>https://jingxa.github.io/2018/07/22/Inside-Cplusplus-%E6%9E%84%E6%9E%84%E9%80%A0-copy/</guid>
      <pubDate>Sun, 22 Jul 2018 07:23:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度探索c++对象模型第二章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>深度探索c++对象模型第二章</p></blockquote><hr><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/22/Inside-Cplusplus-%E6%9E%84%E6%9E%84%E9%80%A0-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Inside_Cplusplus_构造_default</title>
      <link>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/</link>
      <guid>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/</guid>
      <pubDate>Sat, 21 Jul 2018 11:23:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度探索c++对象模型第二章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-默认构造函数&quot;&gt;&lt;a href=&quot;#1-默认构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 默认构造函数
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>深度探索c++对象模型第二章</p></blockquote><hr><h1 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h1><ul><li>默认构造函数在被需要的时被编译器产出来；</li><li>编译器需要的时候，才产生默认构造函数；<ul><li>编译器合成的构造函数只执行编译器所需要的行动，不会将data成员初始化；</li></ul></li></ul><p>【注意】：当class包含多个constructor，但是没有default constructor，编译器不会产生default constructor，而是扩展每个constructor；</p><p>编译器产生的默认构造函数分为：</p><ul><li>是(trivial)平凡的，即没有任何用处的；</li><li>non-trivial:有用的</li></ul><p>一下讨论产生non-trivial 默认构造函数的情况：</p><h2 id="1-1-带有“默认构造函数”的member-class-对象"><a href="#1-1-带有“默认构造函数”的member-class-对象" class="headerlink" title="1.1 带有“默认构造函数”的member class 对象"></a>1.1 带有“默认构造函数”的member class 对象</h2><ul><li>如果一个class，包含一个<code>member object</code> ， 后者有<code>默认构造函数</code>，那么这个class的合成的默认构造函数是<code>non-trivial</code>的；</li></ul><p>例子：</p><pre><code>/****************** 例子1 ****************/class Foo {public:    Foo();    Foo(int);    ...};class Bar{public:    Foo foo;    char *str;};// 编译器合成的版本// 伪代码Bar::Bar(){        foo.Foo::FOO();  // 编译器代码}// 为了代码正确执行// str 必须初始化， 程序员的代码Bar::Bar(){    str =0;  // explicit user code}// 编译器扩展版本Bar::Bar(){    foo.Foo::FOO();  // 编译器代码    str =0;  // explicit user code}/************* 例子2 ：   ***************/class Dopey{public:    Dopey();    ...};class Sneezy{public:    Sneezy();    Sneezy(int);    ...};class Bashful{public:    Bashful();    ...};Class Snow_white{public:    Dopey dopey;    Sneezy sneezy;    Bashful bashful;    ...private:    int mumble;};// 如果未定义默认函数// 编译器合成版本Snow_white::Snow_white(){    dopey.Dopey::Dopey();    sneezy.Sneezy::Sneezy();    bashful.Bashful::Bashful();}/* 程序员的代码 */Snow_white::Snow_white():sneezy(1024){    mumble = 2028;}// 编译器扩充为：/* 程序员的代码 */Snow_white::Snow_white():sneezy(1024){    // 插入代码    dopey.Dopey::Dopey();    sneezy.Sneezy::Sneezy(1024);    bashful.Bashful::Bashful();    mumble = 2028;}</code></pre><h2 id="1-2-带有-“default-constructor-”的Base-class"><a href="#1-2-带有-“default-constructor-”的Base-class" class="headerlink" title="1.2 带有 “default constructor ”的Base class"></a>1.2 带有 “default constructor ”的Base class</h2><pre><code>如果一个没有任何构造函数的class 派生带有“default constructor”的base class。这个派生类的合成默认构造函数为non-trivial</code></pre><h2 id="1-3-“带有一个virtual-Function”的-Class"><a href="#1-3-“带有一个virtual-Function”的-Class" class="headerlink" title="1.3 “带有一个virtual Function”的 Class"></a>1.3 “带有一个virtual Function”的 Class</h2><pre><code>- 1. class  声明或者继承一个 virtual Function;- 2. class 派生子一个继承串链，其中有一个或者多个 virtual base classes;如果程序员没有声明constructor， 编译器就会合成一个default constructor;【编译器动作】- 1. virtual function table(vtpl)会被编译器产生出来，    内放    virtual function  的地址；- 2. 在每一个class object中，一个额外的pointer member（vptr)    会被编译器合成出来，内含相关的class vbtl的地址；</code></pre><h2 id="1-4-“带有一个-virtual-base-class”-的class"><a href="#1-4-“带有一个-virtual-base-class”-的class" class="headerlink" title="1.4 “带有一个 virtual base class” 的class"></a>1.4 “带有一个 virtual base class” 的class</h2><pre><code>编译器会安插“允许每一个virtual base class 的执行器存取操作”的代码；</code></pre><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><pre><code>1. 在合成的default constructor中，只有base class subobjects和    member class objects被初始化2. 其他的non-static data member, 如整数，整数指针，数组等不会被    初始化，应该是程序员提供；</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Inside_Cplusplus_对象</title>
      <link>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/</link>
      <guid>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Sat, 21 Jul 2018 11:23:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度探索c++对象模型第一章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;c-对象&quot;&gt;&lt;a href=&quot;#c-对象&quot; class=&quot;headerlink&quot; title=&quot;c++对象&quot;&gt;&lt;/a&gt;c++对象&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>深度探索c++对象模型第一章</p></blockquote><hr><h1 id="c-对象"><a href="#c-对象" class="headerlink" title="c++对象"></a>c++对象</h1><ul><li>成员函数：<ul><li>非内联： 只会诞生一个函数实体，不在object中</li><li>内联： 在每一个使用者上产生一个函数实体；</li></ul></li></ul><h1 id="1-c-对象模式"><a href="#1-c-对象模式" class="headerlink" title="1 c++对象模式"></a>1 c++对象模式</h1><p>data member:</p><ul><li>static</li><li>non-static</li></ul><p>成员函数：</p><ul><li>static</li><li>nonstatic</li><li>virtual</li></ul><h2 id="1-1-c-对象模型"><a href="#1-1-c-对象模型" class="headerlink" title="1.1 c++对象模型"></a>1.1 c++对象模型</h2><ul><li>指定多个access sections,内含数据：处于用一个access section的数据，必定保证其声明次序出现内存布局中；</li></ul><h3 id="1-1-1-成员数据"><a href="#1-1-1-成员数据" class="headerlink" title="1.1.1 成员数据"></a>1.1.1 成员数据</h3><ul><li>nonstatic 成员数据放在每一个class object中；</li><li>static成员数据 放在所有的class object之外；</li></ul><h3 id="1-1-2-成员函数"><a href="#1-1-2-成员函数" class="headerlink" title="1.1.2 成员函数"></a>1.1.2 成员函数</h3><ul><li>static和nonstatic 都放在class object之外；</li></ul><p>对于虚函数：</p><ul><li>1).每一个class产生一个virtual function 的指针，放在表格中，这个表格就是虚函数表（virtual table）<code>vbtl</code></li><li>2). 每一个class添加一个指针，指向虚函数表 : 指针为vptr(设定和重置通过构造函数和析构函数完成)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ca46784b6a7322d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个class 关联的type_info 对象放在虚函数表的第一个表格；</li></ul><h2 id="1-2-多重继承"><a href="#1-2-多重继承" class="headerlink" title="1.2 多重继承"></a>1.2 多重继承</h2><ul><li>继承：每一个子类中都包含一个基类实体；</li><li>虚拟继承： 永远只会存在一个实体；</li></ul><p>对于一个继承：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-c735d72fc5a53677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个派生类对象中都包含一个指向基类表的指针；</li><li>表中的每一个表格包含一个基类对象的指针；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1d9df8b6eea3a7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-对象的内存布局"><a href="#1-3-对象的内存布局" class="headerlink" title="1.3 对象的内存布局"></a>1.3 对象的内存布局</h2><ul><li>nonstatic data member</li><li>支持virtual而产生的负担</li><li>alignment的需求的填补（可能存在members之间，也可能存在边界）</li></ul><h1 id="2-对象的差异"><a href="#2-对象的差异" class="headerlink" title="2. 对象的差异"></a>2. 对象的差异</h1><h2 id="2-1-指针的转型"><a href="#2-1-指针的转型" class="headerlink" title="2.1 指针的转型"></a>2.1 指针的转型</h2><ul><li><p>对于一个指向某地址的void*指针，只能知道指向的地址，但是不知道通过它操作的object的类型；因此，无法通过void*指针操作object；</p></li><li><p>转型： 一种编译器指令；大部分情况并不改变指针的指向的真正地址，只是影响“被指出的内存的大小和其内容”的解释方式；</p></li></ul><h2 id="2-2-多态的指针"><a href="#2-2-多态的指针" class="headerlink" title="2.2 多态的指针"></a>2.2 多态的指针</h2><p>对于两个类：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-120c33e99dc35995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于以下对象b,指向Bear的指针 pb, rb，对象和指针的内存布局：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0ddd9d7314579a04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给予一个Bear指针和ZooAnimal指针：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3f88acefcf9e4a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bd565f0e895c2b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于对象中的虚函数：</p><ul><li>运行时决定；</li></ul><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发_原子操作</title>
      <link>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <guid>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sat, 21 Jul 2018 11:22:31 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发发_条件变量</title>
      <link>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <guid>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <pubDate>Sat, 21 Jul 2018 11:21:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c++ 标准库 (第二版)&lt;br&gt;c++并发编程(第三版)&lt;br&gt;cplusplus.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>c++ 标准库 (第二版)<br>c++并发编程(第三版)<br>cplusplus.com</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><ul><li>条件变量</li><li>头文件<code>&lt;condition_variable&gt;</code></li></ul><p>使用：</p><ul><li><code>&lt;mutex&gt;</code> 和 <code>&lt;condtion_variable&gt;</code></li><li>必须同时包含mutex和一个条件变量</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-98e976b39dbdc9a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>条件变量分为两种：</li><li>第一种仅限于和std::mutex一起工作（如果没有普遍性，首选第一种）</li><li>后者能够和类似互斥元的任何东西一起工作；</li></ul><h1 id="2、condition-variable"><a href="#2、condition-variable" class="headerlink" title="2、condition_variable"></a>2、condition_variable</h1><ul><li>条件变量需要使用<code>unique_lock</code>来锁住一个线程，当条件变量的wait操作的时候；</li><li>在wait操作的时候，不能使用<code>lock_guard</code>，因为wait()调用中，条件变量会对锁不停地加锁和解锁操作，<code>lock_guard</code>不能满足这样的操作；</li></ul><h2 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h2><pre><code>//default (1)    condition_variable();//copy [deleted] (2)    condition_variable (const condition_variable&amp;) = delete;</code></pre><ul><li>条件变量不能被拷贝或者move构造；</li></ul><h2 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2da74d06403c1937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例子：</p><pre><code>// condition_variable example#include &lt;iostream&gt;           // std::cout#include &lt;thread&gt;             // std::thread#include &lt;mutex&gt;              // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;bool ready = false;void print_id (int id) {  std::unique_lock&lt;std::mutex&gt; lck(mtx);  while (!ready) cv.wait(lck);  // ...  std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#39;\n&#39;;}void go() {  std::unique_lock&lt;std::mutex&gt; lck(mtx); // 这里可以使用lock_guard  ready = true;  cv.notify_all();}int main (){  std::thread threads[10];  // spawn 10 threads:  for (int i=0; i&lt;10; ++i)    threads[i] = std::thread(print_id,i);  std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;  go();                       // go!  for (auto&amp; th : threads) th.join();  return 0;}</code></pre><p>结果为：</p><pre><code>10 threads ready to race...thread 2thread 0thread 9thread 4thread 6thread 8thread 7thread 5thread 3thread 1</code></pre><p>其中，在print_id函数是的while循环，等价于：</p><pre><code>  while (!ready) cv.wait(lck);</code></pre><p>等价于：</p><pre><code>cv.wait(lck,[]-&gt;bool{return ready;}) </code></pre><p>当ready条件满足的时候，就返回;如果不满足，就将线程置于阻塞或等待要求；</p><h2 id="2-3-操作函数详解"><a href="#2-3-操作函数详解" class="headerlink" title="2.3 操作函数详解"></a>2.3 操作函数详解</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58370de18c92d484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-aa6192275617b65a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
