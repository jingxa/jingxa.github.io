<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sat, 21 Jul 2018 11:23:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Inside_Cplusplus_构造_default</title>
      <link>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/</link>
      <guid>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/</guid>
      <pubDate>Sat, 21 Jul 2018 11:23:57 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E6%9E%84%E9%80%A0-default/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Inside_Cplusplus_对象</title>
      <link>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/</link>
      <guid>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Sat, 21 Jul 2018 11:23:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度探索c++对象模型第一章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;c-对象&quot;&gt;&lt;a href=&quot;#c-对象&quot; class=&quot;headerlink&quot; title=&quot;c++对象&quot;&gt;&lt;/a&gt;c++对象&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>深度探索c++对象模型第一章</p></blockquote><hr><h1 id="c-对象"><a href="#c-对象" class="headerlink" title="c++对象"></a>c++对象</h1><ul><li>成员函数：<ul><li>非内联： 只会诞生一个函数实体，不在object中</li><li>内联： 在每一个使用者上产生一个函数实体；</li></ul></li></ul><h1 id="1-c-对象模式"><a href="#1-c-对象模式" class="headerlink" title="1 c++对象模式"></a>1 c++对象模式</h1><p>data member:</p><ul><li>static</li><li>non-static</li></ul><p>成员函数：</p><ul><li>static</li><li>nonstatic</li><li>virtual</li></ul><h2 id="1-1-c-对象模型"><a href="#1-1-c-对象模型" class="headerlink" title="1.1 c++对象模型"></a>1.1 c++对象模型</h2><ul><li>指定多个access sections,内含数据：处于用一个access section的数据，必定保证其声明次序出现内存布局中；</li></ul><h3 id="1-1-1-成员数据"><a href="#1-1-1-成员数据" class="headerlink" title="1.1.1 成员数据"></a>1.1.1 成员数据</h3><ul><li>nonstatic 成员数据放在每一个class object中；</li><li>static成员数据 放在所有的class object之外；</li></ul><h3 id="1-1-2-成员函数"><a href="#1-1-2-成员函数" class="headerlink" title="1.1.2 成员函数"></a>1.1.2 成员函数</h3><ul><li>static和nonstatic 都放在class object之外；</li></ul><p>对于虚函数：</p><ul><li>1).每一个class产生一个virtual function 的指针，放在表格中，这个表格就是虚函数表（virtual table）<code>vbtl</code></li><li>2). 每一个class添加一个指针，指向虚函数表 : 指针为vptr(设定和重置通过构造函数和析构函数完成)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ca46784b6a7322d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个class 关联的type_info 对象放在虚函数表的第一个表格；</li></ul><h2 id="1-2-多重继承"><a href="#1-2-多重继承" class="headerlink" title="1.2 多重继承"></a>1.2 多重继承</h2><ul><li>继承：每一个子类中都包含一个基类实体；</li><li>虚拟继承： 永远只会存在一个实体；</li></ul><p>对于一个继承：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-c735d72fc5a53677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个派生类对象中都包含一个指向基类表的指针；</li><li>表中的每一个表格包含一个基类对象的指针；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1d9df8b6eea3a7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-对象的内存布局"><a href="#1-3-对象的内存布局" class="headerlink" title="1.3 对象的内存布局"></a>1.3 对象的内存布局</h2><ul><li>nonstatic data member</li><li>支持virtual而产生的负担</li><li>alignment的需求的填补（可能存在members之间，也可能存在边界）</li></ul><h1 id="2-对象的差异"><a href="#2-对象的差异" class="headerlink" title="2. 对象的差异"></a>2. 对象的差异</h1><h2 id="2-1-指针的转型"><a href="#2-1-指针的转型" class="headerlink" title="2.1 指针的转型"></a>2.1 指针的转型</h2><ul><li><p>对于一个指向某地址的void*指针，只能知道指向的地址，但是不知道通过它操作的object的类型；因此，无法通过void*指针操作object；</p></li><li><p>转型： 一种编译器指令；大部分情况并不改变指针的指向的真正地址，只是影响“被指出的内存的大小和其内容”的解释方式；</p></li></ul><h2 id="2-2-多态的指针"><a href="#2-2-多态的指针" class="headerlink" title="2.2 多态的指针"></a>2.2 多态的指针</h2><p>对于两个类：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-120c33e99dc35995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于以下对象b,指向Bear的指针 pb, rb，对象和指针的内存布局：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0ddd9d7314579a04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给予一个Bear指针和ZooAnimal指针：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3f88acefcf9e4a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bd565f0e895c2b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于对象中的虚函数：</p><ul><li>运行时决定；</li></ul><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/Inside-Cplusplus-%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发_原子操作</title>
      <link>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <guid>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sat, 21 Jul 2018 11:22:31 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发发_条件变量</title>
      <link>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <guid>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <pubDate>Sat, 21 Jul 2018 11:21:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c++ 标准库 (第二版)&lt;br&gt;c++并发编程(第三版)&lt;br&gt;cplusplus.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>c++ 标准库 (第二版)<br>c++并发编程(第三版)<br>cplusplus.com</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><ul><li>条件变量</li><li>头文件<code>&lt;condition_variable&gt;</code></li></ul><p>使用：</p><ul><li><code>&lt;mutex&gt;</code> 和 <code>&lt;condtion_variable&gt;</code></li><li>必须同时包含mutex和一个条件变量</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-98e976b39dbdc9a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>条件变量分为两种：</li><li>第一种仅限于和std::mutex一起工作（如果没有普遍性，首选第一种）</li><li>后者能够和类似互斥元的任何东西一起工作；</li></ul><h1 id="2、condition-variable"><a href="#2、condition-variable" class="headerlink" title="2、condition_variable"></a>2、condition_variable</h1><ul><li>条件变量需要使用<code>unique_lock</code>来锁住一个线程，当条件变量的wait操作的时候；</li><li>在wait操作的时候，不能使用<code>lock_guard</code>，因为wait()调用中，条件变量会对锁不停地加锁和解锁操作，<code>lock_guard</code>不能满足这样的操作；</li></ul><h2 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h2><pre><code>//default (1)    condition_variable();//copy [deleted] (2)    condition_variable (const condition_variable&amp;) = delete;</code></pre><ul><li>条件变量不能被拷贝或者move构造；</li></ul><h2 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2da74d06403c1937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例子：</p><pre><code>// condition_variable example#include &lt;iostream&gt;           // std::cout#include &lt;thread&gt;             // std::thread#include &lt;mutex&gt;              // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;bool ready = false;void print_id (int id) {  std::unique_lock&lt;std::mutex&gt; lck(mtx);  while (!ready) cv.wait(lck);  // ...  std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#39;\n&#39;;}void go() {  std::unique_lock&lt;std::mutex&gt; lck(mtx); // 这里可以使用lock_guard  ready = true;  cv.notify_all();}int main (){  std::thread threads[10];  // spawn 10 threads:  for (int i=0; i&lt;10; ++i)    threads[i] = std::thread(print_id,i);  std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;  go();                       // go!  for (auto&amp; th : threads) th.join();  return 0;}</code></pre><p>结果为：</p><pre><code>10 threads ready to race...thread 2thread 0thread 9thread 4thread 6thread 8thread 7thread 5thread 3thread 1</code></pre><p>其中，在print_id函数是的while循环，等价于：</p><pre><code>  while (!ready) cv.wait(lck);</code></pre><p>等价于：</p><pre><code>cv.wait(lck,[]-&gt;bool{return ready;}) </code></pre><p>当ready条件满足的时候，就返回;如果不满足，就将线程置于阻塞或等待要求；</p><h2 id="2-3-操作函数详解"><a href="#2-3-操作函数详解" class="headerlink" title="2.3 操作函数详解"></a>2.3 操作函数详解</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58370de18c92d484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-aa6192275617b65a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/21/STL-%E5%B9%B6%E5%8F%91%E5%8F%91-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_并发_高级接口</title>
      <link>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/</link>
      <guid>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/</guid>
      <pubDate>Wed, 18 Jul 2018 08:16:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c++ 标准库 (第二版)&lt;br&gt;c++并发编程(第三版)&lt;br&gt;cplusplus.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一、-概述&quot;&gt;&lt;a href=&quot;#一、-概述&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<p>参考资料：</p><blockquote><p>c++ 标准库 (第二版)<br>c++并发编程(第三版)<br>cplusplus.com</p></blockquote><hr><h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><ul><li><code>Future</code>头文件中<br><img src="https://upload-images.jianshu.io/upload_images/5361608-57a769d1502dd91d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>其中class和Functions的providers</p><ul><li>promise</li><li>packaged_task </li><li>async</li></ul><p>都是providers,能够将共享状态（shard state）的接口分享给future对象；</p><p>例如：</p><ul><li><code>std::async()</code>: 让一个callable objects在后台运行，成为一个独立线程；</li><li><code>class std::future&lt;&gt;</code> ： 允许等待线程结束并且获取结果（一个返回值，或者一个异常）</li></ul><h1 id="二、-Providers"><a href="#二、-Providers" class="headerlink" title="二、 Providers"></a>二、 Providers</h1><h2 id="2-1-asnyc"><a href="#2-1-asnyc" class="headerlink" title="2.1 asnyc()"></a>2.1 asnyc()</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><p>提供了两个版本：</p><pre><code>// unspecified policy (1)    template &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (Fn&amp;&amp; fn, Args&amp;&amp;... args);// specific policy (2)    template &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</code></pre><ul><li>第一个版本执行callable对象 fn，无需等待fn完成就可以返回</li><li>返回值的访问通过future对象（future::get）</li></ul><p>第二个版本：</p><ul><li>调用callable对象的时候选择一种一种策略；</li></ul><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>launch::async</td><td>尝试启动fn并给予参数args,形成一个异步任务</td></tr><tr><td>launch::deferred</td><td>调用fn并且传递参数args，形成一个推迟任务，直到返回的future调用wait()或者get()时，任务才同步调用，否则绝不启动</td></tr><tr><td>launch::async \</td><td>launch::deferred</td><td>第一版本效果一样，即随机选择一个launch策略</td></tr></tbody></table><hr><h2 id="2-2-promise"><a href="#2-2-promise" class="headerlink" title="2.2 promise"></a>2.2 promise</h2><ul><li>1.promise对象能够关联到一个shared state上，其中shared state 能够存储一个返回值或者异常(std::exception);</li><li>2.future对象能够检索promise对象关联的shared state</li><li>3.future对象要关联到一个shared state上，需要promise调用成员函数<code>get_value</code>返回的值传递给future对象；</li></ul><p>这个时候，shared state关联到future对象和promise对象上：</p><ul><li>promise： 提供数据或来设置shared state</li><li>future : 取回shared state中的数据</li></ul><h3 id="2-2-1-模板参数"><a href="#2-2-1-模板参数" class="headerlink" title="2.2.1 模板参数"></a>2.2.1 模板参数</h3><pre><code>template &lt;class T&gt;  promise;template &lt;class R&amp;&gt; promise&lt;R&amp;&gt;;     // specialization : T is a reference type (R&amp;)template &lt;&gt;         promise&lt;void&gt;;   // specialization : T is void</code></pre><h3 id="2-2-2-构造函数"><a href="#2-2-2-构造函数" class="headerlink" title="2.2.2 构造函数"></a>2.2.2 构造函数</h3><pre><code>// default (1)    promise();// with allocator (2)    template &lt;class Alloc&gt; promise (allocator_arg_t aa, const Alloc&amp; alloc);// copy [deleted] (3)    promise (const promise&amp;) = delete;// move (4)    promise (promise&amp;&amp; x) noexcept;</code></pre><p>例子：</p><pre><code>// 默认  std::promise&lt;int&gt; foo;// 分配器构造  std::promise&lt;int&gt; bar = std::promise&lt;int&gt;(std::allocator_arg,std::allocator&lt;int&gt;());// 获取关联到shared state的future对象  std::future&lt;int&gt; fut = bar.get_future();</code></pre><h3 id="2-2-3-成员函数"><a href="#2-2-3-成员函数" class="headerlink" title="2.2.3 成员函数"></a>2.2.3 成员函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-fd3927866383ab95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>promise 对象通过</p><ul><li><code>set_value</code></li><li><code>set_exception</code><br>来向shared state中存储一个数据或者一个异常；</li></ul><pre><code>// promise example#include &lt;iostream&gt;       // std::cout#include &lt;functional&gt;     // std::ref#include &lt;thread&gt;         // std::thread#include &lt;future&gt;         // std::promise, std::futurevoid print_int (std::future&lt;int&gt;&amp; fut) {  int x = fut.get();  std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;}int main (){  std::promise&lt;int&gt; prom;                      // create promise  std::future&lt;int&gt; fut = prom.get_future();    // engagement with future  std::thread th1 (print_int, std::ref(fut));  // send future to new thread  prom.set_value (10);                         // fulfill promise                                               // (synchronizes with getting the future)  th1.join();  return 0;}</code></pre><ul><li>一旦shared state存有某值或者异常， 状态变为ready,于是可以通过future对象读取内容；</li></ul><p>以上两个函数执行后，并不意味着执行promise 的线程结束，该线程可能还在运行；如果想要在线程结束时才设置数据或者异常，可以执行以下函数：</p><ul><li><code>set_value_at_thread_exit()</code></li><li><code>set_exception_at_thread_exit()</code></li></ul><h3 id="2-2-4-操作函数-详解"><a href="#2-2-4-操作函数-详解" class="headerlink" title="2.2.4 操作函数 详解"></a>2.2.4 操作函数 详解</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-782ebdb006364b59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="2-3-packaged-task"><a href="#2-3-packaged-task" class="headerlink" title="2.3 packaged_task"></a>2.3 packaged_task</h2><ul><li>packaged_task 包装callable对象 ，并且允许这个callable结果异步访问；</li><li>类似std::function , 但是结果自动被转换为一个future对象；</li></ul><p>packaged_task 的组成：</p><ul><li>stored task: 一些callable对象（例如函数指针，成员函数指针或者函数对象）并且能够利用 传递的args参数；</li><li>shared state : 存储callable对象的结果，能够被future对象异步访问；</li></ul><p>shared state 能够通过packaged_task调用成员函数<code>get_future()</code>关联到一个future对象；</p><h3 id="2-3-1-函数模板"><a href="#2-3-1-函数模板" class="headerlink" title="2.3.1 函数模板"></a>2.3.1 函数模板</h3><pre><code>template &lt;class T&gt; packaged_task;     // undefinedtemplate &lt;class Ret, class... Args&gt; class packaged_task&lt;Ret(Args...)&gt;;</code></pre><p>模板参数为函数返回值类型和参数类型；</p><h3 id="2-3-2-构造函数"><a href="#2-3-2-构造函数" class="headerlink" title="2.3.2 构造函数"></a>2.3.2 构造函数</h3><pre><code>//default (1)    packaged_task() noexcept;//initialization (2)    template &lt;class Fn&gt;  explicit packaged_task (Fn&amp;&amp; fn);//with allocator (3)    template &lt;class Fn, class Alloc&gt;  explicit packaged_task (allocator_arg_t aa, const Alloc&amp; alloc, Fn&amp;&amp; fn);//copy [deleted] (4)    packaged_task (packaged_task&amp;) = delete;//move (5)    packaged_task (packaged_task&amp;&amp; x) noexcept;</code></pre><p>例如：</p><pre><code>  std::packaged_task&lt;int(int)&gt; foo;                          // default-constructed  std::packaged_task&lt;int(int)&gt; bar ([](int x){return x*2;}); // initialized</code></pre><p>模板为：<br>函数的返回值类型，参数类型</p><h3 id="2-3-3-成员函数"><a href="#2-3-3-成员函数" class="headerlink" title="2.3.3 成员函数"></a>2.3.3 成员函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-36044c6aed919a32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例子：</p><pre><code>// packaged_task::get_future#include &lt;iostream&gt;     // std::cout#include &lt;utility&gt;      // std::move#include &lt;future&gt;       // std::packaged_task, std::future#include &lt;thread&gt;       // std::thread// a simple task:int triple (int x) { return x*3; }int main (){  std::packaged_task&lt;int(int)&gt; tsk (triple); // package task  std::future&lt;int&gt; fut = tsk.get_future();   // get future  std::thread(std::move(tsk),33).detach();   // spawn thread and call task  // ...  int value = fut.get();                     // wait for the task to complete and get result  std::cout &lt;&lt; &quot;The triple of 33 is &quot; &lt;&lt; value &lt;&lt; &quot;.\n&quot;;  return 0;}</code></pre><h3 id="2-3-4-操作函数详解"><a href="#2-3-4-操作函数详解" class="headerlink" title="2.3.4 操作函数详解"></a>2.3.4 操作函数详解</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8eb6a975f60f365c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="三、-Future"><a href="#三、-Future" class="headerlink" title="三、 Future"></a>三、 Future</h1><h2 id="3-1-Future"><a href="#3-1-Future" class="headerlink" title="3.1 Future"></a>3.1 Future</h2><ul><li>future对象用来表示某一操作的输出(outcome)，可能是一个返回值，或者异常；</li><li><p>输出被保留在shared state中，可能是被<code>std::async()</code>,<code>std::packaged_task</code>, <code>promise</code>创建的；</p></li><li><p>结果只能被取出一次。future状态：</p><ul><li>有效(valid)： 结果未被取出</li><li>无效(invalid):结果被取出</li></ul></li></ul><h3 id="3-1-1-模板参数和构造函数"><a href="#3-1-1-模板参数和构造函数" class="headerlink" title="3.1.1 模板参数和构造函数"></a>3.1.1 模板参数和构造函数</h3><pre><code>template &lt;class T&gt;  future;template &lt;class R&amp;&gt; future&lt;R&amp;&gt;;     // specialization : T is a reference type (R&amp;)template &lt;&gt;         future&lt;void&gt;;   // specialization : T is void</code></pre><p>构造函数</p><pre><code>//default (1)    future() noexcept;//copy [deleted] (2)    future (const future&amp;) = delete;//move (3)    future (future&amp;&amp; x) noexcept;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-45c768b706a4fd5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>future没有复制构造函数和赋值操作符，确保不会有两个object 共享一个状态；</li></ul><h3 id="3-1-2-操作函数"><a href="#3-1-2-操作函数" class="headerlink" title="3.1.2 操作函数"></a>3.1.2 操作函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-80a06bc8d6f5770f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-2-Shared-Future"><a href="#3-2-Shared-Future" class="headerlink" title="3.2 Shared Future"></a>3.2 Shared Future</h2><ul><li><ol><li>shared_future  对象类似future对象，但是shared_future对象能够被复制，即能够和另一个shared_future对象共享同一个后台shared state的状态；</li></ol></li><li><ol start="2"><li>当 shared state的状态一旦ready后，能够被检索多次；</li></ol></li><li><ol start="3"><li>shared_future对象能够从future对象转化过来，也能从future::share()获得； 这两种方法，future对象被转化为shared_future对象后，fut ure对象会无效；</li></ol></li><li><ol start="4"><li>shared state的生命周期会持续到最后一个相关的shared_future对象释放；</li></ol></li><li>class shared_future&lt;&gt;的接口和class future&lt;&gt; 相同；</li></ul><h3 id="3-2-1-模板参数"><a href="#3-2-1-模板参数" class="headerlink" title="3.2.1 模板参数"></a>3.2.1 模板参数</h3><pre><code>template &lt;class T&gt;  shared_future;template &lt;class R&amp;&gt; shared_future&lt;R&amp;&gt;;   // specialization : T is a reference type (R&amp;)template &lt;&gt;         shared_future&lt;void&gt;; // specialization : T is void</code></pre><h3 id="3-2-2-构造函数"><a href="#3-2-2-构造函数" class="headerlink" title="3.2.2 构造函数"></a>3.2.2 构造函数</h3><pre><code>// default (1)    shared_future() noexcept;// copy (2)    shared_future (const shared_future&amp; x);// move (3)    shared_future (shared_future&amp;&amp; x) noexcept;// move from future (4)    shared_future (future&lt;T&gt;&amp;&amp; x) noexcept;</code></pre><ul><li>其中move constuctors 后构造一个新的对象，但是旧的对象x不能共享shared state;</li></ul><h3 id="3-2-3-成员函数"><a href="#3-2-3-成员函数" class="headerlink" title="3.2.3 成员函数"></a>3.2.3 成员函数</h3><ul><li>class shared_future&lt;&gt;的接口和class future&lt;&gt; 相同；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1e3de1ca5670b3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/18/STL-%E5%B9%B6%E5%8F%91-%E9%AB%98%E7%BA%A7%E6%8E%A5%E5%8F%A3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
