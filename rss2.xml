<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Wed, 20 Jun 2018 08:47:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>cs231a-homework-1</title>
      <link>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</link>
      <guid>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</guid>
      <pubDate>Tue, 19 Jun 2018 14:05:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;一、affine-camera-Calibration&quot;&gt;&lt;a href=&quot;#一、affine-camera-Calibration&quot; class=&quot;headerlink&quot; title=&quot;一、affine camera Calibration&quot;&gt;&lt;/a&gt;一、aff
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、affine-camera-Calibration"><a href="#一、affine-camera-Calibration" class="headerlink" title="一、affine camera Calibration"></a>一、affine camera Calibration</h1><h2 id="1-1-相机参数-计算"><a href="#1-1-相机参数-计算" class="headerlink" title="1.1 相机参数 计算"></a>1.1 相机参数 计算</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03fce6331a4ddc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ff53ebf6a86b559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>小块大小： 50 mm * 50 mm</li><li>小块间隔： 30mm</li><li>总大小： 450 mm * 450 mm</li></ul><hr><ul><li>计算思路：</li><li>查看ps1_code中的三个npy文件的shape</li><li>real_XY:(12,2)</li><li>front:(12,2)</li><li>back:(12,2)<br>说明选取了十二个点作为测量点，对于3D到2D的变换：</li><li><code>p&#39; = M P</code></li></ul><p>在相机校准中，相机的参数矩阵为：(3 * 4),一共有11个自由度；</p><ul><li>但是本题，是affine camera， 是弱透视投影，因此，参数为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-88c8a13eac856914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>只需要计算8个自由度；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8ec2e79577d7b2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>m3为[0 0 0 1]</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a91e9bee8aaa4231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>则m3Pi = 1</p></li><li><p>因此，可以建立上图中的P矩阵为：(2n * 8)的矩阵，n为参考点个数；</p></li><li><p>m 为： (8 * 1),省略m3,到时候添加上一行[0 0 0 1]就可以</p></li><li><p>因此线性方程变为： Pm=0 ==&gt;Am=b</p></li></ul><p>使用最小二乘，求解：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c782966f307b92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>####在我们的方程中：AM =b</p><ul><li>A： 2n * 8</li><li>m: 8 * 1</li><li>b = 2n * 1</li></ul><p><img src="https://latex.codecogs.com/gif.latex?minimize%20%5Cleft%20%5C%7C%20Am%20-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%2C" alt=""></p><p>对m求导，得到 </p><p><img src="https://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7C%20Am-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%3D%20A%5E%7B2%7Dm%5E%7B2%7D-2Amb%20&plus;%20b%5E%7B2%7D%20%5C%5C%20%3D%3E%202A%5E%7B2%7Dm%20-%202A%5E%7BT%7Db%20%3D0%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7B2%7D%29%5E%7B-1%7DA%5E%7BT%7Db%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7BT%7DA%29%5E%7B-1%7DA%5E%7BT%7Db" alt=""></p><p>因此，计算 affine camera的矩阵为：</p><pre><code class="python">def compute_camera_matrix(real_XY, front_image, back_image):    img_num1 = front_image.shape[0]     img_num2 = back_image.shape[0]    # 建立真实XYZ的齐次矩阵    ones = np.ones((img_num1, 1))    front_z = np.zeros((img_num1, 1))    front_scence = np.c_[real_XY, front_z, ones]  # 12 * 4    back_z =150 * np.ones((img_num2,1))    back_scence = np.c_[real_XY, back_z, ones]  # 12 * 4    # 合并两个真实场景    M_scene = np.r_[front_scence, back_scence]  # 24 * 4    # 系数矩阵 A  2n * 8    n = img_num1 + img_num2    A = np.zeros((2*n, 8))    for i in range(0, A.shape[0], 2):        idx = int(i/2)        A[i, :] = np.hstack((M_scene[idx, :], [0, 0, 0, 0]))        A[i+1, :] = np.hstack(([0, 0, 0, 0], M_scene[idx, :]))    # 图片对应点矩阵 2n * 1     # b = [U1,V1, U2,V2,..., Un,Vn]    b = front_image[0].T    for i in range(1, img_num1, 1):        b = np.hstack((b, front_image[i].T))    for j in range(img_num2):        b = np.hstack((b, back_image[j].T))    b = np.reshape(b, (2 * n, 1))    # 计算矩阵，添加最后一行    # p = np.linalg.lstsq(A, b, rcond=None)  # 直接计算 AM= b ==&gt; M = A^(-1)*b    # camera_matrix = p[0]    camera_matrix = np.linalg.inv(A.T.dot(A)).dot(A.T).dot(b)   # 使用最小二乘计算结果    camera_matrix = np.reshape(camera_matrix, (2, -1)) # m(8,1) ==&gt; m(2,4)    camera_matrix = np.vstack((camera_matrix, [0, 0, 0, 1])) # 添加最后一列 ==&gt; m（3,4）    return camera_matrix</code></pre><ul><li>其中，使用两中方法：</li><li>计算 m = A^(-1)*b</li><li>计算最小二乘法</li></ul><p>两个的结果为；</p><ul><li>方法一：<pre><code>[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02][ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01][ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</code></pre></li><li>方法二：</li></ul><pre><code>[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02] [ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01] [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</code></pre><ul><li>两者之间的差为：</li></ul><pre><code>[[ 3.55271368e-15  5.19723153e-15 -1.38777878e-17  0.00000000e+00] [ 2.20060081e-13 -1.89404048e-13  3.06282777e-14  2.84217094e-14] [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]]</code></pre><p>可以看出每一项的差很小,说明两种方法近似；</p><hr><h2 id="1-2-RMS-计算"><a href="#1-2-RMS-计算" class="headerlink" title="1.2 RMS 计算"></a>1.2 RMS 计算</h2><ul><li>RMS : </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-53ce720a360065b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code class="python">def rms_error(camera_matrix, real_XY, front_image, back_image):    img_num1 = front_image.shape[0]    img_num2 = back_image.shape[0]    ones = np.ones((img_num1,1))    # 建立图像XYZ的齐次矩阵    front_img = np.c_[front_image, ones]     # front_image : n * 3    back_img = np.c_[back_image, ones]   # back_image: n * 3    img = np.r_[front_img, back_img]    img = img.T  # img : 3 * 2n    # 建立真实XYZ的齐次矩阵    front_z = np.zeros((img_num1, 1))    front_scence = np.c_[real_XY, front_z, ones]  # n * 4    back_z =150 * np.ones((img_num2,1))    back_scence = np.c_[real_XY, back_z, ones]  # n * 4    # 合并两个真实场景    M_scene = np.r_[front_scence, back_scence]  # 2n * 4    M_scene = M_scene.T  # real : 4 * 2n    M_scene_trans = camera_matrix.dot(M_scene)  # 变换    diff_sqr = (M_scene_trans - img)**2 # 平方差    diff_sum = np.sum(np.sum(diff_sqr,axis=0))  # 平方差的和，先行相加，在列相加    diff_sum /= (img_num1 + img_num2)   # 求均值    rms_error = np.sqrt(diff_sum)    return rms_error</code></pre><h2 id="1-3-主函数"><a href="#1-3-主函数" class="headerlink" title="1.3 主函数"></a>1.3 主函数</h2><ul><li>python 3.6<br>这两个函数的主函数：</li></ul><pre><code class="python">import numpy as npif __name__ == &#39;__main__&#39;:    # Load the example coordinates setup.    real_XY = np.load(&#39;real_XY.npy&#39;)    front_image = np.load(&#39;front_image.npy&#39;)    back_image = np.load(&#39;back_image.npy&#39;)    camera_matrix = compute_camera_matrix(real_XY, front_image, back_image)    rmse = rms_error(camera_matrix, real_XY, front_image, back_image)    print (&quot;Camera Matrix:\n&quot;, camera_matrix)    print()    print (&quot;RMS Error: &quot;, rmse)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-18036e390c98df9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-4-使用两个位置平面的原因"><a href="#1-4-使用两个位置平面的原因" class="headerlink" title="1.4 使用两个位置平面的原因"></a>1.4 使用两个位置平面的原因</h2><ul><li>如果只使用一个平面：<ul><li>线性方程的系数矩阵： rank &lt; n; 非满秩矩阵，没有唯一解，</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7bbbfc7ee4db2e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个方阵是奇异矩阵，没有可逆矩阵；</p><ul><li>因此，需要至少两个平面；</li></ul><hr><h1 id="二、单视图几行"><a href="#二、单视图几行" class="headerlink" title="二、单视图几行"></a>二、单视图几行</h1><h2 id="2-1-灭点"><a href="#2-1-灭点" class="headerlink" title="2.1 灭点"></a>2.1 灭点</h2><ul><li>相机 no-skew ：没有偏斜</li><li><p>square pixels with   no distortion : 没有扭曲</p></li><li><p>在3d中平行的线投影到2D中，相交于一点—灭点；因此，通过两线相交求得灭点；</p></li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_VANISHING_POINTSArguments:    points - 四对点，前两对为一条直线，后两对为一条，两条线是平行的；Returns:    灭点&#39;&#39;&#39;def compute_vanishing_point(points):    # 获取四对点    x1 = points[0, 0]    y1 = points[0, 1]   # (x1,y1)    x2 = points[1, 0]    y2 = points[1, 1]   # (x2,y2)    x3 = points[2, 0]    y3 = points[2, 1]   # （x3,y3）    x4 = points[3, 0]    y4 = points[3, 1]   # (x4,y4)    # 计算两条直线的参数    a1 = (y2 - y1)/(x2 - x1)    b1 = y1 - a1 * x1    print(&quot;line1: &quot;, a1, b1)    a2 = (y4 - y3)/(x4 - x3)    b2 = y3 - a2 * x3    print(&quot;line2:&quot;, a2, b2)    # 计算交点    x = (b1 - b2)/(a2 - a1)    y = a1 * x + b1    vanish_point = np.array([x, y])    return vanish_point</code></pre><h2 id="2-2-计算相机内参矩阵K"><a href="#2-2-计算相机内参矩阵K" class="headerlink" title="2.2 计算相机内参矩阵K"></a>2.2 计算相机内参矩阵K</h2><ul><li>使用三对灭点计算内部参数</li><li>无穷线的投影变成了水平线：</li></ul><p>因此将一对3d平行线的无穷交点投影成一个灭点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设两对平行线的灭点为v1,v2, 两对平行线的方向分别为d1,d2，那么这每一对平行线的夹角为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3f0fee0cbccdce69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-344f019d6232aca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0888390d19d82e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于一个标准相机,可以将w简化为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2af4fad907d2ad90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0d9e8622d8de703b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>得4个未知参数，然而w是可以缩放的，因此w6最后缩放为1,只需要3个未知变量；</p></li><li><p>因此，只需要三对灭点就可以求得矩阵K;</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d37dfb8754ca5585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个式子可以求解一个未知解；</li></ul><p><img src="https://latex.codecogs.com/gif.latex?%5Bx_%7B1%7D%2Cy_%7B1%7D%2C1%5D*%5Cbegin%7Bbmatrix%7D%20%26w_%7B1%7D%20%260%20%26w_%7B4%7D%5C%5C%20%260%20%26w_%7B1%7D%20%26w_%7B5%7D%20%5C%5C%20%26w_%7B4%7D%20%26w_%7B5%7D%20%26w_%7B6%7D%20%5Cend%7Bbmatrix%7D*%5Bx_%7B2%7D%2Cy_%7B2%7D%2C1%5D%20%3D%200" alt=""></p><p>化简为：</p><p><img src="https://latex.codecogs.com/gif.latex?%28x_%7B1%7Dx_%7B2%7D&plus;y_%7B1%7Dy_%7B2%7D%29w_%7B1%7D%20&plus;%20%28x_%7B1%7D%20&plus;%20x_%7B2%7D%29w_%7B4%7D&plus;%28y_%7B1%7D%20&plus;%20y_%7B2%7D%29w_%7B5%7D&plus;w_%7B6%7D%3D0" alt=""></p><p>w6 最小化1；</p><ul><li><p>说明w是一个对称矩阵，并且是正定矩阵，那么可以在最后，使用Cholesky分解法进行分解；</p></li><li><h2 id="cholesky分解"><a href="#cholesky分解" class="headerlink" title="cholesky分解"></a><a href="https://blog.csdn.net/billbliss/article/details/78559387" target="_blank" rel="noopener">cholesky分解</a></h2></li></ul><p>因此，通过三对灭点构建3*4系数矩阵;<br>代码如下：</p><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_points - a list of vanishing pointsReturns:    K - the intrinsic camera matrix (3x3 matrix)&#39;&#39;&#39;def compute_K_from_vanishing_points(vanishing_points):    v1 = vanishing_points[0]    v2 = vanishing_points[1]    v3 = vanishing_points[2]    # 构建系数矩阵    A = np.zeros((3, 4))    A[0] = np.array([(v1[0]*v2[0] + v1[1]*v2[1]), (v1[0] + v2[0]), (v1[1] + v2[1]), 1])    A[1] = np.array([(v1[0]*v3[0] + v1[1]*v3[1]), (v1[0] + v3[0]), (v1[1] + v3[1]), 1])    A[2] = np.array([(v2[0]*v3[0] + v2[1]*v3[1]), (v2[0] + v3[0]), (v2[1] + v3[1]), 1])    # print(&quot;A:\n&quot;,A)    # SVD分解    U, s, vT = np.linalg.svd(A, full_matrices=True)    # print(&#39;SVD:\n&#39;,U,U.shape)    # print(&#39;s:\n&#39;,s, s.shape)    # print(&#39;v:\n&#39;,vT,vT.shape)    # print()    w = vT[-1, :]   # 取最后一行，最为最优解    print(&#39;w:\n&#39;,w, w.shape)    omega = np.array([  # 建立w矩阵        [w[0], 0, w[1]],        [0, w[0], w[2]],        [w[1], w[2], w[3]]    ], dtype=np.float64)    print()    # 使用cholesky 分解得到K    kT_inv = np.linalg.cholesky(omega)  # w = (k*k.T)^-1 ==&gt; 分解为 k.T^-1    k = np.linalg.inv(kT_inv.T)     k /= k[2, 2]    # 最小化    return k</code></pre><p>【注意】</p><ul><li>三对灭点： 需要正交</li><li>为了减小误差，可以使用超过两条以上的平行线计算灭点，然后计算这个坐标的平均值作为最终灭点；</li></ul><h2 id="2-3-计算两个平面的夹角"><a href="#2-3-计算两个平面的夹角" class="headerlink" title="2.3  计算两个平面的夹角"></a>2.3  计算两个平面的夹角</h2><ul><li>通过上面的公式，通过灭点计算灭线，然后计算角度；</li><li>【问题】<ul><li>不明白为什么通过求点的叉积来获得灭线向量，感觉没有意义啊？？</li></ul></li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_pair1 - a list of a pair of vanishing points computed from lines within the same plane    vanishing_pair2 - a list of another pair of vanishing points from a different plane than vanishing_pair1    K - the camera matrix used to take both imagesReturns:    angle - the angle in degrees between the planes which the vanishing point pair comes from2&#39;&#39;&#39;def compute_angle_between_planes(vanishing_pair1, vanishing_pair2, K):    omega_inv = K.dot(K.T)    # a set of vanishing points on one plane    v1 = np.hstack((vanishing_pair1[0], 1))    v2 = np.hstack((vanishing_pair1[1], 1))    # another set of vanishing points on the other plane    v3 = np.hstack((vanishing_pair2[0], 1))    v4 = np.hstack((vanishing_pair2[1], 1))    # find two vanishing lines    L1 = np.cross(v1.T, v2.T)  # 为什么如此？    L2 = np.cross(v3.T, v4.T)    # find the angle between planes    costheta = (L1.T.dot(omega_inv).dot(L2)) / (np.sqrt(L1.T.dot(omega_inv).dot(L1)) * np.sqrt(L2.T.dot(omega_inv).dot(L2)))    theta = (np.arccos(costheta) / math.pi) * 180    return theta</code></pre><h2 id="2-4-计算旋转矩阵"><a href="#2-4-计算旋转矩阵" class="headerlink" title="2.4 计算旋转矩阵"></a>2.4 计算旋转矩阵</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d09bf4c264e3b2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>假设相机只经过旋转，没有平移；</li><li>通过灭点求解的真实平行线的方向；</li><li>两幅图片的真实平行线是不变的，通过真实平行线的矩阵变换求得相机的旋转矩阵；</li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_points1 - a list of vanishing points in image 1    vanishing_points2 - a list of vanishing points in image 2    K - the camera matrix used to take both imagesReturns:    R - the rotation matrix between camera 1 and camera 2&#39;&#39;&#39;def compute_rotation_matrix_between_cameras(vanishing_points1, vanishing_points2, K):    ones = np.ones((vanishing_points1.shape[0], 1))    # 建立齐次矩阵    v1 = np.hstack((vanishing_points1, ones)).T    v2 = np.hstack((vanishing_points2, ones)).T    # 计算真实平行线的方向    # d = K^-1 * v    k_inv = np.linalg.inv(K)    D1 = k_inv.dot(v1) / np.linalg.norm(k_inv.dot(v1),axis=0)   # 按列计算norm范数    D2 = k_inv.dot(v2) / np.linalg.norm(k_inv.dot(v2),axis=0)    # d2 = R * d1, d2.T = d1.T * R.T    R = np.linalg.lstsq(D1.T, D2.T,rcond = None)[0].T    return R</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/19/cs231a-homework-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客搭建记录</title>
      <link>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</link>
      <guid>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 31 May 2017 10:37:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;简单记录一下利用hexo+github搭建博客的过程&lt;/p&gt;
&lt;h4 id=&quot;主要思路&quot;&gt;&lt;a href=&quot;#主要思路&quot; class=&quot;headerlink&quot; title=&quot;主要思路&quot;&gt;&lt;/a&gt;主要思路&lt;/h4&gt;&lt;p&gt;　　安装git和node的过程就不多提了，本次安装hex
        
      
      </description>
      
      <content:encoded><![CDATA[<p>简单记录一下利用hexo+github搭建博客的过程</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>　　安装git和node的过程就不多提了，本次安装hexo博客主要采用建立GitHub pages托管，建立两个分支，一个用于提交源文件，一个用于提交hexo静态文件，如果博客需要换电脑，直接git clone下来即可</p><blockquote><p>hexo分支：博客源文件内容<br>master分支:静态博客内容</p></blockquote><h4 id="一-建立远程库"><a href="#一-建立远程库" class="headerlink" title="一 建立远程库"></a>一 建立远程库</h4><p>　　注意事项：<br>　　　　１.建立两个分支master 和hexo<br>　　　　２.将hexo分支设为默认分支，这样方便提交源文件</p><h4 id="二、下载远程库"><a href="#二、下载远程库" class="headerlink" title="二、下载远程库"></a>二、下载远程库</h4><pre><code>git clone git@github.com:jingxa/jingxa.github.io.git</code></pre><p>改成你的名字</p><h6 id="【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"><a href="#【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交" class="headerlink" title="【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"></a>【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交</h6><h4 id="三、开始安装hexo"><a href="#三、开始安装hexo" class="headerlink" title="三、开始安装hexo"></a>三、开始安装hexo</h4><h5 id="1、安装hexo"><a href="#1、安装hexo" class="headerlink" title="1、安装hexo"></a>1、安装hexo</h5><pre><code> npm install -g hexo-cli</code></pre><h5 id="2、-初始化hexo"><a href="#2、-初始化hexo" class="headerlink" title="2、 初始化hexo"></a>2、 初始化hexo</h5><pre><code>hexo init</code></pre><h5 id="3、安装npm"><a href="#3、安装npm" class="headerlink" title="3、安装npm"></a>3、安装npm</h5><pre><code> npm install</code></pre><h5 id="4、-安装next主题-："><a href="#4、-安装next主题-：" class="headerlink" title="4、 安装next主题 ："></a>4、 安装next主题 ：</h5><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>【注意：在<em>.jithub.io和themes/next都有一个_config.yml的文件，为了区分。我们使用一下称呼】<br>–</em>github.io/_config.yml:站点配置文件<br>–themes/next/_config.yml:主题配置文件</p><h5 id="5-配置站点文件"><a href="#5-配置站点文件" class="headerlink" title="5.配置站点文件"></a>5.配置站点文件</h5><h6 id="【注意：每一项的填写，其-后面都要保留一个空格】"><a href="#【注意：每一项的填写，其-后面都要保留一个空格】" class="headerlink" title="【注意：每一项的填写，其:后面都要保留一个空格】"></a>【注意：每一项的填写，其:后面都要保留一个空格】</h6><p>(1).修改网站相关信息</p><pre><code>title: 你的题目subtitle: 小题目description: 描述author: 作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p>(2).配置统一资源定位符（个人域名）</p><pre><code>url: https://jingxa.github.io</code></pre><p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。<br>(3). 配置部署</p><pre><code>deploy:  type: git  repo: ssh://git@github.com/jingxa/jingxa.github.io.git  branch: master</code></pre><p>这里我们使用ssh，不使用https,可以避免提交的时候需要输入密码验证<br>(4).主题修改</p><pre><code>themes: next</code></pre><h5 id="6-配置主题文件"><a href="#6-配置主题文件" class="headerlink" title="6.配置主题文件"></a>6.配置主题文件</h5><p>这些大家自己百度<br><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a></p><h5 id="7-提交"><a href="#7-提交" class="headerlink" title="7.提交"></a>7.提交</h5><p>这一步大家讲源文件提交到github,托管源码，方便以后转移、<br>在提交之前，大家需要将【.gitignore】中添加一些配置，免得将一些不必要的东西提交到github上，我的配置如下：</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>将这个不必要的忽略掉<br>(1).增加文件 </p><pre><code>git add .</code></pre><p>提交所有的文件<br>(2).可以使用 </p><pre><code>git status</code></pre><p>检查提交哪些东西<br>(3).提交 </p><pre><code>git commit -m &quot;自己修改commit信息&quot;</code></pre><p>(4).重要的地方，我们需要将修改提交到hexo,分支</p><pre><code>git push origin hexo</code></pre><p>然后完成了源文件的提交，下一步就是提交hexo生成的静态文件，再次之前，需要安装依赖包</p><h5 id="8-安装npm-install-hexo-deployer-git-–save"><a href="#8-安装npm-install-hexo-deployer-git-–save" class="headerlink" title="8.安装npm install hexo-deployer-git –save"></a>8.安装npm install hexo-deployer-git –save</h5><pre><code>npm install hexo-deployer-git --save</code></pre><p>其实这一步可以在前面npm install 之后安装</p><h5 id="9-静态博客生成"><a href="#9-静态博客生成" class="headerlink" title="9.静态博客生成"></a>9.静态博客生成</h5><p>(1).我们可以写一篇文章</p><pre><code>hexo new &quot;你的题目&quot;</code></pre><p>我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。<br>保存后，我们进行本地发布：<br>(2).我自己测试，</p><pre><code>　hexo s -p 8888</code></pre><p>如果使用 </p><pre><code>hexo server</code></pre><p> 会使用默认端口4000，这个一直不能再本地显示，所以我们可以自己更改端口，就能正常访问<br>(3).打开浏览器，输入：</p><pre><code>http://localhost:8888/</code></pre><p>我们可以在浏览器端看到我们搭建好的博客和发布的文章：</p><h5 id="10-博客提交到github上"><a href="#10-博客提交到github上" class="headerlink" title="10.博客提交到github上"></a>10.博客提交到github上</h5><p>(1).这一步主要是清除缓存数据</p><pre><code>hexo clean</code></pre><p>(2). 生成</p><pre><code>//hexo generate可以简写成hexo g</code></pre><p>(3). 发布</p><pre><code>//hexo deploy可以简写成 hexo d</code></pre><p>然后访问你的默认网站。就可以看到你的成果了！</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
