<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sun, 08 Jul 2018 10:45:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>STL_关联式容器_hashtable</title>
      <link>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</link>
      <guid>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</guid>
      <pubDate>Sun, 08 Jul 2018 10:44:01 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>插入，删除，搜索都是常数时间</li><li>视为一种字典结构</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ab2c47b3a5e91bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>问题：</p><ol><li>array数组</li><li>索引<ul><li>索引碰撞</li></ul></li></ol><ul><li>负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；</li></ul><p>2 ：解决办法：</p><ul><li><p>线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-2b6d559944a935d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>二次探测：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f9011c6bd0983d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>开链</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-318b1549c961b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h1 id="2-桶（buckets）和节点-nodes"><a href="#2-桶（buckets）和节点-nodes" class="headerlink" title="2 桶（buckets）和节点(nodes)"></a>2 桶（buckets）和节点(nodes)</h1><ul><li>hash table的表格元素为桶子；(表示可能为单个元素，或者一个list)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-fd77a7af5f9a037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-hashtable-实现"><a href="#3-hashtable-实现" class="headerlink" title="3 hashtable 实现"></a>3 hashtable 实现</h1><h2 id="3-1-hash-table-节点"><a href="#3-1-hash-table-节点" class="headerlink" title="3.1 hash table 节点"></a>3.1 hash table 节点</h2><pre><code>/**    hash table 节点定义    bucket维护的linked list，不采用stl的list或slist，而是维护    上述的hash table node;    bucket聚合体，以vector完成；*/template&lt;class Value&gt;struct __hashtable_node{    __hashtable_node* next;    Value val;};</code></pre><h2 id="3-2-hashtable迭代器"><a href="#3-2-hashtable迭代器" class="headerlink" title="3.2 hashtable迭代器"></a>3.2 hashtable迭代器</h2><ul><li>hashtable的迭代器器没有后退操作，也没有双向迭代器</li></ul><pre><code>/**    hashtable 的迭代器    hashtable的迭代器器没有后退操作，也没有双向迭代器*/template&lt;class Value, class Key, class HashFcn,        class ExtratKey, class Equalkey, class Alloc&gt;struct __hashtable_iterator{    typedef hashtable&lt;Value, Key,HashFcn,ExtratKey,Equalkey,Alloc&gt;        hashtable;    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,                                    Equalkey,Alloc&gt;  iterator;    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,                                    Equalkey,Alloc&gt;  const_iterator;    typedef __hashtable_node&lt;Value&gt; node;    typedef forward_iterator_tag  iterator_category;    typedef    Value                   value_type;    typedef ptrdiff_t              difference_type;    typedef size_t                  size_type;    typedef Value&amp;                   reference;    typedef Value*                pointer;    node* cur;   // 迭代器当前指向节点    hashtable* ht; // 保持对容器的连接关系    __hashtable_iterator(node* n, hashtable* tab):cur(n),ht(tab){}    __hashtable_iterator(){}    reference operator*()const {return cur-&gt;val;}    pointer operator-&gt;() const {return &amp;(operator*());}    // hashtable的迭代器器没有后退操作，也没有双向迭代器    // 如果存在下一节点，直接next指针就可以；    // 如果节点为list的尾端，就跳到下一个bucket，即指向下一个list的头部节点；    iterator oprator++(){        const node* old = cur;        cur = cur-&gt;next; // 如果存在， 否则进入一下if        if(! cur){            // 根据元素值，定位下一个bucket，起始处就为答案            size_type bucket = ht-&gt;bkt_num(old-&gt;val);            while(!cur &amp;&amp; ++bucket &lt; ht-&gt;bucket.size()){                cur = ht-&gt;buckets[bucket];            }            return *this;        }    }    iterator operator++(int){        iterator tmp = *this;        ++*this;        return tmp;    }    bool operator== (const iterator&amp; it){return cur == it.cur;}    bool operator!= (const iterator&amp; it){return cur != it.cur;}};</code></pre><h2 id="3-3-hashtable数据结构"><a href="#3-3-hashtable数据结构" class="headerlink" title="3.3 hashtable数据结构"></a>3.3 hashtable数据结构</h2><h3 id="3-3-1-模板参数"><a href="#3-3-1-模板参数" class="headerlink" title="3.3.1 模板参数"></a>3.3.1 模板参数</h3><pre><code>    hashtable的数据结构    Value: 实值    Key: 键值    HashFcn: hash function类型    ExtratKey: 从节点中取出键值的方法    Equalkey : 判断键值相同与否的方法    Alloc: 空间配置；</code></pre><h3 id="3-3-2-表格大小设计"><a href="#3-3-2-表格大小设计" class="headerlink" title="3.3.2 表格大小设计"></a>3.3.2 表格大小设计</h3><ul><li>开链法 </li><li>SGI用质数来设计表格大小，先计算28 个质数的值存放起来方便直接访问；</li><li>提供了一个函数，用来查询“最近并大于某数”的质数</li></ul><pre><code>/**    开链法的表格大小预先设计    sgi stl 以质数来设计表格大小，现将28个质数计算好，用来被查询*/static const int __stl_num_primes = 28;static const unsigned long __stl_prime_list[__stl_num_primes] = {    53，97， 193， 389， 769，    ...    ...    ...  , 4294967291}// 一下用来找处28个质数中最近于n并大于n的质数inline unsigned long __stl_next_prime(unsigned long n){    const unsigned long* first = __stl_prime_list;    const unsigned long* last = __stl_prime_list + __stl_num_primes;    const unsigned long* pos = lower_bound(first,last,n); // 泛型算法，序列已排序    return pos == last ? *(last -1):*pos;}size_type max_bucket_count() const{    return __stl_prime_list[__stl_num_primes -1];    // 最大值为4294967291}</code></pre><h3 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3.3.3 数据结构"></a>3.3.3 数据结构</h3><pre><code>template&lt;class Value, class Key, class HashFcn,            class ExtratKey,class Equalkey, class Alloc = alloc&gt;class hashtable{public:    typedef        HashFcn        hasher;   // 型别参数重新定义一个名字    typedef        Equalkey    key_equal;        typedef        size_t        size_type;private:    // 以下三者都是函数对象 &lt;stl_hash_fun.h&gt;定义了数个    // 标准型（如int,c-style string等）的hasher;    hasher  hash;    key_equal equals;    ExtratKey  get_key;    typedef        __hashtable_node&lt;Value&gt; node;    typedef        simple_alloc&lt;node, Alloc&gt; node_allocator;    vector&lt;node*, Alloc&gt; buckets;  // vector完成    size_type    num_elements;public:    // bucket 个数 即 buckets vector的大小    size_type  bucket_count() const {return buckets.size();}...</code></pre><h3 id="3-3-4-构造函数"><a href="#3-3-4-构造函数" class="headerlink" title="3.3.4  构造函数"></a>3.3.4  构造函数</h3><ul><li>hashtable没有默认构造函数,其中一个构造函数为：</li></ul><pre><code>protected:    node* new_node(const value_type&amp; obj){        node* n = node_allocator::allocate();        n-&gt;next = 0;        __STL_TRY{            construct(&amp;n-&gt;val, obj);            return n;        }        __STL_UNWIND(node_allocator::deallocate(n));    }    void delete_node(node* n){        destroy(&amp;n-&gt;val);        node_allocator::deallocate(n);    }    // 初始构造 n个bunckets    void iniitalize_buckets(size_type n){        const size_type n_buckets = next_size(n);        buckets.reserve(n_buckets);        buckets.insert(buckets.end(),n_buckets,(node*)0);        num_elements = 0;    }    // 就会最接近于n并且大于n的质数    size_type next_size(size_type n) const {return __stl_next_prime(n);}public:    // hashtable没有默认构造函数    hashtable&lt;size_type n, const HashFcn&amp; hf, const Equalkey&amp; eql)        :hash(hf),equals(eql),get_key(ExtratKey()),num_elements(0){            iniitalize_buckets(n);        }</code></pre><h3 id="3-3-5-插入操作和表格重建"><a href="#3-3-5-插入操作和表格重建" class="headerlink" title="3.3.5  插入操作和表格重建"></a>3.3.5  插入操作和表格重建</h3><ul><li><p>当客户端插入元素的时候，会判断是否需要重建表格</p></li><li><p>resize() ：表格重建判断</p></li></ul><pre><code>// 函数判断是否需要重建表示，如果不要，立刻返回，如果需要，就动手    void resize(size_type num_elements_hint){        // 判断方法： 元素个数和bucker vector个数比较        // 如果前者大于后者，就重建        // 每个list的最大容量 和bucket vector大小相同        const size_type old_n = buckets.size();        if(num_elements_hint &gt; old_n){   // 需要重新配置            const size_type n = next_size(num_elements_hint);  // 新大小            if(n &gt; old_n){                vector&lt;node*, Alloc&gt;tmp(n, (node*)0);  // 设立新的buckets;                __STL_TRY{                    // 处理旧的bucket                    for(size_type bucket = 0; bucket &lt; old_n;++bucket){                        node* first = buckets[bucket];                        // 处理每个bucket的list                        while(first){                            // 寻找节点落在哪一个bucket                            size_type new_bucket =  bkt_num(first-&gt;val,n);                            // (1) 令旧的bucket 指向下一个节点                            buckets[bucket] = first-&gt;next;                            //(2)(3)将当前节点插入到新bucket中,前插法                            first-&gt;next = tmp[new_bucket];                            tmp[new_bucket] = first;                            //(4) 回到旧的bucket所指的list,准备处理下一个节点                            first = buckets[bucket];                        }                    }                    buckets.swap(tmp);  // vector::swap, 新旧两个bucket对换                    // 对换后，如果大小不一样，大的会变小，小的会变大                    // 离开后tmp释放                }            }        }    }</code></pre><ul><li><p>插入操作：分为两种，一种允许重复，一种不允许重复</p><ul><li><code>insert_unique_noresize</code> ：不允许重复</li><li><code>insert_equal_noresize</code> :允许节点重复</li></ul></li><li><p>第一种情况</p></li></ul><pre><code>    // 插入元素，不允许重复    pair&lt;iterator, bool&gt; insert_unique(const value_types obj){        resize(num_elements +1);  // 判断是否需要重建表格，如果需要就重新扩充        return insert_unique_noresize(obj);    }</code></pre><pre><code>    // 在不要建表格的情况下插入新节点，键值不允许重复    pair&lt;iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){        const size_type n = bkt_num(obj); // 决定obj的bucket位置        node* first = buckets[n];        // 如果buckets[n]已经被占用，此时first将不为0        // 迭代到list最尾节点        for(node* cur = first; cur; cur = cur-&gt;next){            // 如果发现存在相同键值，就返回，不插入            if(equals(get_key(cur-&gt;val), get_key(obj))                return pair&lt;iterator,bool&gt;(iterator(cur,this),false);        }        node* tmp = new_node(obj);  // 产生新节点        tmp-&gt;next = first;        buckets[n] = tmp ;   // 前插法        ++num_elements;        return pair&lt;iterator,bool&gt; (iterator(tmp,this),true);    }</code></pre><ul><li>第二种情况</li></ul><pre><code>    // 插入元素，允许重复    iterator insert_equal(const value_type&amp; obj){        resize(num_elements + 1);  // 判断是否重建表格        return insert_equal_noresize(obj);    }</code></pre><pre><code>    iterator insert_equal_noresize(const value_type&amp; obj){        const size_type n = bkt_num(obj);        node* first = buckets[n] ;         for(node* cur = first; cur; cur = cur-&gt;next){            if(equals(get_key(cur-&gt;val),get_key(obj)){                // list中存在相同键值的实值，就马上插入，在返回                node* tmp = new_node(obj);  // 新节点                tmp-&gt;next = cur-&gt;next;                cur-&gt;next = tmp;                ++num_elements;                return iterator(tmp, this);  // 返回            }        }        // 未发现重复值，到达链表尾端        node* tmp = new_node(obj);  // 新节点        tmp-&gt;next = first;        buckets[n] = tmp;        ++num_elements;        return iterator(tmp, this);  // 返回    }</code></pre><h3 id="3-3-6-复制和清除"><a href="#3-3-6-复制和清除" class="headerlink" title="3.3.6 复制和清除"></a>3.3.6 复制和清除</h3><ul><li>清除 <code>clear()</code></li></ul><pre><code>    void clear(){  // buckets空间为释放        // 对每一个bucket        for(size_type i=0; i&lt;buckets.size(); ++i){            node* cur = bucket[i];            // 将list每一个节点删除            while(cur != 0){                node* next = cur-&gt;next;                delete_node(cur);                cur = next;            }            bucket[i] = 0;  // bucket为NULL        }        num_elements = 0;  // 总数为0    }</code></pre><ul><li>复制</li></ul><pre><code>    void copy_from(const hashtable&amp; ht){        // 先清除自己的buckets vector,调用vector::clear()        buckets.clear();        // 如果自己的空间大于对方，就不动，小于的话，增大        buckets.reserve(ht.buckets.size());        // 此时buckets为空，end()就是起头        buckets.insert(buckets.end(),ht.buckets.size(), (node*)0);        __STL_TRY{            // 每个bucket            for(size_type i=0 ;i&lt;ht.buckets.size(); ++i){                // 每个bucket 开头                if(const node* cur = ht.bucket[i]) {                    node* cp = new_node(cur-&gt;val);                    buckets[i] = cp;                    // 每个bucket的list                    for(node* next = cur-&gt;next; next; cur =next, next = cur-&gt;next){                        cop -&gt;next = new_node(next-&gt;val);                        cp = cp-&gt;next;                    }                }                }            num_elements = ht.num_elements;        }        __STL_UNWIND(clear());    }</code></pre><h3 id="3-3-7-判断元素落脚"><a href="#3-3-7-判断元素落脚" class="headerlink" title="3.3.7 判断元素落脚"></a>3.3.7 判断元素落脚</h3><pre><code>public:    // 计算 元素的键值,即hashtable上的bucket序号    // 版本1： 接受实值和buckets个数    size_type bkt_num(const value_type&amp; obj, size_t n) const{        return bkt_num_key(get_key(obj),n);  // 版本4    }    // 版本2： 只接受实值value    size_type bkt_num(const value_type&amp; obj) const{        return bkt_num_key(get_key(obj));   // 版本3    }    // 版本3： 只接受键值    size_type bkt_num(const key_type&amp; key) const{        return bkt_num_key(key,buckets.size());   // 版本4    }    // 版本4： 只接受键值和buckets个数    size_type bkt_num(const key_type&amp; key，size_t n) const{        return hash(key) % n; // SGI内建 hash()    }</code></pre><h1 id="4-hashtable的hash-function"><a href="#4-hashtable的hash-function" class="headerlink" title="4. hashtable的hash function"></a>4. hashtable的hash function</h1><ul><li>SGI的内置hash函数只针对了char,int,long等整数型别，而且都只是返回原值</li><li>只对<code>const char*</code>做了一个转换</li><li>因此无法处理string,double ,float等型别，</li><li>用户必须自定义hash function</li></ul><pre><code>/** hash function类型 &lt;stl_hash_fun.h&gt;*/template&lt;class Key&gt;struct hash{};inline size_t __stl_hash_string(const char* s){    unsigned long  h =0;    for(;*s;++s)        h = 5*h + *s;    return size_t(h);}// __STL_TAMPLATE_NULL 定义为template&lt;&gt; 在;&lt;stl_config.h&gt;中__STL_TAMPLATE_NULLstruct hash&lt;char*&gt;{    size_t operator()(char* s){        return __stl_hash_string(s);    }}__STL_TAMPLATE_NULLstruct hash&lt;const char*&gt;{    size_t operator()(const char* s){        return __stl_hash_string(s);    }}__STL_TAMPLATE_NULLstruct hash&lt;char&gt;{    size_t operator()(char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned char&gt;{    size_t operator()(unsigned char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;signed char&gt;{    size_t operator()(unsigned char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;short&gt;{    size_t operator()(short s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned short&gt;{    size_t operator()(unsigned short s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;int&gt;{    size_t operator()(int s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned int&gt;{    size_t operator()( unsigned int s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;long&gt;{    size_t operator()(long s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned long&gt;{    size_t operator()( unsigned long s){        return s;    }}</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_map</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:35 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>map的元素都是pair</li><li>map 不允许两个元素拥有相同的键值；</li></ul><h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h1><pre><code>template&lt; class T1, class T2&gt;struct pair{    typedef T1 first_type;    typedef T2 seconde_type;    T1 first;    T2 second;    pair():first(T1()),second(T2()){}    pair(const T1&amp; a, const T2&amp; b):first(a), second(b){}};template&lt;class Key, class T,        class Compare = less&lt;Key&gt;,        class Alloc = alloc&gt;class map{public:    typedef    Key key_type;      typedef    T data_type;    typedef T mapped_type;    typedef pair&lt;const Key, T&gt; value_type;  // 元素型别    typedef    Compare key_compare;    // 比较函数    class value_compare: binary_function&lt;value_type, value_type,bool&gt;{        friend class  map&lt;Key,T, Compare, Alloc&gt;;        protected:            Compare comp;            value_compare(Compare c):comp(c){}        public:            bool operator()(const value_type&amp; x, const value_type&amp; y) const{                return comp(x.first, y.first);            }    };private:    rep_type t;public:    typedef     typename  rep_type::pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // 构造函数    map():t(Compare()){}    explicit map(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_unique(first,last);    }    map(const map&lt;Key,T, Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    map&lt;Key,T, Compare,Alloc&gt;&amp; operator=(const map&lt;Key,T,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // 访问器    key_compare key_comp() const(return t.key_comp(););    value_compare value_comp() const{return value_compare(t.key_comp());}    iterator begin() {return t.begin();}    const_iterator begin()const{return t.begin();}    iterator end() {return t.begin();}    const_iterator end() const{return t.end();}    reverse_iterator rbegin() {return t.rbegin();}    const_reverse_iterator rbegin() const {return t.rbegin();}    reverse_iterator rend() {return t.rend();}    const_reverse_iterator rend() const{return t.rend();}    bool empty() const {return t.empty();}    size_type size() const{return t.size();}    size_type max_size() const{return t.max_size();}    T&amp; operator[](const key_type&amp; k){        return(*((insert(value_type(k,T()))).first)).second;    }    void swap(map&lt;Key,T,Compare,Alloc&gt;&amp; x){t.swap(x.t);}    // 插入。删除    // 插入、 删除操作    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        return t.insert_unique(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_unique(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        t.erase(position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    iterator find(const key_type&amp; x) {return t.find(x);}        const_iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x){        return t.equal_range(x);    }    pair&lt;const_iterator,const_iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const map&amp;, const map&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt map&amp;, const map&amp;);};template&lt;class Key, class T, class Compare, class Alloc&gt;inline bool operator==(const map&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T, Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key,class T, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="3-multimap"><a href="#3-multimap" class="headerlink" title="3 multimap"></a>3 multimap</h1><pre><code>/**    multimap*/template&lt;class Key,class T,class Compare= less&lt;Key&gt;            class Alloc = alloc&gt;class multimap{public:    // typedefs     ...  // 和set一样    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_equal(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_equal(first,last);    }    ...// 和set一样    // insert    insert insert(const value_type&amp; x){        return t.insert_equal(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_equal(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_equal(first, last);    }    ... // 其他和map一样};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_set</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:21 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>set 所有元素根据元素的键值自动被排序</li><li>set的键值和实值都是同样的；</li><li>不允许两个元素有相同的键值；</li><li>set<t>::iterator为const_iterator</t></li><li>Rb_tree作为底层；</li></ul><h1 id="1-set"><a href="#1-set" class="headerlink" title="1. set"></a>1. set</h1><pre><code>/**    set源码摘录*/template&lt;class Key,         class Compare = less &lt;Key&gt;,   // 缺省下采用递增排序        class Alloc = alloc&gt;class set{public:    typedef Key    key_type;    typedef    Key    value_type;    typedef Compare    key_compare;    typedef    Compare    value_compare;private:// 以下 identity 定义于&lt;stl_function.h&gt;    /*    template&lt; class T&gt;    struct identity:public unary_function&lt;T, T&gt;{        const T&amp; operator()(const T&amp; x){return x;}    };    */    typedef    rb_tree&lt;key_type, value_type,identity&lt;value_type&gt;,key_compare,Alloc&gt; rep_type;    rep_type t;  // 采用红黑树表示setpublic:    typedef     typename  rep_type::const_pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::const_reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::const_iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::const_reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // aollocattion // deallocation    // set 使用rb_tree 的insert_unique()    // multiset 使用 rb_tree的insert_equal()    set():t(Compare()){}    explicit set(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last):t(Compare())    {        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last, const Compare&amp; comp)        :t(comp){            t.insert_unique(first,last);        }    set(const set&lt;Key,Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    set&lt;Key, Compare,Alloc&gt;&amp; operator=(const set&lt;Key,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // set 操作    key_compare key_comp() const{return t.key_comp();}    value_compare value_comp() const{{return t.key_comp();}    iterator begin() const{return t.begin();}    iterator end()    const{return t.end();}    reverse_iterator rbegin() const{retur t.rbegin();}    reverse_iterator rend() const{return t.rend();}    bool empty() const{return t.empty();}    size_type size() const {return t.size();}    size_type max_size() const{return t.max_size();}    void swap(set&lt;Key,Compare,Alloc&gt;&amp;x){t.swap(x.t);}    // 插入、 删除操作    typedef pair&lt;iterator,bool&gt; pair_iterator_bool;    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        pair&lt;typename rep_type::iterator,bool&gt; p = t.insert_unique(x);        return pair&lt;iterator,bool&gt;(p.first,p.last);    }    iterator insert(iterator position, const value_type&amp; x){        typedef typename rep_type::iterator rep_iterator;        return t.insert_unique((rep_iterator&amp;)position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    // set 操作    iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const set&amp;, const set&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt set&amp;, const set&amp;);};template&lt;class Key, class Compare, class Alloc&gt;inline bool operator==(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="2-multiset"><a href="#2-multiset" class="headerlink" title="2 multiset"></a>2 multiset</h1><p><code>`</code><br>/*<em><br>    multiset</em>/</p><p>// set 不同之处<br>template&lt;class Key, class Compare = less<key>, class Alloc= alloc&gt;<br>class multiset{</key></p><p>public:<br>// typedefs<br>… // 一样和set</p><p>//构造函数</p><pre><code>template&lt;class InputIterator&gt;multiset(InputIterator first,InputIterator last):t(Compare()){    t.insert_equal(first,last);}template&lt;class InputIterator&gt;multiset(InputIterator first, InputIterator last, Compare&amp; comp):t(comp){    t.insert_equal(first,last);}...   // 与 set一样// 插入删除iterator insert(const value_type&amp; x){    return t.insert_equal(x);}iterator insert(iterator position, const value_type&amp; x){    typedef typename rep_type::iterator rep_iterator;    return t.insert_equal((rep_iterator&amp;)position,x);}template&lt;class InputIterator&gt;void insert(InputIterator first, InputIterator last){    t.insert_equal(first,last);}... // 其他和set一样</code></pre><p>};</p><p>···</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_非标准_slist</title>
      <link>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:42 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;STL list是一个双向链表&lt;/li&gt;
&lt;li&gt;slist不在STL标准中，是一个单向链表；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;差别：&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>STL list是一个双向链表</li><li>slist不在STL标准中，是一个单向链表；</li></ul><p>差别：</p><ul><li>slist 的迭代器是单向的ForwardIterator</li><li>list的迭代器是 双向的BidrectionalIterator</li></ul><p>共同特点：</p><ul><li>插入，移除，接合不会造成原有迭代器失效</li></ul><h1 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c69d236d1d012e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>// 节点struct __slist_node_base{    __slist_node_base* next;};// 节点结构template&lt;class T&gt;struct __slist_node : public __slist_node_base{    T data;};// 全局函数// 已知道某一节点， 插入新节点于其后inline __slist_node_base* __slist_make_link(            __slist_node_base* prev_node,                __slist_node_base* new_node){    // 令new节点的下一个节点为prev节点的下一个节点    new_node-&gt;next = prev_node-&gt;next;    prev_node-&gt;next = new_node;  // prev指向new节点    return new_node;}// 全局函数 单向链表的大小inline size_t __slist_size(__slist_node_base* node){    size_t result = 0;    for(;node !=0; node = node-&gt;next)        ++result;    return result;}</code></pre><h1 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2d9e4831ec4892b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>/**    slist的迭代器*/struct __slist_iterator_base{    typedef size_t size_type;    typedef    ptrdiff_t difference_type;    typedef forward_iterator_tag  iterator_category;  // 单向链表的大小    __slist_node_base* node;  // 指向节点基本结构    __slist_node_base(__slist_node_base* x):node(x){}    void incr(){        node = node -&gt;next;  // 前进一个节点    }    bool operator== (const __slist_iterator_base&amp; x) const{        return node == x.node;    }    bool operator!= (const __slist_iterator_base&amp; x) const{        return node != x.node;    }};// 单向链表的迭代器结构template&lt;class T, class Ref , class Ptr&gt;struct _slist_iterator: public __slist_iterator_base{    typedef __slist_iterator&lt;T,T&amp;,T*&gt;                 iterator;    typedef __slist_iterator&lt;T,const T&amp;, const T*&gt;   const_iterator;    typedef __slist_iterator&lt;T,Ref,Ptr&gt;                self;    typedef T                                        value_type;    typedef Ptr                                        pointer;    typedef    Ref                                        reference;    typedef    __slist_node&lt;T&gt;                         list_node;    __slist_iterator(list_node&amp; x):__slist_iterator_base(x){}    // 调用slist&lt;T&gt;::end()会造成 __slist_iterator_base(0)    __slist_iterator():__slist_iterator_base(0){}    __slist_iterator(const iterator&amp; x):__slist_iterator_base(x.node){}    reference operator*()const{ return ((list_node*)node)-&gt;data;}    pointer  operator-&gt;() const{ return &amp;((operator*());}    self&amp; operator++(){        incr();        return *this;    }    self operator++(int){        self tmp = *this;        incr();        return tmp;    }    // 没有实现operator-- ,因为这是一个forward iterator};</code></pre><h1 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h1><pre><code>/**    slist 数据结构*/template&lt;class T, class Alloc = alloc&gt;class slist{public:    typedef T                            value_type;    typedef value_type*                    pointer;    typedef    const value_type*            const_pointer;    typedef    value_type&amp;                 reference;    typedef    const value_type&amp;            const_reference;    typedef size_t                        size_type;    typedef    ptrdiff_t                    difference_type;    typedef    __slist_iterator&lt;T,T&amp;,T*&gt;    iterator;    typedef    __slist_iterator&lt;T,const T&amp;, const T*&gt;    const_iterator;private:    typedef    __slist_node&lt;T&gt;        list_node;    typedef    __slist_node_base   list_node_base;    typedef    __slist_iterator_base    iterator_base;    typedef    simple_alloc&lt;list_node, Alloc&gt;  list_node_allocator;    static list_node* create_node(const value_type&amp; x){        list_node* node = list_node_allocator::allocate(); // 配置一个节点        __STL_TRY{            construct(&amp;node-&gt;data,x);            node-&gt;next = 0;        }        __STL_UNWIND(list_node_allocator::deallocate(node)):        return node;    }    static void destroy_node(list_node* node){        destroy(&amp;node-&gt;data);   // 析构元素        list_node_allocator::deallocate(node);  // 释放空间    }private:    list_node_base     head;   // 头部，不是指针，是对象public:    slist(){head.next =0;}    ~slist(){clear();}public:    // 基本操作    iterator begin(){return iterator((list_node*)head.next);}    iterator end() {return iterator(0);}    size_type size()const{return __slist_size(head.next);}    bool empty() const {return head.next == 0;}    // 两个slist互换    void swap(slist&amp; L){        list_node_base * tmp = head.next;        head.next = L.head.next;        L.head.next = tmp;    }public:    // 取头部元素    reference front(){return ((list_node*)head.next)-&gt;data;}    // 从头部插入元素    void push_front(const value_type&amp; x){        __slist_make_link(&amp;head, create_node(x));    }    // 从头部取走元素；    void pop_front(){        list_node* node = (list_node*) head.next;        head.next = node-&gt;next;        destroy_node(node);    }    ...};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_heap</title>
      <link>https://jingxa.github.io/2018/07/05/STL-heap/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-heap/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:16 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；</li></ul><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-binary-heap"><a href="#1-1-binary-heap" class="headerlink" title="1.1 binary heap"></a>1.1 binary heap</h2><ul><li>一种 complete binary tree (完全二叉树)的存储方式</li><li>使用vector作为存储空间</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-00622adba11ef4f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-heap的隐式表述法-implicit-representation"><a href="#1-2-heap的隐式表述法-implicit-representation" class="headerlink" title="1.2 heap的隐式表述法(implicit representation)"></a>1.2 heap的隐式表述法(implicit representation)</h2><ul><li>将数组的#0元素保留</li><li>那么在数组中，位于数组i处的节点的左子节点为2i，右子节点为(2*i +1)<br>-【SGI STL 并未使用这个方法】</li></ul><h2 id="1-3-max-heap"><a href="#1-3-max-heap" class="headerlink" title="1.3 max-heap"></a>1.3 max-heap</h2><ul><li>STL实现的是大根堆</li></ul><h1 id="2-heap算法"><a href="#2-heap算法" class="headerlink" title="2 heap算法"></a>2 heap算法</h1><h2 id="2-1-push-heap-算法"><a href="#2-1-push-heap-算法" class="headerlink" title="2.1 push_heap 算法"></a>2.1 push_heap 算法</h2><ul><li>新加入的元素位于最下一层作为叶节点，也就是插入到vector的end()处；</li><li>通过和父节点进行比较，如果值比父节点大，就父子对换位置，一直上溯，直到不需要对换或者到根节点为止；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58668b0e78d9e076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>push_heap</li></ul><pre><code>// push_heaptemplate&lt;class RandomAccessIterator&gt;inline void push_heap(RandomAccessIterator first, RandomAccessIterator last){    // 此函数调用的时候 新元素已经置于容器底部    __push_heap_aux(first,last,distance_type(first),value_type(first));}</code></pre><ul><li>使用<strong>push_heap_aux 和 </strong>push_heap作为内部函数；</li></ul><pre><code>template&lt;class RandomAccessIterator, class Distance, class T&gt;inline void __push_heap_aux(RandomAccessIterator first,                RandomAccessIterator last, Distance*, T*){    // 新值在容器最尾端，位置： （last -first）-1    // 隐式表述法 ,根节点编号从0开始    __push_heap(first, Distance(last - first)-1, Distance(0), T(*(last -1)));}// 一下这组push_back()不允许指定&#39;大小比较标准&#39;template&lt;class RandomAccessIterator, class Distance, class T&gt;void __push_heap(RandomAccessIterator first, Distance holeIndex,             Distance topIndex, T value){    Distance parent = (holeIndex -1) /2; // 找出父节点    while(holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value){  // 大根堆调整        // 尚未到达顶端并且父节点小于新值        *(first + holeIndex) = *(first + parent); // 令洞位置为父节点        holeIndex = parent; // 调整洞号， 向上提升        parent = (holeIndex - 1) /2;   // 新父节点        }   // 调整完成    *(first + holeIndex) = value;  // 赋值}</code></pre><h2 id="2-2-pop-heap算法"><a href="#2-2-pop-heap算法" class="headerlink" title="2.2 pop_heap算法"></a>2.2 pop_heap算法</h2><ul><li>先将根节点和最下一层的最右边的叶节点对换位置；然后调整除了最后一个节点的vector的first,last-1]的堆；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f729a93c0e6b8d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>pop_heap</li></ul><pre><code>/**    pop_heap    1. 取走根节点    2. 满足完全二叉树的条件，将最下一层的最右边的叶节点拿掉*/template&lt;class RandomAccessIterator&gt;inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last){    __pop_heap_aux(first, last, value_type(first));}</code></pre><ul><li>使用了__pop_heap_aux作为内部函数：</li></ul><pre><code>// 根据隐式表述法， pop操作的结果为底部容器的第一个元素// 首先将首值和尾节点互换，然后重新调整[first, last -1)template&lt;class RandomAccessIterator , class T&gt;inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last,                            T*){    __pop_heap(first,last-1, last-1, T(*(last - 1), distance_type(first));                            }template&lt;class RandomAccessIterator, class T, class Distance&gt;inline void __pop_heap(RandomAccessIterator first,                         RandomAccessIterator last,                        RandomAccessIterator result,                         T value, Distance*){    *result = * first;   // 设定尾值为首值                          //然后后面可以由容器pop_back()取出    // 重新调整heap    __adjust_heap(first,Distance(0), Distance(last -first), value);}</code></pre><ul><li>heap的调整算法：<code>__adjust_heap</code><br><code>`</code></li></ul><p>template<class randomaccessiterator,="" class="" distance,="" t=""><br>void __adjust_heap(RandomAccessIterator first, Distance holeIndex,<br>                    Distance len, T value){</class></p><pre><code>Distance topIndex = holeIndex; Distance secondChild = 2*holeIndex +2;  // 洞节点的右子节点while(secondChild &lt; len){    // 比较洞节点的两个子节点， 然后secondChild代替较大子节点    if(*(first + secondChild) &lt; *(first(secondChild -1))){        secondChild --;    }    *(first + holeIndex ) = *(first + secondChild);  // 替换父节点和子节点    holeIndex = secondChild;    secondChild = 2*(secondChild +1);  // 下一层}if(secondChild == len){  // 没有右子节点 ，只有左节点    // 令左子值为洞值，在令洞号移动左子节点处    *(first + holeIndex ) = *(first +(secondChild -1));    holeIndex = secondChild -1;}// 将要调整的洞号填入目前的洞号，// 此时已经满足次序性// 可直接为*（first + holeIndex) = value;__push_heap(first, holeIndex, topIndex,value);</code></pre><p>}</p><pre><code>## 2.3 sort_heap 算法- pop_heap每次将最大元素放到尾端，那么通过持续调用pop_heap算法就可以得到逆序序列；</code></pre><p>/**<br>    sort_heap</p><pre><code>1. pop_heap 每次取出一个最大值，持续pop，可得逆序序列；</code></pre><p>*/</p><p>template<class randomaccessiterator=""><br>void sort_heap(RandomAccessIterator first,<br>                RandomAccessIterator last){<br>    // 没执行一次pop_heap(),极值放在尾端<br>    while(last - first &gt;1){<br>        pop_heap(first,last–); // 执行一次，操作范围缩小一点<br>    }<br>}</class></p><pre><code>## 2.4 make_heap算法- 将一段现有数据转化一个heap</code></pre><p>/*<em><br>    make_heap: 将一段数据转化为堆</em>/<br>template<clss randomaccessiterator=""><br>inline void make_heap(RandomAccessIterator first, RandomAccessIterator last){<br>    __make_heap(first,last, value_type(first),distance_type(first));<br>}</clss></p><p>template<class randomaccessiterator,="" class="" t,="" distance=""><br>void __make_heap(RandomAccessIterator first,<br>                RandomAccessIterator    last, T<em>, Distance</em>)<br>{<br>    if(last - first &lt; 2) return ; // 长度0或1 不用重新排列<br>    Distance len = last - first;</class></p><pre><code>// 找出第一个需要重新排列的子树头部，以parent标出，Distance parent = (len -2 ) /2;while(true){    // 重新排列parent为首的子树，len为了让__adjust_heap()判断操作范围    __adjust_heap(first,parent,len,T(*(first+parent)));    if(parent == 0) return ; // 走完根节点就结束；    parent --; // 重排子树的头部向前一个节点；}</code></pre><p>}<br><code>`</code></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-heap/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
