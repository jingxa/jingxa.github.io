<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Wed, 11 Jul 2018 12:53:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>STL_配接器器_1</title>
      <link>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8%E5%99%A8-1/</link>
      <guid>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8%E5%99%A8-1/</guid>
      <pubDate>Wed, 11 Jul 2018 12:48:33 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第八章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;ad
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第八章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>adapter:</p><ul><li>讲一个class的接口转换为另一个class的接口，使原本不兼容而不能合作的classes，可以一起运作；</li></ul><h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h1><ul><li>funcition adapter</li><li>container adapter</li><li>iterator adapter</li></ul><hr><h1 id="3-container-adapter"><a href="#3-container-adapter" class="headerlink" title="3 container adapter"></a>3 container adapter</h1><ul><li>quque<ul><li>deque构成底层；</li></ul></li><li>stack</li></ul><hr><h1 id="4-iterator-adapter"><a href="#4-iterator-adapter" class="headerlink" title="4 iterator adapter"></a>4 iterator adapter</h1><ul><li>insert itearators</li><li>reverse iterators</li><li>iostream iterators<br>接口：</li><li><code>&lt;iterator&gt;</code></li><li>SGI STL <code>&lt;stl_iterator.h</code></li></ul><h2 id="4-1-insert-itearators"><a href="#4-1-insert-itearators" class="headerlink" title="4.1 insert itearators"></a>4.1 insert itearators</h2><ul><li>back_insert_iterator</li><li>front_insert_iterator</li><li>insert_iterator</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a52a8e6d8c64cacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个insert iterators内部维护一个容器（用户指定）,</li><li>用户对insert iterator赋值的时候，insert iterator调用内部容器的操作</li><li><code>operator++,opreator++(int),operator*</code>等都被关闭；</li><li>insert_iterators的前进，后退，取值，成员取用都不被允许；</li></ul><h3 id="4-1-1-back-insert-iterator"><a href="#4-1-1-back-insert-iterator" class="headerlink" title="4.1.1 back_insert_iterator"></a>4.1.1 back_insert_iterator</h3><pre><code>/**    1. back_insert_iterator*/template&lt;class Container&gt;class back_insert_iterator{protected:    Container* container; // 底层容器public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    explicit back_insert_iterator(Container&amp; x):container(x){}    back_insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            container-&gt;push_back(value);  // 调用容器操作            return *this;    }    // 一下三个操作对 back_insert_iterator 不起作用    // 三个返回都是自己    back_insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    back_insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    back_insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x){    return back_insert_iterator&lt;Container&gt;(x);}</code></pre><h3 id="4-1-2-front-insert-iterator"><a href="#4-1-2-front-insert-iterator" class="headerlink" title="4.1.2 front_insert_iterator"></a>4.1.2 front_insert_iterator</h3><pre><code>/**    2. front_insert_iterator*/template&lt;class Container&gt;class front_insert_iterator{protected:    Container* container; // 底层容器public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    explicit front_insert_iterator(Container&amp; x):container(x){}    front_insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            container-&gt;push_front(value);  // 调用容器操作            return *this;    }    // 一下三个操作对 front_insert_iterator 不起作用    // 三个返回都是自己    front_insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    front_insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    front_insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x){    return front_insert_iterator&lt;Container&gt;(x);}</code></pre><h3 id="4-1-3-insert-iterator"><a href="#4-1-3-insert-iterator" class="headerlink" title="4.1.3 insert_iterator"></a>4.1.3 insert_iterator</h3><pre><code>/**    3. insert_iterator*/template&lt;class Container&gt;class insert_iterator{protected:    Container* container; // 底层容器    typename Container::iterator  iter;public:    typedef output_iterator_tag         iterator_category;       typedef    void                        value_type;    typedef    void                         difference_type;    typedef void                        pointer;    typedef    void                        reference;    insert_iterator(Container&amp; x,typename Container::iterator i)        :container(x),iter(i){}    insert_iterator&lt;Container&gt;&amp;        operator=(const typename Container::value_type&amp; value){            iter = container-&gt;insert(value);  // 调用容器操作            ++iter;  // 随着目标移动            return *this;    }    // 一下三个操作对 insert_iterator 不起作用    // 三个返回都是自己    insert_iterator&lt;Container&gt;&amp; operator*(){return *this;}    insert_iterator&lt;Container&gt;&amp; operator++(){return *this;}    insert_iterator&lt;Container&gt;&amp; operator++(int){return *this;}};// 辅助函数template&lt;class Container&gt;inline insert_iterator&lt;Container&gt; front_inserter(Container&amp; x，Iterator i){    typedef typename Container::iterator iter;    return insert_iterator&lt;Container&gt;(x,iter(i));}</code></pre><h2 id="4-2-Reverse-Iterators"><a href="#4-2-Reverse-Iterators" class="headerlink" title="4.2 Reverse Iterators"></a>4.2 Reverse Iterators</h2><ul><li>将一般的迭代器逆转；</li></ul><pre><code>/**    二、 reverse Iterator*/template&lt;class Iterator&gt;class reverse_iterator{protected:    Iterator    current;   // 记录正向迭代器public:    // 逆向迭代器的5中类型    typedef typename iterator_traits&lt;Iterator&gt;:: iterator_category iterator_category;    typedef typename iterator_traits&lt;Iterator&gt;::value_type             value_type;    typedef typename iterator_traits&lt;Iterator&gt;::difference_type        difference_type;    typedef typename iterator_traits&lt;Iterator&gt;::pointer                pointer;    typedef typename iterator_traits&lt;Iterator&gt;::reference            reference;    typedef    Iterator    iterator_type;  // 正向迭代器    typedef    reverse_iterator&lt;Iterator&gt; self;        // 逆向迭代器public:    reverse_iterator(){}    explicit reverse_iterator(iterator_type x):current(x){}    reverse_iterator(const self&amp; x):current(x.current){}    iterator_type base() const{return current;}   // 取出正向迭代器    reference operator*() const {      // 对逆向迭代器取值，就是讲“对应的正向迭代器”退一格在取值        Iterator tmp = current;        treturn *--tmp;    }    pointer operator-&gt;() const{return &amp;(operator*());}    self&amp; operator++(){        -- current;        return *this;    }    self operator++(int){        self tmp = *this;        -- current;        return tmp;    }    // 后退操作    self&amp; operator--(){        ++current;        return *this;    }    self operator--(int){        self  tmp = *this;        ++current;        return tmp;    }    // 前进和后退完全逆转    self  operator+(difference_type n) const{        return self(current -n);    }    self&amp;  operator+=(difference_type n) const{        current -= n;        return *this;    }    self  operator-(difference_type n) const{        return self(current + n);    }    self&amp;  operator-=(difference_type n) const{        current += n;        return *this;    }    // 下面第一个* 和 + 都会调用本类的operator* 和operator+    // 第二个 * 不会调用本类，而是调用正向迭代器的operator*；    reference operator[](difference_type n )const{        return *(*this + n);    }};</code></pre><h2 id="4-3-IOStream-Iterators"><a href="#4-3-IOStream-Iterators" class="headerlink" title="4.3 IOStream Iterators"></a>4.3 IOStream Iterators</h2><ul><li>将迭代器绑定到某个iostream对象上；</li><li>istream_iterator</li><li>ostream_iterator</li></ul><h3 id="4-3-1-istream-iterator"><a href="#4-3-1-istream-iterator" class="headerlink" title="4.3.1 istream_iterator"></a>4.3.1 istream_iterator</h3><pre><code>// istream_iteratortemplate&lt;class T, class Distance = prdiff_t&gt;class istream_iterator{    // __STL_NULL_TMPL_ARGS    在&lt;stl_config.h&gt;中定义为 template&lt;&gt;    friend bool         operator== __STL_NULL_TMPL_ARGS(const istream_iterator&lt;T,Distance&gt;&amp; x,            const istream_iterator&lt;T,Distance&gt;&amp; y&gt;;protected:    istream* stream;    T value;    bool end_marker;    void read(){        end_marker = (*stream)? true: false;        if(end_marker)*stream &gt;&gt;value;        //以上输入之后，stream状态改变，所以在下面在判断一次决定end_marker        // 当读到eof或者型别不符合的时候，stream处于false状态        end_marker = (*stream)? true: false;    }public:    typedef input_iterator_tag                    iterator_category;    typedef    T                                    value_type;    typedef    Distance                            difference_type;    typedef    const T*                            pointer;    typedef    const T&amp;                            reference;    // 以上，因为input iterator ,所以采用const    istream_iterator(): stream(&amp;cin),end_marker(false){}    istream_iterator(istream&amp; s):stream(&amp;s){red();}    // 以上两行用法：    // istream_iterator&lt;int&gt; eos;  造成end_marker为false;    // istream_iterator&lt;int&gt; initer(cin); 引发read(), 程序会等待    // 因此，下面这两行：    // istream_iterator&lt;int&gt; initer(cin); (A)    // cout&lt;&lt;&quot;please input ..&quot;&lt;&lt;endl;     (B)    // 会停留在A等待一个输入，然后才执行(B)的提示信息，不合理；    // 规避：永远在合适的时候定义一个 istream_iterator    reference operator*()const{return value;}    pointer operator-&gt;() const{return &amp;(operator*());}    // 迭代器前进一个位置，读取一个资料    istream_iterator&lt;T,Distance&gt;&amp; operator++(){        read();        return *this;    }    istream_iterator&lt;T,Distance&gt; operator++(int){        istream_iterator&lt;T,Distance&gt; tmp = *this;        read();        return tmp;    }};</code></pre><h3 id="4-3-2-ostream-itreator"><a href="#4-3-2-ostream-itreator" class="headerlink" title="4.3.2 ostream_itreator"></a>4.3.2 ostream_itreator</h3><pre><code>// ostream_iteratortemplate&lt;class T&gt;class ostream_iterator{protected:    ostream* stream;    const char* string; // 每次输出的间隔符号public:    typedef output_iterator_tag        iterator_category;    typedef    void                    value_type;    typedef    void                    pointer;    typedef    void                    difference_type;    typedef    void                    reference;    ostream_iterator(ostream&amp; s):stream(&amp;s),string(0){}    ostream_iterator(ostream&amp; s, const char* c):stream(&amp;s),string(c){}    // 以上，用法：    // ostream_iterator&lt;int&gt; outlier(cout,&#39; &#39;); 输出到cout,每次间隔一个空格    // 迭代器赋值操作，代表输出一笔数据    ostream_iterator&lt;T&gt;&amp; operator=(const T&amp; value){        *stream&lt;&lt;value;        if(string) *stream&lt;&lt;string;  // 如果状态无误，输出间隔符号        return *this;    }    // 一下三个操作，都是返回自己    ostream_iterator&lt;T&gt;&amp; operator*(){return *this;}    ostream_iterator&lt;T&gt;&amp; operator++(){return *this;}    ostream_iterator&lt;T&gt;&amp; operator++(int){return *this;}};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/11/STL-%E9%85%8D%E6%8E%A5%E5%99%A8%E5%99%A8-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_仿函数</title>
      <link>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
      <guid>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Wed, 11 Jul 2018 12:47:56 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第七章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361608-e4607d5a9010
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第七章</p></blockquote><hr><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e4607d5a9010612b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li><p>操作数的个数</p><ul><li>一元</li><li>二元</li></ul></li><li><p>功能</p><ul><li>算法运算</li><li>关系运算</li><li>逻辑运算</li></ul></li><li><p><code>&lt;stl_finction.h&gt;</code> </p></li></ul><h1 id="2-基类"><a href="#2-基类" class="headerlink" title="2 基类"></a>2 基类</h1><pre><code>/**    一元仿函数： unary_function*/template&lt;class Arg, class Result&gt;struct unary_function{    typedef Arg argument_type;    typedef Result result_type;};/**    二元仿函数： binary_function*/template&lt;class Arg1,class Arg2,class Result&gt;struct binary_function{    typedef Arg1 first_argument_type;    typedef Arg2 seconde_argument_type;    typedef Result return_type;};</code></pre><h1 id="3-算术运算"><a href="#3-算术运算" class="headerlink" title="3 算术运算"></a>3 算术运算</h1><pre><code>/**    一、 算术类    --- 支持加法，减法，乘法，除法，模数和否定运算    -- 加法：plus&lt;T&gt;    -- 减法：minus&lt;T&gt;    -- 乘法： multiplies&lt;T&gt;    -- 除法： divides&lt;T&gt;    -- 模取： modulus&lt;T&gt;    -- 否定： negate&lt;T&gt;*/template&lt;class T&gt;struct plus : public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const{        return x + y;    }};template&lt;class T&gt;struct minus: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const {        return x - y;    }};template&lt;class T&gt;struct multiplies: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x,const T&amp; y) const{        return x * y;    }};template&lt;class T&gt;struct divides: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const{        return x / y;    }};template&lt;class T&gt;struct modulus: public binary_function&lt;T,T,T&gt;{    T operator()(const T&amp; x, const T&amp; y) const {        return x % y;    }};template&lt;class T&gt;struct negate: public unary_function&lt;T,T&gt;{    T operator()(const T&amp; x) const{        return -x;    }};</code></pre><h1 id="4-关系运算"><a href="#4-关系运算" class="headerlink" title="4 关系运算"></a>4 关系运算</h1><pre><code>/**    二、关系运算    -- 等于： equal_to&lt;T    -- 不等于： not_equal_to&lt;T    -- 大于： greater&lt;T&gt;    -- 大于或等于： greater_equal&lt;T&gt;    -- 小于： less&lt;T&gt;    -- 小于等于： less_equal&lt;T&gt;*/template&lt; class T&gt;struct equal_to: public binary_function&lt;T,T, bool&gt; {    bool operator()(const T&amp; x, const T&amp; y)const{        return x==y;    }};template&lt;class T&gt;struct not_equal_to: public binary_function&lt;T,T,T&gt;{    bool oeperator()(const T&amp; x, const T&amp; y) const{        return x!= y;    }};template&lt; class T&gt;struct greater: public binary_function&lt;T,T,T&gt; {    bool operator()(const T&amp; x, const T&amp; y) const{        return x&gt;y;    }};template&lt; class T&gt;struct less: public binary_function&lt;T,T,T&gt; {    bool operator()(const T&amp; x,const T&amp; y) const{        return x &lt; y;    }};template&lt; class T&gt;struct greater_equal: public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        sdreturn x&gt;=y;    }};template&lt; class T&gt;struct less_equal: public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x,const T&amp; y)const{        return x &lt;= y;    }};</code></pre><h1 id="5-逻辑运算"><a href="#5-逻辑运算" class="headerlink" title="5 逻辑运算"></a>5 逻辑运算</h1><pre><code>/**    三、 逻辑运算    -- And : logical_and    -- Or  : logical_or    __ Not:  logical_not*/template&lt;class T&gt;struct logical_and:public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        return x &amp;&amp; y;    }};template&lt;class T&gt;struct logical_or:public binary_function&lt;T,T,T&gt;{    bool operator()(const T&amp; x, const T&amp; y) const{        return x || y;    }};template&lt;class T&gt;struct logical_not:public unary_function&lt;T,T&gt;{    bool operator()(const T&amp; x) const{        return !x ;    }};</code></pre><h1 id="6-证同（identity）、选择（select）、-投射（project）"><a href="#6-证同（identity）、选择（select）、-投射（project）" class="headerlink" title="6 证同（identity）、选择（select）、 投射（project）"></a>6 证同（identity）、选择（select）、 投射（project）</h1><h2 id="6-1-证同"><a href="#6-1-证同" class="headerlink" title="6.1 证同"></a>6.1 证同</h2><h3 id="6-1-1-仿函数的证同"><a href="#6-1-1-仿函数的证同" class="headerlink" title="6.1.1 仿函数的证同"></a>6.1.1 仿函数的证同</h3><p> 证同元素(identity element)</p><ul><li>数值A若与该元素做op运算，会得到A自己；</li><li>加法的证同元素为0</li><li>乘法的证同元素为1 </li></ul><pre><code>/** 3.2 证同元素(identity element)- 数值A若与该元素做op运算，会得到A自己；- 加法的证同元素为0- 乘法的证同元素为1 */template&lt;class T&gt;inline T identity_element(plus&lt;T&gt;){    return T(0);}template&lt; class T&gt;inline T identity_element(multiplies&lt;T&gt;){    return T(1);}</code></pre><h3 id="6-1-2-证同函数"><a href="#6-1-2-证同函数" class="headerlink" title="6.1.2 证同函数"></a>6.1.2 证同函数</h3><pre><code>struct identity: public unary_function&lt;T,T&gt;{    const T&amp; operator()(const T&amp; x)const{        return x;    }};</code></pre><h2 id="6-2-选择"><a href="#6-2-选择" class="headerlink" title="6.2 选择"></a>6.2 选择</h2><pre><code>// 选择函数： 接受一个pair,传回第一个元素// 运用于&lt;stl_map.h&gt; ，用来指定rb_tree所需要的KeyOfValue op;template&lt; class Pair&gt;struct select1st:public unary_function&lt;Pair,typename Pair::first_type&gt;{    const typename Pair::first_type&amp; operator()(const Pair&amp; x) const{        return x.first;    }};// 选择函数，返回第二个元素// SGI stl 未使用此式子template&lt; class Pair&gt;struct select2nd:public unary_function&lt;Pair,typename Pair::second_type&gt;{    const typename Pair::second_type&amp; operator()(const Pair&amp; x) const{        return x.second;    }};</code></pre><h2 id="6-3-投射"><a href="#6-3-投射" class="headerlink" title="6.3 投射"></a>6.3 投射</h2><pre><code>// 投射函数：传回第一参数，忽略第二参数// SGI STL 未使用此式子template&lt;class Arg1,class Arg2&gt;struct project1st:public binary_function&lt;T,T,T&gt;{    Arg1 operator()(const Arg1&amp; x, const Arg2&amp;) const{        return x;    }};// 投射函数：传回第二参数，忽略第一参数// SGI STL 未使用此式子template&lt;class Arg1,class Arg2&gt;struct project1st:public binary_function&lt;T,T,T&gt;{    Arg2 operator()(const Arg1&amp;, const Arg2&amp; y) const{        return y;    }};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/11/STL-%E4%BB%BF%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_hashtable</title>
      <link>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</link>
      <guid>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</guid>
      <pubDate>Sun, 08 Jul 2018 10:44:01 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>插入，删除，搜索都是常数时间</li><li>视为一种字典结构</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ab2c47b3a5e91bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>问题：</p><ol><li>array数组</li><li>索引<ul><li>索引碰撞</li></ul></li></ol><ul><li>负载系数： 元素个数除以表格大小（大小为 0 ~ 1）；</li></ul><p>2 ：解决办法：</p><ul><li><p>线性探测：如果目标位置不可用，循序意义往下寻找，知道一个可用空间即可；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-2b6d559944a935d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>二次探测：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f9011c6bd0983d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>开链</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-318b1549c961b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h1 id="2-桶（buckets）和节点-nodes"><a href="#2-桶（buckets）和节点-nodes" class="headerlink" title="2 桶（buckets）和节点(nodes)"></a>2 桶（buckets）和节点(nodes)</h1><ul><li>hash table的表格元素为桶子；(表示可能为单个元素，或者一个list)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-fd77a7af5f9a037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-hashtable-实现"><a href="#3-hashtable-实现" class="headerlink" title="3 hashtable 实现"></a>3 hashtable 实现</h1><h2 id="3-1-hash-table-节点"><a href="#3-1-hash-table-节点" class="headerlink" title="3.1 hash table 节点"></a>3.1 hash table 节点</h2><pre><code>/**    hash table 节点定义    bucket维护的linked list，不采用stl的list或slist，而是维护    上述的hash table node;    bucket聚合体，以vector完成；*/template&lt;class Value&gt;struct __hashtable_node{    __hashtable_node* next;    Value val;};</code></pre><h2 id="3-2-hashtable迭代器"><a href="#3-2-hashtable迭代器" class="headerlink" title="3.2 hashtable迭代器"></a>3.2 hashtable迭代器</h2><ul><li>hashtable的迭代器器没有后退操作，也没有双向迭代器</li></ul><pre><code>/**    hashtable 的迭代器    hashtable的迭代器器没有后退操作，也没有双向迭代器*/template&lt;class Value, class Key, class HashFcn,        class ExtratKey, class Equalkey, class Alloc&gt;struct __hashtable_iterator{    typedef hashtable&lt;Value, Key,HashFcn,ExtratKey,Equalkey,Alloc&gt;        hashtable;    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,                                    Equalkey,Alloc&gt;  iterator;    typedef __hashtable_iterator&lt;Value,Key,HashFcn,ExtratKey,                                    Equalkey,Alloc&gt;  const_iterator;    typedef __hashtable_node&lt;Value&gt; node;    typedef forward_iterator_tag  iterator_category;    typedef    Value                   value_type;    typedef ptrdiff_t              difference_type;    typedef size_t                  size_type;    typedef Value&amp;                   reference;    typedef Value*                pointer;    node* cur;   // 迭代器当前指向节点    hashtable* ht; // 保持对容器的连接关系    __hashtable_iterator(node* n, hashtable* tab):cur(n),ht(tab){}    __hashtable_iterator(){}    reference operator*()const {return cur-&gt;val;}    pointer operator-&gt;() const {return &amp;(operator*());}    // hashtable的迭代器器没有后退操作，也没有双向迭代器    // 如果存在下一节点，直接next指针就可以；    // 如果节点为list的尾端，就跳到下一个bucket，即指向下一个list的头部节点；    iterator oprator++(){        const node* old = cur;        cur = cur-&gt;next; // 如果存在， 否则进入一下if        if(! cur){            // 根据元素值，定位下一个bucket，起始处就为答案            size_type bucket = ht-&gt;bkt_num(old-&gt;val);            while(!cur &amp;&amp; ++bucket &lt; ht-&gt;bucket.size()){                cur = ht-&gt;buckets[bucket];            }            return *this;        }    }    iterator operator++(int){        iterator tmp = *this;        ++*this;        return tmp;    }    bool operator== (const iterator&amp; it){return cur == it.cur;}    bool operator!= (const iterator&amp; it){return cur != it.cur;}};</code></pre><h2 id="3-3-hashtable数据结构"><a href="#3-3-hashtable数据结构" class="headerlink" title="3.3 hashtable数据结构"></a>3.3 hashtable数据结构</h2><h3 id="3-3-1-模板参数"><a href="#3-3-1-模板参数" class="headerlink" title="3.3.1 模板参数"></a>3.3.1 模板参数</h3><pre><code>    hashtable的数据结构    Value: 实值    Key: 键值    HashFcn: hash function类型    ExtratKey: 从节点中取出键值的方法    Equalkey : 判断键值相同与否的方法    Alloc: 空间配置；</code></pre><h3 id="3-3-2-表格大小设计"><a href="#3-3-2-表格大小设计" class="headerlink" title="3.3.2 表格大小设计"></a>3.3.2 表格大小设计</h3><ul><li>开链法 </li><li>SGI用质数来设计表格大小，先计算28 个质数的值存放起来方便直接访问；</li><li>提供了一个函数，用来查询“最近并大于某数”的质数</li></ul><pre><code>/**    开链法的表格大小预先设计    sgi stl 以质数来设计表格大小，现将28个质数计算好，用来被查询*/static const int __stl_num_primes = 28;static const unsigned long __stl_prime_list[__stl_num_primes] = {    53，97， 193， 389， 769，    ...    ...    ...  , 4294967291}// 一下用来找处28个质数中最近于n并大于n的质数inline unsigned long __stl_next_prime(unsigned long n){    const unsigned long* first = __stl_prime_list;    const unsigned long* last = __stl_prime_list + __stl_num_primes;    const unsigned long* pos = lower_bound(first,last,n); // 泛型算法，序列已排序    return pos == last ? *(last -1):*pos;}size_type max_bucket_count() const{    return __stl_prime_list[__stl_num_primes -1];    // 最大值为4294967291}</code></pre><h3 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3.3.3 数据结构"></a>3.3.3 数据结构</h3><pre><code>template&lt;class Value, class Key, class HashFcn,            class ExtratKey,class Equalkey, class Alloc = alloc&gt;class hashtable{public:    typedef        HashFcn        hasher;   // 型别参数重新定义一个名字    typedef        Equalkey    key_equal;        typedef        size_t        size_type;private:    // 以下三者都是函数对象 &lt;stl_hash_fun.h&gt;定义了数个    // 标准型（如int,c-style string等）的hasher;    hasher  hash;    key_equal equals;    ExtratKey  get_key;    typedef        __hashtable_node&lt;Value&gt; node;    typedef        simple_alloc&lt;node, Alloc&gt; node_allocator;    vector&lt;node*, Alloc&gt; buckets;  // vector完成    size_type    num_elements;public:    // bucket 个数 即 buckets vector的大小    size_type  bucket_count() const {return buckets.size();}...</code></pre><h3 id="3-3-4-构造函数"><a href="#3-3-4-构造函数" class="headerlink" title="3.3.4  构造函数"></a>3.3.4  构造函数</h3><ul><li>hashtable没有默认构造函数,其中一个构造函数为：</li></ul><pre><code>protected:    node* new_node(const value_type&amp; obj){        node* n = node_allocator::allocate();        n-&gt;next = 0;        __STL_TRY{            construct(&amp;n-&gt;val, obj);            return n;        }        __STL_UNWIND(node_allocator::deallocate(n));    }    void delete_node(node* n){        destroy(&amp;n-&gt;val);        node_allocator::deallocate(n);    }    // 初始构造 n个bunckets    void iniitalize_buckets(size_type n){        const size_type n_buckets = next_size(n);        buckets.reserve(n_buckets);        buckets.insert(buckets.end(),n_buckets,(node*)0);        num_elements = 0;    }    // 就会最接近于n并且大于n的质数    size_type next_size(size_type n) const {return __stl_next_prime(n);}public:    // hashtable没有默认构造函数    hashtable&lt;size_type n, const HashFcn&amp; hf, const Equalkey&amp; eql)        :hash(hf),equals(eql),get_key(ExtratKey()),num_elements(0){            iniitalize_buckets(n);        }</code></pre><h3 id="3-3-5-插入操作和表格重建"><a href="#3-3-5-插入操作和表格重建" class="headerlink" title="3.3.5  插入操作和表格重建"></a>3.3.5  插入操作和表格重建</h3><ul><li><p>当客户端插入元素的时候，会判断是否需要重建表格</p></li><li><p>resize() ：表格重建判断</p></li></ul><pre><code>// 函数判断是否需要重建表示，如果不要，立刻返回，如果需要，就动手    void resize(size_type num_elements_hint){        // 判断方法： 元素个数和bucker vector个数比较        // 如果前者大于后者，就重建        // 每个list的最大容量 和bucket vector大小相同        const size_type old_n = buckets.size();        if(num_elements_hint &gt; old_n){   // 需要重新配置            const size_type n = next_size(num_elements_hint);  // 新大小            if(n &gt; old_n){                vector&lt;node*, Alloc&gt;tmp(n, (node*)0);  // 设立新的buckets;                __STL_TRY{                    // 处理旧的bucket                    for(size_type bucket = 0; bucket &lt; old_n;++bucket){                        node* first = buckets[bucket];                        // 处理每个bucket的list                        while(first){                            // 寻找节点落在哪一个bucket                            size_type new_bucket =  bkt_num(first-&gt;val,n);                            // (1) 令旧的bucket 指向下一个节点                            buckets[bucket] = first-&gt;next;                            //(2)(3)将当前节点插入到新bucket中,前插法                            first-&gt;next = tmp[new_bucket];                            tmp[new_bucket] = first;                            //(4) 回到旧的bucket所指的list,准备处理下一个节点                            first = buckets[bucket];                        }                    }                    buckets.swap(tmp);  // vector::swap, 新旧两个bucket对换                    // 对换后，如果大小不一样，大的会变小，小的会变大                    // 离开后tmp释放                }            }        }    }</code></pre><ul><li><p>插入操作：分为两种，一种允许重复，一种不允许重复</p><ul><li><code>insert_unique_noresize</code> ：不允许重复</li><li><code>insert_equal_noresize</code> :允许节点重复</li></ul></li><li><p>第一种情况</p></li></ul><pre><code>    // 插入元素，不允许重复    pair&lt;iterator, bool&gt; insert_unique(const value_types obj){        resize(num_elements +1);  // 判断是否需要重建表格，如果需要就重新扩充        return insert_unique_noresize(obj);    }</code></pre><pre><code>    // 在不要建表格的情况下插入新节点，键值不允许重复    pair&lt;iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){        const size_type n = bkt_num(obj); // 决定obj的bucket位置        node* first = buckets[n];        // 如果buckets[n]已经被占用，此时first将不为0        // 迭代到list最尾节点        for(node* cur = first; cur; cur = cur-&gt;next){            // 如果发现存在相同键值，就返回，不插入            if(equals(get_key(cur-&gt;val), get_key(obj))                return pair&lt;iterator,bool&gt;(iterator(cur,this),false);        }        node* tmp = new_node(obj);  // 产生新节点        tmp-&gt;next = first;        buckets[n] = tmp ;   // 前插法        ++num_elements;        return pair&lt;iterator,bool&gt; (iterator(tmp,this),true);    }</code></pre><ul><li>第二种情况</li></ul><pre><code>    // 插入元素，允许重复    iterator insert_equal(const value_type&amp; obj){        resize(num_elements + 1);  // 判断是否重建表格        return insert_equal_noresize(obj);    }</code></pre><pre><code>    iterator insert_equal_noresize(const value_type&amp; obj){        const size_type n = bkt_num(obj);        node* first = buckets[n] ;         for(node* cur = first; cur; cur = cur-&gt;next){            if(equals(get_key(cur-&gt;val),get_key(obj)){                // list中存在相同键值的实值，就马上插入，在返回                node* tmp = new_node(obj);  // 新节点                tmp-&gt;next = cur-&gt;next;                cur-&gt;next = tmp;                ++num_elements;                return iterator(tmp, this);  // 返回            }        }        // 未发现重复值，到达链表尾端        node* tmp = new_node(obj);  // 新节点        tmp-&gt;next = first;        buckets[n] = tmp;        ++num_elements;        return iterator(tmp, this);  // 返回    }</code></pre><h3 id="3-3-6-复制和清除"><a href="#3-3-6-复制和清除" class="headerlink" title="3.3.6 复制和清除"></a>3.3.6 复制和清除</h3><ul><li>清除 <code>clear()</code></li></ul><pre><code>    void clear(){  // buckets空间为释放        // 对每一个bucket        for(size_type i=0; i&lt;buckets.size(); ++i){            node* cur = bucket[i];            // 将list每一个节点删除            while(cur != 0){                node* next = cur-&gt;next;                delete_node(cur);                cur = next;            }            bucket[i] = 0;  // bucket为NULL        }        num_elements = 0;  // 总数为0    }</code></pre><ul><li>复制</li></ul><pre><code>    void copy_from(const hashtable&amp; ht){        // 先清除自己的buckets vector,调用vector::clear()        buckets.clear();        // 如果自己的空间大于对方，就不动，小于的话，增大        buckets.reserve(ht.buckets.size());        // 此时buckets为空，end()就是起头        buckets.insert(buckets.end(),ht.buckets.size(), (node*)0);        __STL_TRY{            // 每个bucket            for(size_type i=0 ;i&lt;ht.buckets.size(); ++i){                // 每个bucket 开头                if(const node* cur = ht.bucket[i]) {                    node* cp = new_node(cur-&gt;val);                    buckets[i] = cp;                    // 每个bucket的list                    for(node* next = cur-&gt;next; next; cur =next, next = cur-&gt;next){                        cop -&gt;next = new_node(next-&gt;val);                        cp = cp-&gt;next;                    }                }                }            num_elements = ht.num_elements;        }        __STL_UNWIND(clear());    }</code></pre><h3 id="3-3-7-判断元素落脚"><a href="#3-3-7-判断元素落脚" class="headerlink" title="3.3.7 判断元素落脚"></a>3.3.7 判断元素落脚</h3><pre><code>public:    // 计算 元素的键值,即hashtable上的bucket序号    // 版本1： 接受实值和buckets个数    size_type bkt_num(const value_type&amp; obj, size_t n) const{        return bkt_num_key(get_key(obj),n);  // 版本4    }    // 版本2： 只接受实值value    size_type bkt_num(const value_type&amp; obj) const{        return bkt_num_key(get_key(obj));   // 版本3    }    // 版本3： 只接受键值    size_type bkt_num(const key_type&amp; key) const{        return bkt_num_key(key,buckets.size());   // 版本4    }    // 版本4： 只接受键值和buckets个数    size_type bkt_num(const key_type&amp; key，size_t n) const{        return hash(key) % n; // SGI内建 hash()    }</code></pre><h1 id="4-hashtable的hash-function"><a href="#4-hashtable的hash-function" class="headerlink" title="4. hashtable的hash function"></a>4. hashtable的hash function</h1><ul><li>SGI的内置hash函数只针对了char,int,long等整数型别，而且都只是返回原值</li><li>只对<code>const char*</code>做了一个转换</li><li>因此无法处理string,double ,float等型别，</li><li>用户必须自定义hash function</li></ul><pre><code>/** hash function类型 &lt;stl_hash_fun.h&gt;*/template&lt;class Key&gt;struct hash{};inline size_t __stl_hash_string(const char* s){    unsigned long  h =0;    for(;*s;++s)        h = 5*h + *s;    return size_t(h);}// __STL_TAMPLATE_NULL 定义为template&lt;&gt; 在;&lt;stl_config.h&gt;中__STL_TAMPLATE_NULLstruct hash&lt;char*&gt;{    size_t operator()(char* s){        return __stl_hash_string(s);    }}__STL_TAMPLATE_NULLstruct hash&lt;const char*&gt;{    size_t operator()(const char* s){        return __stl_hash_string(s);    }}__STL_TAMPLATE_NULLstruct hash&lt;char&gt;{    size_t operator()(char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned char&gt;{    size_t operator()(unsigned char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;signed char&gt;{    size_t operator()(unsigned char s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;short&gt;{    size_t operator()(short s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned short&gt;{    size_t operator()(unsigned short s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;int&gt;{    size_t operator()(int s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned int&gt;{    size_t operator()( unsigned int s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;long&gt;{    size_t operator()(long s){        return s;    }}__STL_TAMPLATE_NULLstruct hash&lt;unsigned long&gt;{    size_t operator()( unsigned long s){        return s;    }}</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/08/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_map</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:35 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>map的元素都是pair</li><li>map 不允许两个元素拥有相同的键值；</li></ul><h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h1><pre><code>template&lt; class T1, class T2&gt;struct pair{    typedef T1 first_type;    typedef T2 seconde_type;    T1 first;    T2 second;    pair():first(T1()),second(T2()){}    pair(const T1&amp; a, const T2&amp; b):first(a), second(b){}};template&lt;class Key, class T,        class Compare = less&lt;Key&gt;,        class Alloc = alloc&gt;class map{public:    typedef    Key key_type;      typedef    T data_type;    typedef T mapped_type;    typedef pair&lt;const Key, T&gt; value_type;  // 元素型别    typedef    Compare key_compare;    // 比较函数    class value_compare: binary_function&lt;value_type, value_type,bool&gt;{        friend class  map&lt;Key,T, Compare, Alloc&gt;;        protected:            Compare comp;            value_compare(Compare c):comp(c){}        public:            bool operator()(const value_type&amp; x, const value_type&amp; y) const{                return comp(x.first, y.first);            }    };private:    rep_type t;public:    typedef     typename  rep_type::pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // 构造函数    map():t(Compare()){}    explicit map(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_unique(first,last);    }    map(const map&lt;Key,T, Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    map&lt;Key,T, Compare,Alloc&gt;&amp; operator=(const map&lt;Key,T,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // 访问器    key_compare key_comp() const(return t.key_comp(););    value_compare value_comp() const{return value_compare(t.key_comp());}    iterator begin() {return t.begin();}    const_iterator begin()const{return t.begin();}    iterator end() {return t.begin();}    const_iterator end() const{return t.end();}    reverse_iterator rbegin() {return t.rbegin();}    const_reverse_iterator rbegin() const {return t.rbegin();}    reverse_iterator rend() {return t.rend();}    const_reverse_iterator rend() const{return t.rend();}    bool empty() const {return t.empty();}    size_type size() const{return t.size();}    size_type max_size() const{return t.max_size();}    T&amp; operator[](const key_type&amp; k){        return(*((insert(value_type(k,T()))).first)).second;    }    void swap(map&lt;Key,T,Compare,Alloc&gt;&amp; x){t.swap(x.t);}    // 插入。删除    // 插入、 删除操作    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        return t.insert_unique(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_unique(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        t.erase(position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    iterator find(const key_type&amp; x) {return t.find(x);}        const_iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x){        return t.equal_range(x);    }    pair&lt;const_iterator,const_iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const map&amp;, const map&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt map&amp;, const map&amp;);};template&lt;class Key, class T, class Compare, class Alloc&gt;inline bool operator==(const map&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T, Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key,class T, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="3-multimap"><a href="#3-multimap" class="headerlink" title="3 multimap"></a>3 multimap</h1><pre><code>/**    multimap*/template&lt;class Key,class T,class Compare= less&lt;Key&gt;            class Alloc = alloc&gt;class multimap{public:    // typedefs     ...  // 和set一样    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_equal(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_equal(first,last);    }    ...// 和set一样    // insert    insert insert(const value_type&amp; x){        return t.insert_equal(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_equal(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_equal(first, last);    }    ... // 其他和map一样};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_set</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:21 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>set 所有元素根据元素的键值自动被排序</li><li>set的键值和实值都是同样的；</li><li>不允许两个元素有相同的键值；</li><li>set<t>::iterator为const_iterator</t></li><li>Rb_tree作为底层；</li></ul><h1 id="1-set"><a href="#1-set" class="headerlink" title="1. set"></a>1. set</h1><pre><code>/**    set源码摘录*/template&lt;class Key,         class Compare = less &lt;Key&gt;,   // 缺省下采用递增排序        class Alloc = alloc&gt;class set{public:    typedef Key    key_type;    typedef    Key    value_type;    typedef Compare    key_compare;    typedef    Compare    value_compare;private:// 以下 identity 定义于&lt;stl_function.h&gt;    /*    template&lt; class T&gt;    struct identity:public unary_function&lt;T, T&gt;{        const T&amp; operator()(const T&amp; x){return x;}    };    */    typedef    rb_tree&lt;key_type, value_type,identity&lt;value_type&gt;,key_compare,Alloc&gt; rep_type;    rep_type t;  // 采用红黑树表示setpublic:    typedef     typename  rep_type::const_pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::const_reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::const_iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::const_reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // aollocattion // deallocation    // set 使用rb_tree 的insert_unique()    // multiset 使用 rb_tree的insert_equal()    set():t(Compare()){}    explicit set(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last):t(Compare())    {        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last, const Compare&amp; comp)        :t(comp){            t.insert_unique(first,last);        }    set(const set&lt;Key,Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    set&lt;Key, Compare,Alloc&gt;&amp; operator=(const set&lt;Key,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // set 操作    key_compare key_comp() const{return t.key_comp();}    value_compare value_comp() const{{return t.key_comp();}    iterator begin() const{return t.begin();}    iterator end()    const{return t.end();}    reverse_iterator rbegin() const{retur t.rbegin();}    reverse_iterator rend() const{return t.rend();}    bool empty() const{return t.empty();}    size_type size() const {return t.size();}    size_type max_size() const{return t.max_size();}    void swap(set&lt;Key,Compare,Alloc&gt;&amp;x){t.swap(x.t);}    // 插入、 删除操作    typedef pair&lt;iterator,bool&gt; pair_iterator_bool;    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        pair&lt;typename rep_type::iterator,bool&gt; p = t.insert_unique(x);        return pair&lt;iterator,bool&gt;(p.first,p.last);    }    iterator insert(iterator position, const value_type&amp; x){        typedef typename rep_type::iterator rep_iterator;        return t.insert_unique((rep_iterator&amp;)position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    // set 操作    iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const set&amp;, const set&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt set&amp;, const set&amp;);};template&lt;class Key, class Compare, class Alloc&gt;inline bool operator==(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="2-multiset"><a href="#2-multiset" class="headerlink" title="2 multiset"></a>2 multiset</h1><p><code>`</code><br>/*<em><br>    multiset</em>/</p><p>// set 不同之处<br>template&lt;class Key, class Compare = less<key>, class Alloc= alloc&gt;<br>class multiset{</key></p><p>public:<br>// typedefs<br>… // 一样和set</p><p>//构造函数</p><pre><code>template&lt;class InputIterator&gt;multiset(InputIterator first,InputIterator last):t(Compare()){    t.insert_equal(first,last);}template&lt;class InputIterator&gt;multiset(InputIterator first, InputIterator last, Compare&amp; comp):t(comp){    t.insert_equal(first,last);}...   // 与 set一样// 插入删除iterator insert(const value_type&amp; x){    return t.insert_equal(x);}iterator insert(iterator position, const value_type&amp; x){    typedef typename rep_type::iterator rep_iterator;    return t.insert_equal((rep_iterator&amp;)position,x);}template&lt;class InputIterator&gt;void insert(InputIterator first, InputIterator last){    t.insert_equal(first,last);}... // 其他和set一样</code></pre><p>};</p><p>···</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
