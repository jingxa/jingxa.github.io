<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Thu, 21 Jun 2018 13:47:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>1_Tensor_Learn_OPS_2</title>
      <link>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-2/</link>
      <guid>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-2/</guid>
      <pubDate>Thu, 21 Jun 2018 13:46:06 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;1-4-variable&quot;&gt;&lt;a href=&quot;#1-4-variable&quot; class=&quot;headerlink&quot; title=&quot;1.4 variable&quot;&gt;&lt;/a&gt;1.4 variable&lt;/h2&gt;&lt;h3 id=&quot;1-4-1-变量的概念&quot;&gt;&lt;a href
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="1-4-variable"><a href="#1-4-variable" class="headerlink" title="1.4 variable"></a>1.4 variable</h2><h3 id="1-4-1-变量的概念"><a href="#1-4-1-变量的概念" class="headerlink" title="1.4.1 变量的概念"></a>1.4.1 变量的概念</h3><p>constant和variable的区别：</p><ul><li>tf. constant is an op</li><li>tf. V ariable is  a class with multiple ops. </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cc093a4fa77154a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>第二点说明了常量存储在graph中，constant是memory expensive， 因此，如果graph中的constant过多，那么每次载入graph 的速度变得很慢；</p></li><li><p>如果想要查看graph中的存储：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-77c7034cd2acbd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>输出为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-94e58d3c55fd6e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>创建一个变量：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8a43df33a3d32b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>老的创建变量的方式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-917f5fbd29b25d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但是现在不推荐使用这种方式，推荐使用：<code>tf.get_variable</code>,参数如下，当使用tf.constant作为初始器来，不需要输入shape;</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8aac8812d20daba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-43b02007952acd16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-4-2-初始化变量"><a href="#1-4-2-初始化变量" class="headerlink" title="1.4.2 初始化变量"></a>1.4.2 初始化变量</h3><ul><li>变量在使用前需要初始化，否则抛出<code>FailedPreconditionError:Attempting to use unintialized value</code></li><li>如果想获得未初始化的变量列表：如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d01410fa9698f0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(1)最简单的初始化变量的方式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9136055a81ae592e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2)初始化变量的子集：<br>可以使用下面的<code>tf.variable_initializer()</code></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0cb840a6b3713f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(3)也可以对每个变量分开初始化<code>tf.Variable.initializer</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9c8d65f4f2aaf956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(4)从一个文件中载入值来初始化变量</p><hr><h3 id="1-4-3-求变量值"><a href="#1-4-3-求变量值" class="headerlink" title="1.4.3 求变量值"></a>1.4.3 求变量值</h3><p>（1） 类似tensors,获得变量值需要在一个session下；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-75a5c52f035aa654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2 ）使用<code>tf.Variable.eval()</code></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6c7d5246165cf231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>print(V.eal()) # 获取值</code></pre><h3 id="1-4-4-变量赋值"><a href="#1-4-4-变量赋值" class="headerlink" title="1.4.4 变量赋值"></a>1.4.4 变量赋值</h3><p>（1） <code>tf.Variable.assign()</code></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-354852da3562ae67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>W结果为10 ： 赋值操作有效，必须在session下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb8c618508c2ec0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>在这段代码中，没有使用初始化操作，因为初始化操作就是一个赋值操作；</p></li><li><p>源代码中的初始化操作：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-146474becae7166d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一个例子：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb2f4a344122e236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>·tf.Variable.assign_add()·和<code>tf.Variable.assign_sub()</code>不同于assign操作；这两个方法不能初始化变量，因为这两个方法依赖变量的初始值；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-bca6b384feb42500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>因为session分别维持着值，每个session 对于一个变量有着各自的当前值：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-244b9ea35721f8c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假如一个变量W和另一个变量U是相关的，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d279a789b35175b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>应该使用<code>initialized_value()</code>确保这个变量W初始化在U使用这个变量前：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-043caee5b2fa2547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-5-Interactive-Session"><a href="#1-5-Interactive-Session" class="headerlink" title="1.5 Interactive Session"></a>1.5 Interactive Session</h2><ul><li>交互式session和默认session不同的是不需要显式调用session；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-24ea7a500d250dc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><code>tf.get_default_session()</code>返回当前线程的默认session；</li></ul><hr><h2 id="1-6-Control-Dependencies"><a href="#1-6-Control-Dependencies" class="headerlink" title="1.6  Control Dependencies"></a>1.6  Control Dependencies</h2><ul><li>有时候，如果有多个独立的op，我们想要指定op的运行顺序：</li><li>使用<code>tf.Graph.control_dependencies([control_inputs])</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4bed84beb31387fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-7-Importing-Data"><a href="#1-7-Importing-Data" class="headerlink" title="1. 7 Importing Data"></a>1. 7 Importing Data</h2><h3 id="1-7-1-old-way-placeholders-and-feed-dict"><a href="#1-7-1-old-way-placeholders-and-feed-dict" class="headerlink" title="1.7.1 old way: placeholders and feed_dict"></a>1.7.1 old way: placeholders and feed_dict</h3><ul><li><p>如果想要构建一个图，但是不知道要计算的值：</p></li><li><p>定义一个占位符：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5697bb05c4dd5fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果这个占位符的shape为none,代表任何shape的tensor被接受；建议尽可能定义shape，不要默认；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-329d9c901d0f2eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-496bc6ff7f0cb47f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（1） 传递单一值<br>但是如果运行，会得到一个错误，需要给占位符一个输入；一般传入一个字典，key为占位符，value为占位符的值：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b67aa9d16cf42036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2）传递多个值给一个占位符<br>使用循环传递：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-66c6107ea8f9e3f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（3） 检查tensor是否feedable</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-29c2d6ed284cb64b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-7-2-new-way-tf-data"><a href="#1-7-2-new-way-tf-data" class="headerlink" title="1.7.2 new way:tf.data"></a>1.7.2 new way:tf.data</h3><ul><li>后面线性回归举例子；</li></ul><hr><h2 id="1-8-trap-of-lazy-loading"><a href="#1-8-trap-of-lazy-loading" class="headerlink" title="1.8  trap of lazy loading"></a>1.8  trap of lazy loading</h2><ul><li><p>一个不是bug的bug – ‘lazy loading’</p></li><li><p>在tensorflow中，直到你需要一个op才会创建它；</p></li></ul><p>例如：</p><pre><code>x = tf.Variable(10,name = &#39;x&#39;)y = tf.Variable(20,name = &#39;y&#39;)z = tf.add(x,y)with tf.Session() as sess:  sess.run(tf.global_variables_initializer())  writer = tf.summary.FileWriter(&#39;graphs/normal_loading&#39;,sess.graph)  for _ in range(10):    sess.run(z)  writer.close()</code></pre><p>在循环中：</p><pre><code>x = tf.Variable(10, name=&#39;x&#39;)y = tf.Variable(20, name=&#39;y&#39;)with tf.Session() as sess:  sess.run(tf.global_variables_initializer())  writer = tf.summary.FileWriter(&#39;graphs/lazy_loading&#39;, sess.graph)  for _ in range(10):    sess.run(tf.add(x, y))  print(tf.get_default_graph().as_graph_def())  writer.close()</code></pre><p>第一个只有一个add节点，结果为：</p><pre><code>node {  name: &quot;Add&quot;  op: &quot;Add&quot;  input: &quot;x/read&quot;  input: &quot;y/read&quot;  attr {    key: &quot;T&quot;    value {      type: DT_INT32      }    }}</code></pre><p>而第二种有多个add节点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a29cca95be6409d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>如果不注意，就会在graph中添加很多节点；</li></ul><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1_Tensor_Learn_OPS_1</title>
      <link>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-1/</link>
      <guid>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-1/</guid>
      <pubDate>Thu, 21 Jun 2018 13:44:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1. 基本概念&lt;/h1&gt;&lt;p&gt;tensorflow不仅是一个软件库，还包括Tensorflow，Tensorboard,TensorS
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>tensorflow不仅是一个软件库，还包括Tensorflow，Tensorboard,TensorServing;</p><ul><li>Tensorflow中constants,variables,operators 称为：ops;</li></ul><h2 id="1-1-Constant-op"><a href="#1-1-Constant-op" class="headerlink" title="1.1 Constant op"></a>1.1 Constant op</h2><pre><code class="python">tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;, verify_shape=False)# constant of 1d tensor (vector)a = tf.constant([2, 2], name=&quot;vector&quot;)# constant of 2x2 tensor (matrix)b = tf.constant([[0, 1], [2, 3]], name=&quot;matrix&quot;)</code></pre><p>创建 类似numpy的结构</p><pre><code>tf.zeros(shape, dtype=tf.float32, name=None)# create a tensor of shape and all elements are zeros# ==&gt; [[0, 0, 0], [0, 0, 0]]tf.zeros([2, 3], tf.int32) </code></pre><p>创建类似·input_tensor·的shape和type(除非指定)但是元素全部为0：</p><pre><code>tf.zeros_like(input_tensor, dtype=None, name=None, optimize=True)# input_tensor [[0, 1], [2, 3], [4, 5]]tf.zeros_like(input_tensor)  #==&gt; [[0, 0], [0, 0], [0, 0]]</code></pre><ul><li>创建一个tensor，所有元素都为1<br><code>`</code><br>tf.ones(shape.dtype  =  tf.float32  ,  name  =  None)</li></ul><p>tf.ones([  2  ,   3  ],  tf  .  int32  )  </p><p> #==&gt;   [[  1  ,   1  ,   1  ],   [  1  ,   1  ,   1  ]]<br><code>`</code></p><ul><li>创建一个类似input_tensor的shape结构，数据type可以自定义,所有元素为1；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-51931d934a916970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>创建一个tensor ,并且使用一个标量填充；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c5db6be102722506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>创建一个连续constant，包含start和stop；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a2fa8fa2ae007f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>从一个数开始创建一个constant 序列，但是不包括最后limit数；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8502e3bd5a2c5d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-18ba5ab7b409d49b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>但是，tensor不支持python的迭代器属性：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d11f279c7db31cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>tensorflow的随机生成：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3b675676bdb469d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="1-2-math-ops"><a href="#1-2-math-ops" class="headerlink" title="1.2 math ops"></a>1.2 math ops</h2><ul><li><a href="https://www.tensorflow.org/api_guides/python/math_ops" target="_blank" rel="noopener">math_ops</a></li></ul><h3 id="1-2-1-division"><a href="#1-2-1-division" class="headerlink" title="1.2.1 division"></a>1.2.1 division</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1586df33c9136fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4ec12108b8a3f45c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-2-2-add"><a href="#1-2-2-add" class="headerlink" title="1.2.2 add"></a>1.2.2 add</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-27d7811b4186dcf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-2-3-product"><a href="#1-2-3-product" class="headerlink" title="1.2.3 product"></a>1.2.3 product</h3><p><code>tf.matmul</code> 不等于dot product：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-0ae8c3063d20cd86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-2-4-ops-in-Python"><a href="#1-2-4-ops-in-Python" class="headerlink" title="1.2.4 ops in Python"></a>1.2.4 ops in Python</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d8cd33fe3bf21fac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-Data-Type"><a href="#1-3-Data-Type" class="headerlink" title="1.3 Data Type"></a>1.3 Data Type</h2><h3 id="1-3-1-python-type"><a href="#1-3-1-python-type" class="headerlink" title="1.3.1 python type"></a>1.3.1 python type</h3><ul><li>tensorflow 适配python原始类型：<ul><li>python中的single value(boolean,numeric value,strings) =&gt; 0-d tensor（scalars）</li><li>list : 1-d tensor</li><li>list of list : 2-d tensor</li></ul></li></ul><p>等等；</p><p>例如： </p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ddc839d123dc7831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7616c685ca6085bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-3-2-tensor-type"><a href="#1-3-2-tensor-type" class="headerlink" title="1.3.2 tensor type"></a>1.3.2 tensor type</h3><ul><li><a href="https://www.tensorflow.org/api_docs/python/tf/DType" target="_blank" rel="noopener">全部类型</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-96befea16e1db0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4aa75cfd5df45da3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-3-3-numpy-Type"><a href="#1-3-3-numpy-Type" class="headerlink" title="1.3.3 numpy Type"></a>1.3.3 numpy Type</h3><ul><li>tensor 的type基于numpy的type，因此例如 <code>tf.int32 == np.int32</code> 返回true;<br>在tensor中可以传递numpy的type：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d94c5e020c92428c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong>1.tensor 和numpy的boolean，numeric value相互匹配；但是string不是完全匹配，tf能够导入numpy strings，只是不要指定numpy的dtypes;</strong></p><p><strong>2.numpy  不支持gpu,tensorflow 支持；</strong> </p><p><strong>3.tensorflow能够推断数据类型状态：如integer： tf中有：8-bit,16-bit,32-bit,64bit可用，但是python不能推断使用的那种数据类型</strong></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/21/1-Tensor-Learn-OPS-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>cs231a-homework-1</title>
      <link>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</link>
      <guid>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</guid>
      <pubDate>Tue, 19 Jun 2018 14:05:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;一、affine-camera-Calibration&quot;&gt;&lt;a href=&quot;#一、affine-camera-Calibration&quot; class=&quot;headerlink&quot; title=&quot;一、affine camera Calibration&quot;&gt;&lt;/a&gt;一、aff
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、affine-camera-Calibration"><a href="#一、affine-camera-Calibration" class="headerlink" title="一、affine camera Calibration"></a>一、affine camera Calibration</h1><h2 id="1-1-相机参数-计算"><a href="#1-1-相机参数-计算" class="headerlink" title="1.1 相机参数 计算"></a>1.1 相机参数 计算</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03fce6331a4ddc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ff53ebf6a86b559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>小块大小： 50 mm * 50 mm</li><li>小块间隔： 30mm</li><li>总大小： 450 mm * 450 mm</li></ul><hr><ul><li>计算思路：</li><li>查看ps1_code中的三个npy文件的shape</li><li>real_XY:(12,2)</li><li>front:(12,2)</li><li>back:(12,2)<br>说明选取了十二个点作为测量点，对于3D到2D的变换：</li><li><code>p&#39; = M P</code></li></ul><p>在相机校准中，相机的参数矩阵为：(3 * 4),一共有11个自由度；</p><ul><li>但是本题，是affine camera， 是弱透视投影，因此，参数为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-88c8a13eac856914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>只需要计算8个自由度；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8ec2e79577d7b2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>m3为[0 0 0 1]</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a91e9bee8aaa4231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>则m3Pi = 1</p></li><li><p>因此，可以建立上图中的P矩阵为：(2n * 8)的矩阵，n为参考点个数；</p></li><li><p>m 为： (8 * 1),省略m3,到时候添加上一行[0 0 0 1]就可以</p></li><li><p>因此线性方程变为： Pm=0 ==&gt;Am=b</p></li></ul><p>使用最小二乘，求解：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c782966f307b92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>####在我们的方程中：AM =b</p><ul><li>A： 2n * 8</li><li>m: 8 * 1</li><li>b = 2n * 1</li></ul><p><img src="https://latex.codecogs.com/gif.latex?minimize%20%5Cleft%20%5C%7C%20Am%20-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%2C" alt=""></p><p>对m求导，得到 </p><p><img src="https://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7C%20Am-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%3D%20A%5E%7B2%7Dm%5E%7B2%7D-2Amb%20&plus;%20b%5E%7B2%7D%20%5C%5C%20%3D%3E%202A%5E%7B2%7Dm%20-%202A%5E%7BT%7Db%20%3D0%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7B2%7D%29%5E%7B-1%7DA%5E%7BT%7Db%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7BT%7DA%29%5E%7B-1%7DA%5E%7BT%7Db" alt=""></p><p>因此，计算 affine camera的矩阵为：</p><pre><code class="python">def compute_camera_matrix(real_XY, front_image, back_image):    img_num1 = front_image.shape[0]     img_num2 = back_image.shape[0]    # 建立真实XYZ的齐次矩阵    ones = np.ones((img_num1, 1))    front_z = np.zeros((img_num1, 1))    front_scence = np.c_[real_XY, front_z, ones]  # 12 * 4    back_z =150 * np.ones((img_num2,1))    back_scence = np.c_[real_XY, back_z, ones]  # 12 * 4    # 合并两个真实场景    M_scene = np.r_[front_scence, back_scence]  # 24 * 4    # 系数矩阵 A  2n * 8    n = img_num1 + img_num2    A = np.zeros((2*n, 8))    for i in range(0, A.shape[0], 2):        idx = int(i/2)        A[i, :] = np.hstack((M_scene[idx, :], [0, 0, 0, 0]))        A[i+1, :] = np.hstack(([0, 0, 0, 0], M_scene[idx, :]))    # 图片对应点矩阵 2n * 1     # b = [U1,V1, U2,V2,..., Un,Vn]    b = front_image[0].T    for i in range(1, img_num1, 1):        b = np.hstack((b, front_image[i].T))    for j in range(img_num2):        b = np.hstack((b, back_image[j].T))    b = np.reshape(b, (2 * n, 1))    # 计算矩阵，添加最后一行    # p = np.linalg.lstsq(A, b, rcond=None)  # 直接计算 AM= b ==&gt; M = A^(-1)*b    # camera_matrix = p[0]    camera_matrix = np.linalg.inv(A.T.dot(A)).dot(A.T).dot(b)   # 使用最小二乘计算结果    camera_matrix = np.reshape(camera_matrix, (2, -1)) # m(8,1) ==&gt; m(2,4)    camera_matrix = np.vstack((camera_matrix, [0, 0, 0, 1])) # 添加最后一列 ==&gt; m（3,4）    return camera_matrix</code></pre><ul><li>其中，使用两中方法：</li><li>计算 m = A^(-1)*b</li><li>计算最小二乘法</li></ul><p>两个的结果为；</p><ul><li>方法一：<pre><code>[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02][ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01][ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</code></pre></li><li>方法二：</li></ul><pre><code>[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02] [ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01] [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</code></pre><ul><li>两者之间的差为：</li></ul><pre><code>[[ 3.55271368e-15  5.19723153e-15 -1.38777878e-17  0.00000000e+00] [ 2.20060081e-13 -1.89404048e-13  3.06282777e-14  2.84217094e-14] [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]]</code></pre><p>可以看出每一项的差很小,说明两种方法近似；</p><hr><h2 id="1-2-RMS-计算"><a href="#1-2-RMS-计算" class="headerlink" title="1.2 RMS 计算"></a>1.2 RMS 计算</h2><ul><li>RMS : </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-53ce720a360065b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code class="python">def rms_error(camera_matrix, real_XY, front_image, back_image):    img_num1 = front_image.shape[0]    img_num2 = back_image.shape[0]    ones = np.ones((img_num1,1))    # 建立图像XYZ的齐次矩阵    front_img = np.c_[front_image, ones]     # front_image : n * 3    back_img = np.c_[back_image, ones]   # back_image: n * 3    img = np.r_[front_img, back_img]    img = img.T  # img : 3 * 2n    # 建立真实XYZ的齐次矩阵    front_z = np.zeros((img_num1, 1))    front_scence = np.c_[real_XY, front_z, ones]  # n * 4    back_z =150 * np.ones((img_num2,1))    back_scence = np.c_[real_XY, back_z, ones]  # n * 4    # 合并两个真实场景    M_scene = np.r_[front_scence, back_scence]  # 2n * 4    M_scene = M_scene.T  # real : 4 * 2n    M_scene_trans = camera_matrix.dot(M_scene)  # 变换    diff_sqr = (M_scene_trans - img)**2 # 平方差    diff_sum = np.sum(np.sum(diff_sqr,axis=0))  # 平方差的和，先行相加，在列相加    diff_sum /= (img_num1 + img_num2)   # 求均值    rms_error = np.sqrt(diff_sum)    return rms_error</code></pre><h2 id="1-3-主函数"><a href="#1-3-主函数" class="headerlink" title="1.3 主函数"></a>1.3 主函数</h2><ul><li>python 3.6<br>这两个函数的主函数：</li></ul><pre><code class="python">import numpy as npif __name__ == &#39;__main__&#39;:    # Load the example coordinates setup.    real_XY = np.load(&#39;real_XY.npy&#39;)    front_image = np.load(&#39;front_image.npy&#39;)    back_image = np.load(&#39;back_image.npy&#39;)    camera_matrix = compute_camera_matrix(real_XY, front_image, back_image)    rmse = rms_error(camera_matrix, real_XY, front_image, back_image)    print (&quot;Camera Matrix:\n&quot;, camera_matrix)    print()    print (&quot;RMS Error: &quot;, rmse)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-18036e390c98df9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-4-使用两个位置平面的原因"><a href="#1-4-使用两个位置平面的原因" class="headerlink" title="1.4 使用两个位置平面的原因"></a>1.4 使用两个位置平面的原因</h2><ul><li>如果只使用一个平面：<ul><li>线性方程的系数矩阵： rank &lt; n; 非满秩矩阵，没有唯一解，</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7bbbfc7ee4db2e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个方阵是奇异矩阵，没有可逆矩阵；</p><ul><li>因此，需要至少两个平面；</li></ul><hr><h1 id="二、单视图几行"><a href="#二、单视图几行" class="headerlink" title="二、单视图几行"></a>二、单视图几行</h1><h2 id="2-1-灭点"><a href="#2-1-灭点" class="headerlink" title="2.1 灭点"></a>2.1 灭点</h2><ul><li>相机 no-skew ：没有偏斜</li><li><p>square pixels with   no distortion : 没有扭曲</p></li><li><p>在3d中平行的线投影到2D中，相交于一点—灭点；因此，通过两线相交求得灭点；</p></li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_VANISHING_POINTSArguments:    points - 四对点，前两对为一条直线，后两对为一条，两条线是平行的；Returns:    灭点&#39;&#39;&#39;def compute_vanishing_point(points):    # 获取四对点    x1 = points[0, 0]    y1 = points[0, 1]   # (x1,y1)    x2 = points[1, 0]    y2 = points[1, 1]   # (x2,y2)    x3 = points[2, 0]    y3 = points[2, 1]   # （x3,y3）    x4 = points[3, 0]    y4 = points[3, 1]   # (x4,y4)    # 计算两条直线的参数    a1 = (y2 - y1)/(x2 - x1)    b1 = y1 - a1 * x1    print(&quot;line1: &quot;, a1, b1)    a2 = (y4 - y3)/(x4 - x3)    b2 = y3 - a2 * x3    print(&quot;line2:&quot;, a2, b2)    # 计算交点    x = (b1 - b2)/(a2 - a1)    y = a1 * x + b1    vanish_point = np.array([x, y])    return vanish_point</code></pre><h2 id="2-2-计算相机内参矩阵K"><a href="#2-2-计算相机内参矩阵K" class="headerlink" title="2.2 计算相机内参矩阵K"></a>2.2 计算相机内参矩阵K</h2><ul><li>使用三对灭点计算内部参数</li><li>无穷线的投影变成了水平线：</li></ul><p>因此将一对3d平行线的无穷交点投影成一个灭点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设两对平行线的灭点为v1,v2, 两对平行线的方向分别为d1,d2，那么这每一对平行线的夹角为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3f0fee0cbccdce69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-344f019d6232aca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0888390d19d82e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于一个标准相机,可以将w简化为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2af4fad907d2ad90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0d9e8622d8de703b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>得4个未知参数，然而w是可以缩放的，因此w6最后缩放为1,只需要3个未知变量；</p></li><li><p>因此，只需要三对灭点就可以求得矩阵K;</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d37dfb8754ca5585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个式子可以求解一个未知解；</li></ul><p><img src="https://latex.codecogs.com/gif.latex?%5Bx_%7B1%7D%2Cy_%7B1%7D%2C1%5D*%5Cbegin%7Bbmatrix%7D%20%26w_%7B1%7D%20%260%20%26w_%7B4%7D%5C%5C%20%260%20%26w_%7B1%7D%20%26w_%7B5%7D%20%5C%5C%20%26w_%7B4%7D%20%26w_%7B5%7D%20%26w_%7B6%7D%20%5Cend%7Bbmatrix%7D*%5Bx_%7B2%7D%2Cy_%7B2%7D%2C1%5D%20%3D%200" alt=""></p><p>化简为：</p><p><img src="https://latex.codecogs.com/gif.latex?%28x_%7B1%7Dx_%7B2%7D&plus;y_%7B1%7Dy_%7B2%7D%29w_%7B1%7D%20&plus;%20%28x_%7B1%7D%20&plus;%20x_%7B2%7D%29w_%7B4%7D&plus;%28y_%7B1%7D%20&plus;%20y_%7B2%7D%29w_%7B5%7D&plus;w_%7B6%7D%3D0" alt=""></p><p>w6 最小化1；</p><ul><li><p>说明w是一个对称矩阵，并且是正定矩阵，那么可以在最后，使用Cholesky分解法进行分解；</p></li><li><h2 id="cholesky分解"><a href="#cholesky分解" class="headerlink" title="cholesky分解"></a><a href="https://blog.csdn.net/billbliss/article/details/78559387" target="_blank" rel="noopener">cholesky分解</a></h2></li></ul><p>因此，通过三对灭点构建3*4系数矩阵;<br>代码如下：</p><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_points - a list of vanishing pointsReturns:    K - the intrinsic camera matrix (3x3 matrix)&#39;&#39;&#39;def compute_K_from_vanishing_points(vanishing_points):    v1 = vanishing_points[0]    v2 = vanishing_points[1]    v3 = vanishing_points[2]    # 构建系数矩阵    A = np.zeros((3, 4))    A[0] = np.array([(v1[0]*v2[0] + v1[1]*v2[1]), (v1[0] + v2[0]), (v1[1] + v2[1]), 1])    A[1] = np.array([(v1[0]*v3[0] + v1[1]*v3[1]), (v1[0] + v3[0]), (v1[1] + v3[1]), 1])    A[2] = np.array([(v2[0]*v3[0] + v2[1]*v3[1]), (v2[0] + v3[0]), (v2[1] + v3[1]), 1])    # print(&quot;A:\n&quot;,A)    # SVD分解    U, s, vT = np.linalg.svd(A, full_matrices=True)    # print(&#39;SVD:\n&#39;,U,U.shape)    # print(&#39;s:\n&#39;,s, s.shape)    # print(&#39;v:\n&#39;,vT,vT.shape)    # print()    w = vT[-1, :]   # 取最后一行，最为最优解    print(&#39;w:\n&#39;,w, w.shape)    omega = np.array([  # 建立w矩阵        [w[0], 0, w[1]],        [0, w[0], w[2]],        [w[1], w[2], w[3]]    ], dtype=np.float64)    print()    # 使用cholesky 分解得到K    kT_inv = np.linalg.cholesky(omega)  # w = (k*k.T)^-1 ==&gt; 分解为 k.T^-1    k = np.linalg.inv(kT_inv.T)     k /= k[2, 2]    # 最小化    return k</code></pre><p>【注意】</p><ul><li>三对灭点： 需要正交</li><li>为了减小误差，可以使用超过两条以上的平行线计算灭点，然后计算这个坐标的平均值作为最终灭点；</li></ul><h2 id="2-3-计算两个平面的夹角"><a href="#2-3-计算两个平面的夹角" class="headerlink" title="2.3  计算两个平面的夹角"></a>2.3  计算两个平面的夹角</h2><ul><li>通过上面的公式，通过灭点计算灭线，然后计算角度；</li><li>【问题】<ul><li>不明白为什么通过求点的叉积来获得灭线向量，感觉没有意义啊？？</li></ul></li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_pair1 - a list of a pair of vanishing points computed from lines within the same plane    vanishing_pair2 - a list of another pair of vanishing points from a different plane than vanishing_pair1    K - the camera matrix used to take both imagesReturns:    angle - the angle in degrees between the planes which the vanishing point pair comes from2&#39;&#39;&#39;def compute_angle_between_planes(vanishing_pair1, vanishing_pair2, K):    omega_inv = K.dot(K.T)    # a set of vanishing points on one plane    v1 = np.hstack((vanishing_pair1[0], 1))    v2 = np.hstack((vanishing_pair1[1], 1))    # another set of vanishing points on the other plane    v3 = np.hstack((vanishing_pair2[0], 1))    v4 = np.hstack((vanishing_pair2[1], 1))    # find two vanishing lines    L1 = np.cross(v1.T, v2.T)  # 为什么如此？    L2 = np.cross(v3.T, v4.T)    # find the angle between planes    costheta = (L1.T.dot(omega_inv).dot(L2)) / (np.sqrt(L1.T.dot(omega_inv).dot(L1)) * np.sqrt(L2.T.dot(omega_inv).dot(L2)))    theta = (np.arccos(costheta) / math.pi) * 180    return theta</code></pre><h2 id="2-4-计算旋转矩阵"><a href="#2-4-计算旋转矩阵" class="headerlink" title="2.4 计算旋转矩阵"></a>2.4 计算旋转矩阵</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d09bf4c264e3b2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>假设相机只经过旋转，没有平移；</li><li>通过灭点求解的真实平行线的方向；</li><li>两幅图片的真实平行线是不变的，通过真实平行线的矩阵变换求得相机的旋转矩阵；</li></ul><pre><code class="python">&#39;&#39;&#39;COMPUTE_K_FROM_VANISHING_POINTSArguments:    vanishing_points1 - a list of vanishing points in image 1    vanishing_points2 - a list of vanishing points in image 2    K - the camera matrix used to take both imagesReturns:    R - the rotation matrix between camera 1 and camera 2&#39;&#39;&#39;def compute_rotation_matrix_between_cameras(vanishing_points1, vanishing_points2, K):    ones = np.ones((vanishing_points1.shape[0], 1))    # 建立齐次矩阵    v1 = np.hstack((vanishing_points1, ones)).T    v2 = np.hstack((vanishing_points2, ones)).T    # 计算真实平行线的方向    # d = K^-1 * v    k_inv = np.linalg.inv(K)    D1 = k_inv.dot(v1) / np.linalg.norm(k_inv.dot(v1),axis=0)   # 按列计算norm范数    D2 = k_inv.dot(v2) / np.linalg.norm(k_inv.dot(v2),axis=0)    # d2 = R * d1, d2.T = d1.T * R.T    R = np.linalg.lstsq(D1.T, D2.T,rcond = None)[0].T    return R</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/19/cs231a-homework-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客搭建记录</title>
      <link>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</link>
      <guid>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 31 May 2017 10:37:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;简单记录一下利用hexo+github搭建博客的过程&lt;/p&gt;
&lt;h4 id=&quot;主要思路&quot;&gt;&lt;a href=&quot;#主要思路&quot; class=&quot;headerlink&quot; title=&quot;主要思路&quot;&gt;&lt;/a&gt;主要思路&lt;/h4&gt;&lt;p&gt;　　安装git和node的过程就不多提了，本次安装hex
        
      
      </description>
      
      <content:encoded><![CDATA[<p>简单记录一下利用hexo+github搭建博客的过程</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>　　安装git和node的过程就不多提了，本次安装hexo博客主要采用建立GitHub pages托管，建立两个分支，一个用于提交源文件，一个用于提交hexo静态文件，如果博客需要换电脑，直接git clone下来即可</p><blockquote><p>hexo分支：博客源文件内容<br>master分支:静态博客内容</p></blockquote><h4 id="一-建立远程库"><a href="#一-建立远程库" class="headerlink" title="一 建立远程库"></a>一 建立远程库</h4><p>　　注意事项：<br>　　　　１.建立两个分支master 和hexo<br>　　　　２.将hexo分支设为默认分支，这样方便提交源文件</p><h4 id="二、下载远程库"><a href="#二、下载远程库" class="headerlink" title="二、下载远程库"></a>二、下载远程库</h4><pre><code>git clone git@github.com:jingxa/jingxa.github.io.git</code></pre><p>改成你的名字</p><h6 id="【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"><a href="#【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交" class="headerlink" title="【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"></a>【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交</h6><h4 id="三、开始安装hexo"><a href="#三、开始安装hexo" class="headerlink" title="三、开始安装hexo"></a>三、开始安装hexo</h4><h5 id="1、安装hexo"><a href="#1、安装hexo" class="headerlink" title="1、安装hexo"></a>1、安装hexo</h5><pre><code> npm install -g hexo-cli</code></pre><h5 id="2、-初始化hexo"><a href="#2、-初始化hexo" class="headerlink" title="2、 初始化hexo"></a>2、 初始化hexo</h5><pre><code>hexo init</code></pre><h5 id="3、安装npm"><a href="#3、安装npm" class="headerlink" title="3、安装npm"></a>3、安装npm</h5><pre><code> npm install</code></pre><h5 id="4、-安装next主题-："><a href="#4、-安装next主题-：" class="headerlink" title="4、 安装next主题 ："></a>4、 安装next主题 ：</h5><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>【注意：在<em>.jithub.io和themes/next都有一个_config.yml的文件，为了区分。我们使用一下称呼】<br>–</em>github.io/_config.yml:站点配置文件<br>–themes/next/_config.yml:主题配置文件</p><h5 id="5-配置站点文件"><a href="#5-配置站点文件" class="headerlink" title="5.配置站点文件"></a>5.配置站点文件</h5><h6 id="【注意：每一项的填写，其-后面都要保留一个空格】"><a href="#【注意：每一项的填写，其-后面都要保留一个空格】" class="headerlink" title="【注意：每一项的填写，其:后面都要保留一个空格】"></a>【注意：每一项的填写，其:后面都要保留一个空格】</h6><p>(1).修改网站相关信息</p><pre><code>title: 你的题目subtitle: 小题目description: 描述author: 作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p>(2).配置统一资源定位符（个人域名）</p><pre><code>url: https://jingxa.github.io</code></pre><p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。<br>(3). 配置部署</p><pre><code>deploy:  type: git  repo: ssh://git@github.com/jingxa/jingxa.github.io.git  branch: master</code></pre><p>这里我们使用ssh，不使用https,可以避免提交的时候需要输入密码验证<br>(4).主题修改</p><pre><code>themes: next</code></pre><h5 id="6-配置主题文件"><a href="#6-配置主题文件" class="headerlink" title="6.配置主题文件"></a>6.配置主题文件</h5><p>这些大家自己百度<br><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a></p><h5 id="7-提交"><a href="#7-提交" class="headerlink" title="7.提交"></a>7.提交</h5><p>这一步大家讲源文件提交到github,托管源码，方便以后转移、<br>在提交之前，大家需要将【.gitignore】中添加一些配置，免得将一些不必要的东西提交到github上，我的配置如下：</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>将这个不必要的忽略掉<br>(1).增加文件 </p><pre><code>git add .</code></pre><p>提交所有的文件<br>(2).可以使用 </p><pre><code>git status</code></pre><p>检查提交哪些东西<br>(3).提交 </p><pre><code>git commit -m &quot;自己修改commit信息&quot;</code></pre><p>(4).重要的地方，我们需要将修改提交到hexo,分支</p><pre><code>git push origin hexo</code></pre><p>然后完成了源文件的提交，下一步就是提交hexo生成的静态文件，再次之前，需要安装依赖包</p><h5 id="8-安装npm-install-hexo-deployer-git-–save"><a href="#8-安装npm-install-hexo-deployer-git-–save" class="headerlink" title="8.安装npm install hexo-deployer-git –save"></a>8.安装npm install hexo-deployer-git –save</h5><pre><code>npm install hexo-deployer-git --save</code></pre><p>其实这一步可以在前面npm install 之后安装</p><h5 id="9-静态博客生成"><a href="#9-静态博客生成" class="headerlink" title="9.静态博客生成"></a>9.静态博客生成</h5><p>(1).我们可以写一篇文章</p><pre><code>hexo new &quot;你的题目&quot;</code></pre><p>我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。<br>保存后，我们进行本地发布：<br>(2).我自己测试，</p><pre><code>　hexo s -p 8888</code></pre><p>如果使用 </p><pre><code>hexo server</code></pre><p> 会使用默认端口4000，这个一直不能再本地显示，所以我们可以自己更改端口，就能正常访问<br>(3).打开浏览器，输入：</p><pre><code>http://localhost:8888/</code></pre><p>我们可以在浏览器端看到我们搭建好的博客和发布的文章：</p><h5 id="10-博客提交到github上"><a href="#10-博客提交到github上" class="headerlink" title="10.博客提交到github上"></a>10.博客提交到github上</h5><p>(1).这一步主要是清除缓存数据</p><pre><code>hexo clean</code></pre><p>(2). 生成</p><pre><code>//hexo generate可以简写成hexo g</code></pre><p>(3). 发布</p><pre><code>//hexo deploy可以简写成 hexo d</code></pre><p>然后访问你的默认网站。就可以看到你的成果了！</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
