<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Tue, 19 Jun 2018 14:27:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>test</title>
      <link>https://jingxa.github.io/2018/06/19/test/</link>
      <guid>https://jingxa.github.io/2018/06/19/test/</guid>
      <pubDate>Tue, 19 Jun 2018 14:27:47 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：&lt;br&gt;&lt;br&gt;本文作者：&lt;br&gt;本文链接：https://jingxa.github.io/2018/06/19/test/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;hr&gt;&lt;br&gt;除非注明，本博文章均为原创，转载请以链接形
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><blockquote><p>版权声明：<br><br>本文作者：<br>本文链接：https://jingxa.github.io/2018/06/19/test/</p></blockquote><p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/19/test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>cs231a-homework-1</title>
      <link>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</link>
      <guid>https://jingxa.github.io/2018/06/19/cs231a-homework-1/</guid>
      <pubDate>Tue, 19 Jun 2018 14:05:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;一、affine-camera-Calibration&quot;&gt;&lt;a href=&quot;#一、affine-camera-Calibration&quot; class=&quot;headerlink&quot; title=&quot;一、affine camera Calibration&quot;&gt;&lt;/a&gt;一、aff
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、affine-camera-Calibration"><a href="#一、affine-camera-Calibration" class="headerlink" title="一、affine camera Calibration"></a>一、affine camera Calibration</h1><h2 id="1-1-相机参数-计算"><a href="#1-1-相机参数-计算" class="headerlink" title="1.1 相机参数 计算"></a>1.1 相机参数 计算</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03fce6331a4ddc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ff53ebf6a86b559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>小块大小： 50 mm * 50 mm</li><li>小块间隔： 30mm</li><li>总大小： 450 mm * 450 mm</li></ul><hr><ul><li>计算思路：</li><li>查看ps1_code中的三个npy文件的shape</li><li>real_XY:(12,2)</li><li>front:(12,2)</li><li>back:(12,2)<br>说明选取了十二个点作为测量点，对于3D到2D的变换：</li><li><code>p&#39; = M P</code></li></ul><p>在相机校准中，相机的参数矩阵为：(3 * 4),一共有11个自由度；</p><ul><li>但是本题，是affine camera， 是弱透视投影，因此，参数为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-88c8a13eac856914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>只需要计算8个自由度；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8ec2e79577d7b2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>m3为[0 0 0 1]</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a91e9bee8aaa4231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>则m3Pi = 1</p></li><li><p>因此，可以建立上图中的P矩阵为：(2n * 8)的矩阵，n为参考点个数；</p></li><li><p>m 为： (8 * 1),省略m3,到时候添加上一行[0 0 0 1]就可以</p></li><li><p>因此线性方程变为： Pm=0 ==&gt;Am=b</p></li></ul><p>使用最小二乘，求解：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c782966f307b92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>####在我们的方程中：AM =b</p><ul><li>A： 2n * 8</li><li>m: 8 * 1</li><li>b = 2n * 1</li></ul><p><img src="https://latex.codecogs.com/gif.latex?minimize%20%5Cleft%20%5C%7C%20Am%20-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%2C" alt=""></p><p>对m求导，得到 </p><p><img src="https://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7C%20Am-b%20%5Cright%20%5C%7C%5E%7B2%7D%20%3D%20A%5E%7B2%7Dm%5E%7B2%7D-2Amb%20&plus;%20b%5E%7B2%7D%20%5C%5C%20%3D%3E%202A%5E%7B2%7Dm%20-%202A%5E%7BT%7Db%20%3D0%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7B2%7D%29%5E%7B-1%7DA%5E%7BT%7Db%20%5C%5C%20%3D%3E%20m%20%3D%20%28A%5E%7BT%7DA%29%5E%7B-1%7DA%5E%7BT%7Db" alt=""></p><p>因此，计算 affine camera的矩阵为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def compute_camera_matrix(real_XY, front_image, back_image):</span><br><span class="line">    img_num1 = front_image.shape[0] </span><br><span class="line">    img_num2 = back_image.shape[0]</span><br><span class="line"></span><br><span class="line">    # 建立真实XYZ的齐次矩阵</span><br><span class="line">    ones = np.ones((img_num1, 1))</span><br><span class="line">    front_z = np.zeros((img_num1, 1))</span><br><span class="line">    front_scence = np.c_[real_XY, front_z, ones]  # 12 * 4</span><br><span class="line"></span><br><span class="line">    back_z =150 * np.ones((img_num2,1))</span><br><span class="line">    back_scence = np.c_[real_XY, back_z, ones]  # 12 * 4</span><br><span class="line"></span><br><span class="line">    # 合并两个真实场景</span><br><span class="line">    M_scene = np.r_[front_scence, back_scence]  # 24 * 4</span><br><span class="line"></span><br><span class="line">    # 系数矩阵 A  2n * 8</span><br><span class="line">    n = img_num1 + img_num2</span><br><span class="line">    A = np.zeros((2*n, 8))</span><br><span class="line">    for i in range(0, A.shape[0], 2):</span><br><span class="line">        idx = int(i/2)</span><br><span class="line">        A[i, :] = np.hstack((M_scene[idx, :], [0, 0, 0, 0]))</span><br><span class="line">        A[i+1, :] = np.hstack(([0, 0, 0, 0], M_scene[idx, :]))</span><br><span class="line"></span><br><span class="line">    # 图片对应点矩阵 2n * 1 </span><br><span class="line">    # b = [U1,V1, U2,V2,..., Un,Vn]</span><br><span class="line">    b = front_image[0].T</span><br><span class="line">    for i in range(1, img_num1, 1):</span><br><span class="line">        b = np.hstack((b, front_image[i].T))</span><br><span class="line">    for j in range(img_num2):</span><br><span class="line">        b = np.hstack((b, back_image[j].T))</span><br><span class="line">    b = np.reshape(b, (2 * n, 1))</span><br><span class="line"></span><br><span class="line">    # 计算矩阵，添加最后一行</span><br><span class="line">    # p = np.linalg.lstsq(A, b, rcond=None)  # 直接计算 AM= b ==&gt; M = A^(-1)*b</span><br><span class="line">    # camera_matrix = p[0]</span><br><span class="line"></span><br><span class="line">    camera_matrix = np.linalg.inv(A.T.dot(A)).dot(A.T).dot(b)   # 使用最小二乘计算结果</span><br><span class="line">    camera_matrix = np.reshape(camera_matrix, (2, -1)) # m(8,1) ==&gt; m(2,4)</span><br><span class="line">    camera_matrix = np.vstack((camera_matrix, [0, 0, 0, 1])) # 添加最后一列 ==&gt; m（3,4）</span><br><span class="line">    return camera_matrix</span><br></pre></td></tr></table></figure><ul><li>其中，使用两中方法：</li><li>计算 m = A^(-1)*b</li><li>计算最小二乘法</li></ul><p>两个的结果为；</p><ul><li><p>方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02]</span><br><span class="line">[ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01]</span><br><span class="line">[ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 5.31276507e-01 -1.80886074e-02  1.20509667e-01  1.29720641e+02]</span><br><span class="line"> [ 4.84975447e-02  5.36366401e-01 -1.02675222e-01  4.43879607e+01]</span><br><span class="line"> [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]</span><br></pre></td></tr></table></figure><ul><li>两者之间的差为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 3.55271368e-15  5.19723153e-15 -1.38777878e-17  0.00000000e+00]</span><br><span class="line"> [ 2.20060081e-13 -1.89404048e-13  3.06282777e-14  2.84217094e-14]</span><br><span class="line"> [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]]</span><br></pre></td></tr></table></figure><p>可以看出每一项的差很小,说明两种方法近似；</p><hr><h2 id="1-2-RMS-计算"><a href="#1-2-RMS-计算" class="headerlink" title="1.2 RMS 计算"></a>1.2 RMS 计算</h2><ul><li>RMS : </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-53ce720a360065b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def rms_error(camera_matrix, real_XY, front_image, back_image):</span><br><span class="line">    img_num1 = front_image.shape[0]</span><br><span class="line">    img_num2 = back_image.shape[0]</span><br><span class="line"></span><br><span class="line">    ones = np.ones((img_num1,1))</span><br><span class="line">    # 建立图像XYZ的齐次矩阵</span><br><span class="line">    front_img = np.c_[front_image, ones]     # front_image : n * 3</span><br><span class="line">    back_img = np.c_[back_image, ones]   # back_image: n * 3</span><br><span class="line">    img = np.r_[front_img, back_img]</span><br><span class="line">    img = img.T  # img : 3 * 2n</span><br><span class="line"></span><br><span class="line">    # 建立真实XYZ的齐次矩阵</span><br><span class="line">    front_z = np.zeros((img_num1, 1))</span><br><span class="line">    front_scence = np.c_[real_XY, front_z, ones]  # n * 4</span><br><span class="line"></span><br><span class="line">    back_z =150 * np.ones((img_num2,1))</span><br><span class="line">    back_scence = np.c_[real_XY, back_z, ones]  # n * 4</span><br><span class="line"></span><br><span class="line">    # 合并两个真实场景</span><br><span class="line">    M_scene = np.r_[front_scence, back_scence]  # 2n * 4</span><br><span class="line">    M_scene = M_scene.T  # real : 4 * 2n</span><br><span class="line"></span><br><span class="line">    M_scene_trans = camera_matrix.dot(M_scene)  # 变换</span><br><span class="line">    diff_sqr = (M_scene_trans - img)**2 # 平方差</span><br><span class="line">    diff_sum = np.sum(np.sum(diff_sqr,axis=0))  # 平方差的和，先行相加，在列相加</span><br><span class="line">    diff_sum /= (img_num1 + img_num2)   # 求均值</span><br><span class="line"></span><br><span class="line">    rms_error = np.sqrt(diff_sum)</span><br><span class="line">    return rms_error</span><br></pre></td></tr></table></figure><h2 id="1-3-主函数"><a href="#1-3-主函数" class="headerlink" title="1.3 主函数"></a>1.3 主函数</h2><ul><li>python 3.6<br>这两个函数的主函数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # Load the example coordinates setup.</span><br><span class="line">    real_XY = np.load(&apos;real_XY.npy&apos;)</span><br><span class="line">    front_image = np.load(&apos;front_image.npy&apos;)</span><br><span class="line">    back_image = np.load(&apos;back_image.npy&apos;)</span><br><span class="line"></span><br><span class="line">    camera_matrix = compute_camera_matrix(real_XY, front_image, back_image)</span><br><span class="line">    rmse = rms_error(camera_matrix, real_XY, front_image, back_image)</span><br><span class="line">    print (&quot;Camera Matrix:\n&quot;, camera_matrix)</span><br><span class="line">    print()</span><br><span class="line">    print (&quot;RMS Error: &quot;, rmse)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5361608-18036e390c98df9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-4-使用两个位置平面的原因"><a href="#1-4-使用两个位置平面的原因" class="headerlink" title="1.4 使用两个位置平面的原因"></a>1.4 使用两个位置平面的原因</h2><ul><li>如果只使用一个平面：<ul><li>线性方程的系数矩阵： rank &lt; n; 非满秩矩阵，没有唯一解，</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7bbbfc7ee4db2e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个方阵是奇异矩阵，没有可逆矩阵；</p><ul><li>因此，需要至少两个平面；</li></ul><hr><h1 id="二、单视图几行"><a href="#二、单视图几行" class="headerlink" title="二、单视图几行"></a>二、单视图几行</h1><h2 id="2-1-灭点"><a href="#2-1-灭点" class="headerlink" title="2.1 灭点"></a>2.1 灭点</h2><ul><li>相机 no-skew ：没有偏斜</li><li><p>square pixels with   no distortion : 没有扭曲</p></li><li><p>在3d中平行的线投影到2D中，相交于一点—灭点；因此，通过两线相交求得灭点；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">COMPUTE_VANISHING_POINTS</span><br><span class="line">Arguments:</span><br><span class="line">    points - 四对点，前两对为一条直线，后两对为一条，两条线是平行的；</span><br><span class="line">Returns:</span><br><span class="line">    灭点</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def compute_vanishing_point(points):</span><br><span class="line">    # 获取四对点</span><br><span class="line">    x1 = points[0, 0]</span><br><span class="line">    y1 = points[0, 1]   # (x1,y1)</span><br><span class="line">    x2 = points[1, 0]</span><br><span class="line">    y2 = points[1, 1]   # (x2,y2)</span><br><span class="line">    x3 = points[2, 0]</span><br><span class="line">    y3 = points[2, 1]   # （x3,y3）</span><br><span class="line">    x4 = points[3, 0]</span><br><span class="line">    y4 = points[3, 1]   # (x4,y4)</span><br><span class="line"></span><br><span class="line">    # 计算两条直线的参数</span><br><span class="line">    a1 = (y2 - y1)/(x2 - x1)</span><br><span class="line">    b1 = y1 - a1 * x1</span><br><span class="line">    print(&quot;line1: &quot;, a1, b1)</span><br><span class="line"></span><br><span class="line">    a2 = (y4 - y3)/(x4 - x3)</span><br><span class="line">    b2 = y3 - a2 * x3</span><br><span class="line">    print(&quot;line2:&quot;, a2, b2)</span><br><span class="line"></span><br><span class="line">    # 计算交点</span><br><span class="line">    x = (b1 - b2)/(a2 - a1)</span><br><span class="line">    y = a1 * x + b1</span><br><span class="line">    vanish_point = np.array([x, y])</span><br><span class="line">    return vanish_point</span><br></pre></td></tr></table></figure><h2 id="2-2-计算相机内参矩阵K"><a href="#2-2-计算相机内参矩阵K" class="headerlink" title="2.2 计算相机内参矩阵K"></a>2.2 计算相机内参矩阵K</h2><ul><li>使用三对灭点计算内部参数</li><li>无穷线的投影变成了水平线：</li></ul><p>因此将一对3d平行线的无穷交点投影成一个灭点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设两对平行线的灭点为v1,v2, 两对平行线的方向分别为d1,d2，那么这每一对平行线的夹角为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3f0fee0cbccdce69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-344f019d6232aca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0888390d19d82e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于一个标准相机,可以将w简化为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2af4fad907d2ad90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0d9e8622d8de703b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>得4个未知参数，然而w是可以缩放的，因此w6最后缩放为1,只需要3个未知变量；</p></li><li><p>因此，只需要三对灭点就可以求得矩阵K;</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d37dfb8754ca5585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>每一个式子可以求解一个未知解；</li></ul><p><img src="https://latex.codecogs.com/gif.latex?%5Bx_%7B1%7D%2Cy_%7B1%7D%2C1%5D*%5Cbegin%7Bbmatrix%7D%20%26w_%7B1%7D%20%260%20%26w_%7B4%7D%5C%5C%20%260%20%26w_%7B1%7D%20%26w_%7B5%7D%20%5C%5C%20%26w_%7B4%7D%20%26w_%7B5%7D%20%26w_%7B6%7D%20%5Cend%7Bbmatrix%7D*%5Bx_%7B2%7D%2Cy_%7B2%7D%2C1%5D%20%3D%200" alt=""></p><p>化简为：</p><p><img src="https://latex.codecogs.com/gif.latex?%28x_%7B1%7Dx_%7B2%7D&plus;y_%7B1%7Dy_%7B2%7D%29w_%7B1%7D%20&plus;%20%28x_%7B1%7D%20&plus;%20x_%7B2%7D%29w_%7B4%7D&plus;%28y_%7B1%7D%20&plus;%20y_%7B2%7D%29w_%7B5%7D&plus;w_%7B6%7D%3D0" alt=""></p><p>w6 最小化1；</p><ul><li><p>说明w是一个对称矩阵，并且是正定矩阵，那么可以在最后，使用Cholesky分解法进行分解；</p></li><li><h2 id="cholesky分解"><a href="#cholesky分解" class="headerlink" title="cholesky分解"></a><a href="https://blog.csdn.net/billbliss/article/details/78559387" target="_blank" rel="noopener">cholesky分解</a></h2></li></ul><p>因此，通过三对灭点构建3*4系数矩阵;<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">COMPUTE_K_FROM_VANISHING_POINTS</span><br><span class="line">Arguments:</span><br><span class="line">    vanishing_points - a list of vanishing points</span><br><span class="line"></span><br><span class="line">Returns:</span><br><span class="line">    K - the intrinsic camera matrix (3x3 matrix)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def compute_K_from_vanishing_points(vanishing_points):</span><br><span class="line">    v1 = vanishing_points[0]</span><br><span class="line">    v2 = vanishing_points[1]</span><br><span class="line">    v3 = vanishing_points[2]</span><br><span class="line"></span><br><span class="line">    # 构建系数矩阵</span><br><span class="line">    A = np.zeros((3, 4))</span><br><span class="line">    A[0] = np.array([(v1[0]*v2[0] + v1[1]*v2[1]), (v1[0] + v2[0]), (v1[1] + v2[1]), 1])</span><br><span class="line">    A[1] = np.array([(v1[0]*v3[0] + v1[1]*v3[1]), (v1[0] + v3[0]), (v1[1] + v3[1]), 1])</span><br><span class="line">    A[2] = np.array([(v2[0]*v3[0] + v2[1]*v3[1]), (v2[0] + v3[0]), (v2[1] + v3[1]), 1])</span><br><span class="line"></span><br><span class="line">    # print(&quot;A:\n&quot;,A)</span><br><span class="line">    # SVD分解</span><br><span class="line">    U, s, vT = np.linalg.svd(A, full_matrices=True)</span><br><span class="line"></span><br><span class="line">    # print(&apos;SVD:\n&apos;,U,U.shape)</span><br><span class="line">    # print(&apos;s:\n&apos;,s, s.shape)</span><br><span class="line">    # print(&apos;v:\n&apos;,vT,vT.shape)</span><br><span class="line">    # print()</span><br><span class="line"></span><br><span class="line">    w = vT[-1, :]   # 取最后一行，最为最优解</span><br><span class="line">    print(&apos;w:\n&apos;,w, w.shape)</span><br><span class="line">    omega = np.array([  # 建立w矩阵</span><br><span class="line">        [w[0], 0, w[1]],</span><br><span class="line">        [0, w[0], w[2]],</span><br><span class="line">        [w[1], w[2], w[3]]</span><br><span class="line">    ], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    # 使用cholesky 分解得到K</span><br><span class="line">    kT_inv = np.linalg.cholesky(omega)  # w = (k*k.T)^-1 ==&gt; 分解为 k.T^-1</span><br><span class="line">    k = np.linalg.inv(kT_inv.T) </span><br><span class="line">    k /= k[2, 2]    # 最小化</span><br><span class="line">    return k</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>三对灭点： 需要正交</li><li>为了减小误差，可以使用超过两条以上的平行线计算灭点，然后计算这个坐标的平均值作为最终灭点；</li></ul><h2 id="2-3-计算两个平面的夹角"><a href="#2-3-计算两个平面的夹角" class="headerlink" title="2.3  计算两个平面的夹角"></a>2.3  计算两个平面的夹角</h2><ul><li>通过上面的公式，通过灭点计算灭线，然后计算角度；</li><li>【问题】<ul><li>不明白为什么通过求点的叉积来获得灭线向量，感觉没有意义啊？？</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">COMPUTE_K_FROM_VANISHING_POINTS</span><br><span class="line">Arguments:</span><br><span class="line">    vanishing_pair1 - a list of a pair of vanishing points computed from lines within the same plane</span><br><span class="line">    vanishing_pair2 - a list of another pair of vanishing points from a different plane than vanishing_pair1</span><br><span class="line">    K - the camera matrix used to take both images</span><br><span class="line"></span><br><span class="line">Returns:</span><br><span class="line">    angle - the angle in degrees between the planes which the vanishing point pair comes from2</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def compute_angle_between_planes(vanishing_pair1, vanishing_pair2, K):</span><br><span class="line">    omega_inv = K.dot(K.T)</span><br><span class="line"></span><br><span class="line">    # a set of vanishing points on one plane</span><br><span class="line">    v1 = np.hstack((vanishing_pair1[0], 1))</span><br><span class="line">    v2 = np.hstack((vanishing_pair1[1], 1))</span><br><span class="line"></span><br><span class="line">    # another set of vanishing points on the other plane</span><br><span class="line">    v3 = np.hstack((vanishing_pair2[0], 1))</span><br><span class="line">    v4 = np.hstack((vanishing_pair2[1], 1))</span><br><span class="line"></span><br><span class="line">    # find two vanishing lines</span><br><span class="line">    L1 = np.cross(v1.T, v2.T)  # 为什么如此？</span><br><span class="line">    L2 = np.cross(v3.T, v4.T)</span><br><span class="line"></span><br><span class="line">    # find the angle between planes</span><br><span class="line">    costheta = (L1.T.dot(omega_inv).dot(L2)) / (np.sqrt(L1.T.dot(omega_inv).dot(L1)) * np.sqrt(L2.T.dot(omega_inv).dot(L2)))</span><br><span class="line">    theta = (np.arccos(costheta) / math.pi) * 180</span><br><span class="line"></span><br><span class="line">    return theta</span><br></pre></td></tr></table></figure><h2 id="2-4-计算旋转矩阵"><a href="#2-4-计算旋转矩阵" class="headerlink" title="2.4 计算旋转矩阵"></a>2.4 计算旋转矩阵</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d09bf4c264e3b2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>假设相机只经过旋转，没有平移；</li><li>通过灭点求解的真实平行线的方向；</li><li>两幅图片的真实平行线是不变的，通过真实平行线的矩阵变换求得相机的旋转矩阵；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">COMPUTE_K_FROM_VANISHING_POINTS</span><br><span class="line">Arguments:</span><br><span class="line">    vanishing_points1 - a list of vanishing points in image 1</span><br><span class="line">    vanishing_points2 - a list of vanishing points in image 2</span><br><span class="line">    K - the camera matrix used to take both images</span><br><span class="line"></span><br><span class="line">Returns:</span><br><span class="line">    R - the rotation matrix between camera 1 and camera 2</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def compute_rotation_matrix_between_cameras(vanishing_points1, vanishing_points2, K):</span><br><span class="line"></span><br><span class="line">    ones = np.ones((vanishing_points1.shape[0], 1))</span><br><span class="line">    # 建立齐次矩阵</span><br><span class="line">    v1 = np.hstack((vanishing_points1, ones)).T</span><br><span class="line">    v2 = np.hstack((vanishing_points2, ones)).T</span><br><span class="line"></span><br><span class="line">    # 计算真实平行线的方向</span><br><span class="line">    # d = K^-1 * v</span><br><span class="line">    k_inv = np.linalg.inv(K)</span><br><span class="line">    D1 = k_inv.dot(v1) / np.linalg.norm(k_inv.dot(v1),axis=0)   # 按列计算norm范数</span><br><span class="line">    D2 = k_inv.dot(v2) / np.linalg.norm(k_inv.dot(v2),axis=0)</span><br><span class="line"></span><br><span class="line">    # d2 = R * d1, d2.T = d1.T * R.T</span><br><span class="line">    R = np.linalg.lstsq(D1.T, D2.T,rcond = None)[0].T</span><br><span class="line"></span><br><span class="line">    return R</span><br></pre></td></tr></table></figure><hr><blockquote><p>版权声明：<br><br>本文作者：<br>本文链接：https://jingxa.github.io/2018/06/19/cs231a-homework-1/</p></blockquote><p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/19/cs231a-homework-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客搭建记录</title>
      <link>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</link>
      <guid>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 31 May 2017 10:37:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;简单记录一下利用hexo+github搭建博客的过程&lt;/p&gt;
&lt;h4 id=&quot;主要思路&quot;&gt;&lt;a href=&quot;#主要思路&quot; class=&quot;headerlink&quot; title=&quot;主要思路&quot;&gt;&lt;/a&gt;主要思路&lt;/h4&gt;&lt;p&gt;　　安装git和node的过程就不多提了，本次安装hex
        
      
      </description>
      
      <content:encoded><![CDATA[<p>简单记录一下利用hexo+github搭建博客的过程</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>　　安装git和node的过程就不多提了，本次安装hexo博客主要采用建立GitHub pages托管，建立两个分支，一个用于提交源文件，一个用于提交hexo静态文件，如果博客需要换电脑，直接git clone下来即可</p><blockquote><p>hexo分支：博客源文件内容<br>master分支:静态博客内容</p></blockquote><h4 id="一-建立远程库"><a href="#一-建立远程库" class="headerlink" title="一 建立远程库"></a>一 建立远程库</h4><p>　　注意事项：<br>　　　　１.建立两个分支master 和hexo<br>　　　　２.将hexo分支设为默认分支，这样方便提交源文件</p><h4 id="二、下载远程库"><a href="#二、下载远程库" class="headerlink" title="二、下载远程库"></a>二、下载远程库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:jingxa/jingxa.github.io.git</span><br></pre></td></tr></table></figure><p>改成你的名字</p><h6 id="【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"><a href="#【特别注意】：先不要进行下面的步骤，先将仓库中【-git-gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交" class="headerlink" title="【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交"></a>【特别注意】：先不要进行下面的步骤，先将仓库中【.git,.gitignore】复制出来，不然下面安装hexo会将这个给覆盖掉，后面无法提交</h6><h4 id="三、开始安装hexo"><a href="#三、开始安装hexo" class="headerlink" title="三、开始安装hexo"></a>三、开始安装hexo</h4><h5 id="1、安装hexo"><a href="#1、安装hexo" class="headerlink" title="1、安装hexo"></a>1、安装hexo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h5 id="2、-初始化hexo"><a href="#2、-初始化hexo" class="headerlink" title="2、 初始化hexo"></a>2、 初始化hexo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h5 id="3、安装npm"><a href="#3、安装npm" class="headerlink" title="3、安装npm"></a>3、安装npm</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h5 id="4、-安装next主题-："><a href="#4、-安装next主题-：" class="headerlink" title="4、 安装next主题 ："></a>4、 安装next主题 ：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>【注意：在<em>.jithub.io和themes/next都有一个_config.yml的文件，为了区分。我们使用一下称呼】<br>–</em>github.io/_config.yml:站点配置文件<br>–themes/next/_config.yml:主题配置文件</p><h5 id="5-配置站点文件"><a href="#5-配置站点文件" class="headerlink" title="5.配置站点文件"></a>5.配置站点文件</h5><h6 id="【注意：每一项的填写，其-后面都要保留一个空格】"><a href="#【注意：每一项的填写，其-后面都要保留一个空格】" class="headerlink" title="【注意：每一项的填写，其:后面都要保留一个空格】"></a>【注意：每一项的填写，其:后面都要保留一个空格】</h6><p>(1).修改网站相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 你的题目</span><br><span class="line">subtitle: 小题目</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure></p><p>(2).配置统一资源定位符（个人域名）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: https://jingxa.github.io</span><br></pre></td></tr></table></figure></p><p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。<br>(3). 配置部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: ssh://git@github.com/jingxa/jingxa.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>这里我们使用ssh，不使用https,可以避免提交的时候需要输入密码验证<br>(4).主题修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes: next</span><br></pre></td></tr></table></figure></p><h5 id="6-配置主题文件"><a href="#6-配置主题文件" class="headerlink" title="6.配置主题文件"></a>6.配置主题文件</h5><p>这些大家自己百度<br><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a></p><h5 id="7-提交"><a href="#7-提交" class="headerlink" title="7.提交"></a>7.提交</h5><p>这一步大家讲源文件提交到github,托管源码，方便以后转移、<br>在提交之前，大家需要将【.gitignore】中添加一些配置，免得将一些不必要的东西提交到github上，我的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><p>将这个不必要的忽略掉<br>(1).增加文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></p><p>提交所有的文件<br>(2).可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>检查提交哪些东西<br>(3).提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;自己修改commit信息&quot;</span><br></pre></td></tr></table></figure></p><p>(4).重要的地方，我们需要将修改提交到hexo,分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>然后完成了源文件的提交，下一步就是提交hexo生成的静态文件，再次之前，需要安装依赖包</p><h5 id="8-安装npm-install-hexo-deployer-git-–save"><a href="#8-安装npm-install-hexo-deployer-git-–save" class="headerlink" title="8.安装npm install hexo-deployer-git –save"></a>8.安装npm install hexo-deployer-git –save</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>其实这一步可以在前面npm install 之后安装</p><h5 id="9-静态博客生成"><a href="#9-静态博客生成" class="headerlink" title="9.静态博客生成"></a>9.静态博客生成</h5><p>(1).我们可以写一篇文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;你的题目&quot;</span><br></pre></td></tr></table></figure></p><p>我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。<br>保存后，我们进行本地发布：<br>(2).我自己测试，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　hexo s -p 8888</span><br></pre></td></tr></table></figure></p><p>如果使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p> 会使用默认端口4000，这个一直不能再本地显示，所以我们可以自己更改端口，就能正常访问<br>(3).打开浏览器，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/</span><br></pre></td></tr></table></figure></p><p>我们可以在浏览器端看到我们搭建好的博客和发布的文章：</p><h5 id="10-博客提交到github上"><a href="#10-博客提交到github上" class="headerlink" title="10.博客提交到github上"></a>10.博客提交到github上</h5><p>(1).这一步主要是清除缓存数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>(2). 生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//hexo generate可以简写成</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><p>(3). 发布<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//hexo deploy可以简写成 </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>然后访问你的默认网站。就可以看到你的成果了！</p><hr><blockquote><p>版权声明：<br><br>本文作者：<br>本文链接：https://jingxa.github.io/2017/05/31/hexo博客搭建记录/</p></blockquote><p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2017/05/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
