<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sat, 07 Jul 2018 10:10:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>STL_关联式容器_map</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:35 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>map的元素都是pair</li><li>map 不允许两个元素拥有相同的键值；</li></ul><h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h1><pre><code>template&lt; class T1, class T2&gt;struct pair{    typedef T1 first_type;    typedef T2 seconde_type;    T1 first;    T2 second;    pair():first(T1()),second(T2()){}    pair(const T1&amp; a, const T2&amp; b):first(a), second(b){}};template&lt;class Key, class T,        class Compare = less&lt;Key&gt;,        class Alloc = alloc&gt;class map{public:    typedef    Key key_type;      typedef    T data_type;    typedef T mapped_type;    typedef pair&lt;const Key, T&gt; value_type;  // 元素型别    typedef    Compare key_compare;    // 比较函数    class value_compare: binary_function&lt;value_type, value_type,bool&gt;{        friend class  map&lt;Key,T, Compare, Alloc&gt;;        protected:            Compare comp;            value_compare(Compare c):comp(c){}        public:            bool operator()(const value_type&amp; x, const value_type&amp; y) const{                return comp(x.first, y.first);            }    };private:    rep_type t;public:    typedef     typename  rep_type::pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // 构造函数    map():t(Compare()){}    explicit map(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_unique(first,last);    }    map(const map&lt;Key,T, Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    map&lt;Key,T, Compare,Alloc&gt;&amp; operator=(const map&lt;Key,T,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // 访问器    key_compare key_comp() const(return t.key_comp(););    value_compare value_comp() const{return value_compare(t.key_comp());}    iterator begin() {return t.begin();}    const_iterator begin()const{return t.begin();}    iterator end() {return t.begin();}    const_iterator end() const{return t.end();}    reverse_iterator rbegin() {return t.rbegin();}    const_reverse_iterator rbegin() const {return t.rbegin();}    reverse_iterator rend() {return t.rend();}    const_reverse_iterator rend() const{return t.rend();}    bool empty() const {return t.empty();}    size_type size() const{return t.size();}    size_type max_size() const{return t.max_size();}    T&amp; operator[](const key_type&amp; k){        return(*((insert(value_type(k,T()))).first)).second;    }    void swap(map&lt;Key,T,Compare,Alloc&gt;&amp; x){t.swap(x.t);}    // 插入。删除    // 插入、 删除操作    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        return t.insert_unique(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_unique(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        t.erase(position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    iterator find(const key_type&amp; x) {return t.find(x);}        const_iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x){        return t.equal_range(x);    }    pair&lt;const_iterator,const_iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const map&amp;, const map&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt map&amp;, const map&amp;);};template&lt;class Key, class T, class Compare, class Alloc&gt;inline bool operator==(const map&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T, Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key,class T, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,T,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,T,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="3-multimap"><a href="#3-multimap" class="headerlink" title="3 multimap"></a>3 multimap</h1><pre><code>/**    multimap*/template&lt;class Key,class T,class Compare= less&lt;Key&gt;            class Alloc = alloc&gt;class multimap{public:    // typedefs     ...  // 和set一样    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last):t(Compare()){        t.insert_equal(first,last);    }    template&lt;class InputIterator&gt;    map(InputIterator first, InputIterator last, const Compare&amp; comp):t(comp){        t.insert_equal(first,last);    }    ...// 和set一样    // insert    insert insert(const value_type&amp; x){        return t.insert_equal(x);    }    iterator insert(iterator position, const value_type&amp; x){        return t.insert_equal(position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_equal(first, last);    }    ... // 其他和map一样};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-map/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_关联式容器_set</title>
      <link>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</link>
      <guid>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</guid>
      <pubDate>Sat, 07 Jul 2018 10:08:21 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第五章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第五章</p></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>set 所有元素根据元素的键值自动被排序</li><li>set的键值和实值都是同样的；</li><li>不允许两个元素有相同的键值；</li><li>set<t>::iterator为const_iterator</t></li><li>Rb_tree作为底层；</li></ul><h1 id="1-set"><a href="#1-set" class="headerlink" title="1. set"></a>1. set</h1><pre><code>/**    set源码摘录*/template&lt;class Key,         class Compare = less &lt;Key&gt;,   // 缺省下采用递增排序        class Alloc = alloc&gt;class set{public:    typedef Key    key_type;    typedef    Key    value_type;    typedef Compare    key_compare;    typedef    Compare    value_compare;private:// 以下 identity 定义于&lt;stl_function.h&gt;    /*    template&lt; class T&gt;    struct identity:public unary_function&lt;T, T&gt;{        const T&amp; operator()(const T&amp; x){return x;}    };    */    typedef    rb_tree&lt;key_type, value_type,identity&lt;value_type&gt;,key_compare,Alloc&gt; rep_type;    rep_type t;  // 采用红黑树表示setpublic:    typedef     typename  rep_type::const_pointer pointer;    typedef     typename  rep_type::const_pointer const_pointer;    typedef     typename  rep_type::const_reference reference;    typedef     typename  rep_type::const_reference const_reference;    typedef     typename  rep_type::const_iterator  iterator;    // 以上iterator定义为const，表示不允许用户执行写入操作    typedef     typename  rep_type::const_iterator    const_iterator;    typedef     typename  rep_type::const_reverse_iterator reverse_iterator;    typedef  typename  rep_type::const_reverse_iterator const_reverse_iterator;    typedef     typename  rep_type::size_type    size_type;    typedef     typename  rep_type::difference_type  difference_type;    // aollocattion // deallocation    // set 使用rb_tree 的insert_unique()    // multiset 使用 rb_tree的insert_equal()    set():t(Compare()){}    explicit set(const Compare&amp; comp):t(comp){}    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last):t(Compare())    {        t.insert_unique(first,last);    }    template&lt;class InputIterator&gt;    set(InputIterator first, InputIterator last, const Compare&amp; comp)        :t(comp){            t.insert_unique(first,last);        }    set(const set&lt;Key,Compare,Alloc&gt;&amp; x):t(x.t){}    // 赋值符    set&lt;Key, Compare,Alloc&gt;&amp; operator=(const set&lt;Key,Compare,Alloc&gt;&amp; x){        t = x.t;        return *this;    }    // set 操作    key_compare key_comp() const{return t.key_comp();}    value_compare value_comp() const{{return t.key_comp();}    iterator begin() const{return t.begin();}    iterator end()    const{return t.end();}    reverse_iterator rbegin() const{retur t.rbegin();}    reverse_iterator rend() const{return t.rend();}    bool empty() const{return t.empty();}    size_type size() const {return t.size();}    size_type max_size() const{return t.max_size();}    void swap(set&lt;Key,Compare,Alloc&gt;&amp;x){t.swap(x.t);}    // 插入、 删除操作    typedef pair&lt;iterator,bool&gt; pair_iterator_bool;    pair&lt;iterator,bool&gt; insert(const value_type&amp; x){        pair&lt;typename rep_type::iterator,bool&gt; p = t.insert_unique(x);        return pair&lt;iterator,bool&gt;(p.first,p.last);    }    iterator insert(iterator position, const value_type&amp; x){        typedef typename rep_type::iterator rep_iterator;        return t.insert_unique((rep_iterator&amp;)position,x);    }    template&lt;class InputIterator&gt;    void insert(InputIterator first, InputIterator last){        t.insert_unique(first, last);    }    void erase(iterator position){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)position);    }    size_type erase(const key_type&amp; x){        return t.erase(x);    }    void erase(iterator first, iterator last){        typedef typename rep_type::iterator rep_iterator;        t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);    }    void clear(){        t.clear();    }    // set 操作    iterator find(const key_type&amp; x) const{return t.find(x);}    size_type count(const key_type&amp; x)const{return t.count(x);}    iterator lower_bound(const key_type&amp; x)const{        return t.lower_bound(x);    }    iterator upper_bound(const key_type&amp; x)const{        return t.upper_bound(x);    }    pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x)const{        return t.equal_range(x);    }    // 以下的 __STL_NULL_TMPL_ARGS 被定义为&lt;&gt;    friend bool operator==__STL_NULL_TMPL_ARGS(const set&amp;, const set&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(cosnt set&amp;, const set&amp;);};template&lt;class Key, class Compare, class Alloc&gt;inline bool operator==(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t == y.t;                        }template&lt;class Key, class Compare, class Alloc&gt;inline bool operator&lt;(const set&lt;Key,Compare,Alloc&gt;&amp; x,                        const set&lt;Key,Compare,Alloc&gt;&amp; y){    return x.t &lt; y.t;                        }</code></pre><h1 id="2-multiset"><a href="#2-multiset" class="headerlink" title="2 multiset"></a>2 multiset</h1><p><code>`</code><br>/*<em><br>    multiset</em>/</p><p>// set 不同之处<br>template&lt;class Key, class Compare = less<key>, class Alloc= alloc&gt;<br>class multiset{</key></p><p>public:<br>// typedefs<br>… // 一样和set</p><p>//构造函数</p><pre><code>template&lt;class InputIterator&gt;multiset(InputIterator first,InputIterator last):t(Compare()){    t.insert_equal(first,last);}template&lt;class InputIterator&gt;multiset(InputIterator first, InputIterator last, Compare&amp; comp):t(comp){    t.insert_equal(first,last);}...   // 与 set一样// 插入删除iterator insert(const value_type&amp; x){    return t.insert_equal(x);}iterator insert(iterator position, const value_type&amp; x){    typedef typename rep_type::iterator rep_iterator;    return t.insert_equal((rep_iterator&amp;)position,x);}template&lt;class InputIterator&gt;void insert(InputIterator first, InputIterator last){    t.insert_equal(first,last);}... // 其他和set一样</code></pre><p>};</p><p>···</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/07/STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_非标准_slist</title>
      <link>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:42 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;STL list是一个双向链表&lt;/li&gt;
&lt;li&gt;slist不在STL标准中，是一个单向链表；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;差别：&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>STL list是一个双向链表</li><li>slist不在STL标准中，是一个单向链表；</li></ul><p>差别：</p><ul><li>slist 的迭代器是单向的ForwardIterator</li><li>list的迭代器是 双向的BidrectionalIterator</li></ul><p>共同特点：</p><ul><li>插入，移除，接合不会造成原有迭代器失效</li></ul><h1 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c69d236d1d012e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>// 节点struct __slist_node_base{    __slist_node_base* next;};// 节点结构template&lt;class T&gt;struct __slist_node : public __slist_node_base{    T data;};// 全局函数// 已知道某一节点， 插入新节点于其后inline __slist_node_base* __slist_make_link(            __slist_node_base* prev_node,                __slist_node_base* new_node){    // 令new节点的下一个节点为prev节点的下一个节点    new_node-&gt;next = prev_node-&gt;next;    prev_node-&gt;next = new_node;  // prev指向new节点    return new_node;}// 全局函数 单向链表的大小inline size_t __slist_size(__slist_node_base* node){    size_t result = 0;    for(;node !=0; node = node-&gt;next)        ++result;    return result;}</code></pre><h1 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2d9e4831ec4892b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>/**    slist的迭代器*/struct __slist_iterator_base{    typedef size_t size_type;    typedef    ptrdiff_t difference_type;    typedef forward_iterator_tag  iterator_category;  // 单向链表的大小    __slist_node_base* node;  // 指向节点基本结构    __slist_node_base(__slist_node_base* x):node(x){}    void incr(){        node = node -&gt;next;  // 前进一个节点    }    bool operator== (const __slist_iterator_base&amp; x) const{        return node == x.node;    }    bool operator!= (const __slist_iterator_base&amp; x) const{        return node != x.node;    }};// 单向链表的迭代器结构template&lt;class T, class Ref , class Ptr&gt;struct _slist_iterator: public __slist_iterator_base{    typedef __slist_iterator&lt;T,T&amp;,T*&gt;                 iterator;    typedef __slist_iterator&lt;T,const T&amp;, const T*&gt;   const_iterator;    typedef __slist_iterator&lt;T,Ref,Ptr&gt;                self;    typedef T                                        value_type;    typedef Ptr                                        pointer;    typedef    Ref                                        reference;    typedef    __slist_node&lt;T&gt;                         list_node;    __slist_iterator(list_node&amp; x):__slist_iterator_base(x){}    // 调用slist&lt;T&gt;::end()会造成 __slist_iterator_base(0)    __slist_iterator():__slist_iterator_base(0){}    __slist_iterator(const iterator&amp; x):__slist_iterator_base(x.node){}    reference operator*()const{ return ((list_node*)node)-&gt;data;}    pointer  operator-&gt;() const{ return &amp;((operator*());}    self&amp; operator++(){        incr();        return *this;    }    self operator++(int){        self tmp = *this;        incr();        return tmp;    }    // 没有实现operator-- ,因为这是一个forward iterator};</code></pre><h1 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h1><pre><code>/**    slist 数据结构*/template&lt;class T, class Alloc = alloc&gt;class slist{public:    typedef T                            value_type;    typedef value_type*                    pointer;    typedef    const value_type*            const_pointer;    typedef    value_type&amp;                 reference;    typedef    const value_type&amp;            const_reference;    typedef size_t                        size_type;    typedef    ptrdiff_t                    difference_type;    typedef    __slist_iterator&lt;T,T&amp;,T*&gt;    iterator;    typedef    __slist_iterator&lt;T,const T&amp;, const T*&gt;    const_iterator;private:    typedef    __slist_node&lt;T&gt;        list_node;    typedef    __slist_node_base   list_node_base;    typedef    __slist_iterator_base    iterator_base;    typedef    simple_alloc&lt;list_node, Alloc&gt;  list_node_allocator;    static list_node* create_node(const value_type&amp; x){        list_node* node = list_node_allocator::allocate(); // 配置一个节点        __STL_TRY{            construct(&amp;node-&gt;data,x);            node-&gt;next = 0;        }        __STL_UNWIND(list_node_allocator::deallocate(node)):        return node;    }    static void destroy_node(list_node* node){        destroy(&amp;node-&gt;data);   // 析构元素        list_node_allocator::deallocate(node);  // 释放空间    }private:    list_node_base     head;   // 头部，不是指针，是对象public:    slist(){head.next =0;}    ~slist(){clear();}public:    // 基本操作    iterator begin(){return iterator((list_node*)head.next);}    iterator end() {return iterator(0);}    size_type size()const{return __slist_size(head.next);}    bool empty() const {return head.next == 0;}    // 两个slist互换    void swap(slist&amp; L){        list_node_base * tmp = head.next;        head.next = L.head.next;        L.head.next = tmp;    }public:    // 取头部元素    reference front(){return ((list_node*)head.next)-&gt;data;}    // 从头部插入元素    void push_front(const value_type&amp; x){        __slist_make_link(&amp;head, create_node(x));    }    // 从头部取走元素；    void pop_front(){        list_node* node = (list_node*) head.next;        head.next = node-&gt;next;        destroy_node(node);    }    ...};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-%E9%9D%9E%E6%A0%87%E5%87%86-slist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_heap</title>
      <link>https://jingxa.github.io/2018/07/05/STL-heap/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-heap/</guid>
      <pubDate>Thu, 05 Jul 2018 13:44:16 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><ul><li>heap不归属于STL容器组件，扮演priority-quque的助手，即priority queue的底层；</li></ul><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-binary-heap"><a href="#1-1-binary-heap" class="headerlink" title="1.1 binary heap"></a>1.1 binary heap</h2><ul><li>一种 complete binary tree (完全二叉树)的存储方式</li><li>使用vector作为存储空间</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-00622adba11ef4f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-heap的隐式表述法-implicit-representation"><a href="#1-2-heap的隐式表述法-implicit-representation" class="headerlink" title="1.2 heap的隐式表述法(implicit representation)"></a>1.2 heap的隐式表述法(implicit representation)</h2><ul><li>将数组的#0元素保留</li><li>那么在数组中，位于数组i处的节点的左子节点为2i，右子节点为(2*i +1)<br>-【SGI STL 并未使用这个方法】</li></ul><h2 id="1-3-max-heap"><a href="#1-3-max-heap" class="headerlink" title="1.3 max-heap"></a>1.3 max-heap</h2><ul><li>STL实现的是大根堆</li></ul><h1 id="2-heap算法"><a href="#2-heap算法" class="headerlink" title="2 heap算法"></a>2 heap算法</h1><h2 id="2-1-push-heap-算法"><a href="#2-1-push-heap-算法" class="headerlink" title="2.1 push_heap 算法"></a>2.1 push_heap 算法</h2><ul><li>新加入的元素位于最下一层作为叶节点，也就是插入到vector的end()处；</li><li>通过和父节点进行比较，如果值比父节点大，就父子对换位置，一直上溯，直到不需要对换或者到根节点为止；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58668b0e78d9e076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>push_heap</li></ul><pre><code>// push_heaptemplate&lt;class RandomAccessIterator&gt;inline void push_heap(RandomAccessIterator first, RandomAccessIterator last){    // 此函数调用的时候 新元素已经置于容器底部    __push_heap_aux(first,last,distance_type(first),value_type(first));}</code></pre><ul><li>使用<strong>push_heap_aux 和 </strong>push_heap作为内部函数；</li></ul><pre><code>template&lt;class RandomAccessIterator, class Distance, class T&gt;inline void __push_heap_aux(RandomAccessIterator first,                RandomAccessIterator last, Distance*, T*){    // 新值在容器最尾端，位置： （last -first）-1    // 隐式表述法 ,根节点编号从0开始    __push_heap(first, Distance(last - first)-1, Distance(0), T(*(last -1)));}// 一下这组push_back()不允许指定&#39;大小比较标准&#39;template&lt;class RandomAccessIterator, class Distance, class T&gt;void __push_heap(RandomAccessIterator first, Distance holeIndex,             Distance topIndex, T value){    Distance parent = (holeIndex -1) /2; // 找出父节点    while(holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value){  // 大根堆调整        // 尚未到达顶端并且父节点小于新值        *(first + holeIndex) = *(first + parent); // 令洞位置为父节点        holeIndex = parent; // 调整洞号， 向上提升        parent = (holeIndex - 1) /2;   // 新父节点        }   // 调整完成    *(first + holeIndex) = value;  // 赋值}</code></pre><h2 id="2-2-pop-heap算法"><a href="#2-2-pop-heap算法" class="headerlink" title="2.2 pop_heap算法"></a>2.2 pop_heap算法</h2><ul><li>先将根节点和最下一层的最右边的叶节点对换位置；然后调整除了最后一个节点的vector的first,last-1]的堆；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f729a93c0e6b8d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>pop_heap</li></ul><pre><code>/**    pop_heap    1. 取走根节点    2. 满足完全二叉树的条件，将最下一层的最右边的叶节点拿掉*/template&lt;class RandomAccessIterator&gt;inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last){    __pop_heap_aux(first, last, value_type(first));}</code></pre><ul><li>使用了__pop_heap_aux作为内部函数：</li></ul><pre><code>// 根据隐式表述法， pop操作的结果为底部容器的第一个元素// 首先将首值和尾节点互换，然后重新调整[first, last -1)template&lt;class RandomAccessIterator , class T&gt;inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last,                            T*){    __pop_heap(first,last-1, last-1, T(*(last - 1), distance_type(first));                            }template&lt;class RandomAccessIterator, class T, class Distance&gt;inline void __pop_heap(RandomAccessIterator first,                         RandomAccessIterator last,                        RandomAccessIterator result,                         T value, Distance*){    *result = * first;   // 设定尾值为首值                          //然后后面可以由容器pop_back()取出    // 重新调整heap    __adjust_heap(first,Distance(0), Distance(last -first), value);}</code></pre><ul><li>heap的调整算法：<code>__adjust_heap</code><br><code>`</code></li></ul><p>template<class randomaccessiterator,="" class="" distance,="" t=""><br>void __adjust_heap(RandomAccessIterator first, Distance holeIndex,<br>                    Distance len, T value){</class></p><pre><code>Distance topIndex = holeIndex; Distance secondChild = 2*holeIndex +2;  // 洞节点的右子节点while(secondChild &lt; len){    // 比较洞节点的两个子节点， 然后secondChild代替较大子节点    if(*(first + secondChild) &lt; *(first(secondChild -1))){        secondChild --;    }    *(first + holeIndex ) = *(first + secondChild);  // 替换父节点和子节点    holeIndex = secondChild;    secondChild = 2*(secondChild +1);  // 下一层}if(secondChild == len){  // 没有右子节点 ，只有左节点    // 令左子值为洞值，在令洞号移动左子节点处    *(first + holeIndex ) = *(first +(secondChild -1));    holeIndex = secondChild -1;}// 将要调整的洞号填入目前的洞号，// 此时已经满足次序性// 可直接为*（first + holeIndex) = value;__push_heap(first, holeIndex, topIndex,value);</code></pre><p>}</p><pre><code>## 2.3 sort_heap 算法- pop_heap每次将最大元素放到尾端，那么通过持续调用pop_heap算法就可以得到逆序序列；</code></pre><p>/**<br>    sort_heap</p><pre><code>1. pop_heap 每次取出一个最大值，持续pop，可得逆序序列；</code></pre><p>*/</p><p>template<class randomaccessiterator=""><br>void sort_heap(RandomAccessIterator first,<br>                RandomAccessIterator last){<br>    // 没执行一次pop_heap(),极值放在尾端<br>    while(last - first &gt;1){<br>        pop_heap(first,last–); // 执行一次，操作范围缩小一点<br>    }<br>}</class></p><pre><code>## 2.4 make_heap算法- 将一段现有数据转化一个heap</code></pre><p>/*<em><br>    make_heap: 将一段数据转化为堆</em>/<br>template<clss randomaccessiterator=""><br>inline void make_heap(RandomAccessIterator first, RandomAccessIterator last){<br>    __make_heap(first,last, value_type(first),distance_type(first));<br>}</clss></p><p>template<class randomaccessiterator,="" class="" t,="" distance=""><br>void __make_heap(RandomAccessIterator first,<br>                RandomAccessIterator    last, T<em>, Distance</em>)<br>{<br>    if(last - first &lt; 2) return ; // 长度0或1 不用重新排列<br>    Distance len = last - first;</class></p><pre><code>// 找出第一个需要重新排列的子树头部，以parent标出，Distance parent = (len -2 ) /2;while(true){    // 重新排列parent为首的子树，len为了让__adjust_heap()判断操作范围    __adjust_heap(first,parent,len,T(*(first+parent)));    if(parent == 0) return ; // 走完根节点就结束；    parent --; // 重排子树的头部向前一个节点；}</code></pre><p>}<br><code>`</code></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-heap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STL_适配器</title>
      <link>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <guid>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <pubDate>Thu, 05 Jul 2018 13:43:51 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文章内容来源于《STL源码分析》第四章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-适配器-（adapter）&quot;&gt;&lt;a href=&quot;#1-适配器-（adapter）&quot; class=&quot;headerlink&quot; title=&quot;1 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文章内容来源于《STL源码分析》第四章</p></blockquote><hr><h1 id="1-适配器-（adapter）"><a href="#1-适配器-（adapter）" class="headerlink" title="1 适配器 （adapter）"></a>1 适配器 （adapter）</h1><ul><li>“修改某物接口，形成另一个风貌者”的性质，称为adapter；</li></ul><p>STL的适配器：</p><ul><li>stack</li><li>queue</li></ul><h1 id="2-stack"><a href="#2-stack" class="headerlink" title="2 stack"></a>2 stack</h1><ul><li>以deque或者 list作为底层容器</li><li>先进后出</li><li>stack没有迭代器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f525a94e3884b2a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>emplate&lt;class T, Sequence = deque&lt;T&gt;&gt;class stack{    // __STL_NULL_TMPL_ARGS 展开为&lt;&gt;    friend bool operator== __STL_NULL_TMPL_ARGS(const stack&amp;, const stack&amp;);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(const stack&amp;, const stack&amp;);public:    typedef typename Sequence::value_type value_type;    typedef typename Sequence:size_type     size_type;    typedef typename Sequence::reference    reference;    typedef    typename Sequence::const_reference    const_reference;protected:    Sequence c;  // 底层容器public:    // 一下完全利用Sequence c 的操作，完成stack的操作    bool empty()const{return c.empty();}    size_type    size() const{return c.size();}    reference top(){returnc.back();}    const_reference top() const{return c.back();}    // stack末端进，末端出    void push(const value_type&amp; x){c.push_back(x);}    void pop(){c.pop_back();}};template&lt;class T, class Sequence&gt;bool operator==(const stack&lt;T,Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){    return x.c = y.c;}template&lt;class T ,class Sequence&gt;bool operator&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){    return x.c &lt; y.c;}</code></pre><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3 queue"></a>3 queue</h1><ul><li>以deque或者list作为底层容器</li><li>先进先出的结构</li><li>不允许有遍历行为，没有迭代器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c3723b2ba1434db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>/**    queue: 先进先出    1. 不允许遍历    2. deque作为底层容器*/template&lt;class T, class Sequence = deque&lt;T&gt; &gt;class queue{    // __STL_NULL_TMPL_ARGS展开为&lt;&gt;    friend bool operator== __STL_NULL_TMPL_ARGS(const queue&amp; x, const queue&amp; y);    friend bool operator&lt; __STL_NULL_TMPL_ARGS(const queue&amp; x, const queue&amp; y);public:    typedef typename    Sequence::value_type    value_type;    typedef    typename    Sequence::size_type        size_type;    typedef    typename    Sequence::reference        reference;    typedef    typename    Sequence::const_reference    const_reference;protected:    Sequence c;  // 底层容器public:    bool empty() const{return c.empty();}    size_type size() const{return c.size();}    reference front(){return c.front();}    const_reference front() const{return c.front();}    reference back(){return c.back();}    const_reference back(){return c.back();}    // queue 末端进，前端出    void push(const value_type&amp; x){c.push_back(x);}    void pop(){c.pop_front();}};template&lt;class T, class Sequence&gt;bool operator==(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T,Sequence&gt;&amp; y){    return x.c == y.c;}template&lt;class T, class Sequence&gt;bool operator,(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T,Sequence&gt;&amp; y){    return x.c , y.c;}</code></pre><h1 id="4-priority-queue"><a href="#4-priority-queue" class="headerlink" title="4 priority_queue"></a>4 priority_queue</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h2><ul><li>带有权值观念的queue;</li><li>按照权值排列；</li><li>缺省情况下priority_queue利用max_heap完成；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a4a3bd8124fc1325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-2-定义"><a href="#4-2-定义" class="headerlink" title="4.2 定义"></a>4.2 定义</h2><ul><li>priority_queue内部以vector为底层容器；</li><li>使用泛型算法<code>push_heap</code>、<code>pop_heap</code>  、<code>mmake_heap</code>；</li></ul><pre><code>template&lt;class T, class Sequence = vector&lt;T&gt;,     class Compare = less&lt;typename Sequence::value_type&gt; &gt;class priority_queue{public:    typedef typename Sequence::value_type  value_type;    typedef typename Sequence::size_type     size_type;    typedef    typename Sequence::reference    reference;    typedef    typename Sequence::const_reference    const_reference;protected:    Sequence c; // 底层容器    Compare    comp;  // 元素比较器pubic:priority_queue(): c(){}explicit priority_queue(const Compar&amp; x):c(),comp(x){}    // 一下用到 make_heap()，push_heap(),pop_heap()都是泛型算法    // 注意，任一个构造函数都立刻于底层容器内产生一个隐式表述法的heap    template&lt;class InputIterator&gt;    priority_queue(InputIterator first, InputIterator last,    const Compar&amp; x):c(first,last), comp(x){        make_heap(c.begin(),c.end(),comp);    }    template&lt;class InputIterator&gt;    priority_queue(InputIterator first, InputIterator last)        :c(first,last){            make_heap(c.begin(),c.end(),comp);        }    bool empty() const{return c.empty();}    size_type size() const{return c.size();}    const_reference top() const{return c.front();}    void push(const value_type&amp; x){        __STL_TRY{            // push_heap 是泛型算法，先利用底层容器的push_back()将xnyrsu            // 推入末端，在重排heap            c.push_back(x);            push_heap(c.begin(),c.end(),comp);  // push_heap 是泛型算法        }        __STL_UNWIND(c.clear())；    }    void pop(){        __STL_TRY{            // pop_heap 是泛型算法， 从heap内取出一个元素，它并不是真正将            // 元素弹出，而是重排heap,然后再以底层容器pop_back()取得被弹出的元素            pop_heap(c.begin(),c.end(),comp);            c.pop_back();        }        __STL_UNWIND(c.clear());    }};</code></pre><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/07/05/STL-%E9%80%82%E9%85%8D%E5%99%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
