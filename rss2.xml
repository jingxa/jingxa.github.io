<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jingxa&#39;s Blog</title>
    <link>https://jingxa.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>单影无人相依偎！</description>
    <pubDate>Sat, 23 Jun 2018 09:47:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CS231A-Homework-2.1</title>
      <link>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</link>
      <guid>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/</guid>
      <pubDate>Sat, 23 Jun 2018 09:35:13 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A-Homework-2:ps-code2-part-1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、-从对应点估计基础矩阵&quot;&gt;&lt;a href=&quot;#一、-从对应点估计基础矩阵&quot; class=&quot;headerlink&quot; title
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A-Homework-2:ps-code2-part-1</p></blockquote><h1 id="一、-从对应点估计基础矩阵"><a href="#一、-从对应点估计基础矩阵" class="headerlink" title="一、 从对应点估计基础矩阵"></a>一、 从对应点估计基础矩阵</h1><ul><li><p>本题要求从对应点估计基础矩阵，使用二种方法：</p><ul><li>线性最小二乘法的八点算法</li><li>归一化八点算法</li></ul></li><li><p>笔记：</p><ul><li><a href="https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/">对极几何</a><h2 id="1-1-八点算法–-基础矩阵求解过程"><a href="#1-1-八点算法–-基础矩阵求解过程" class="headerlink" title="1.1 八点算法– 基础矩阵求解过程"></a>1.1 八点算法– 基础矩阵求解过程</h2></li></ul></li><li><p>给予两张图片，没有相机内外参数；</p></li><li><p>求出基本矩阵</p></li><li><p>方法： ‘<em>Eight-Point 算法</em> ‘</p></li></ul><hr><ol><li>至少8对 对应点</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-750407be55d3a189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>则每队对对应点满足：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-39605f51776577d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>即：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b2ab3e15ad77b5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>展开，可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-321f94cfacb01aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于所有对应点，使用一下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c3ec40ba81b3477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>简写为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5766d9a159915312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>W ： N*9 矩阵 ， N: 对应对的数量</li><li>f: 基本矩阵</li></ul><hr><ul><li>使用svd分解</li><li>w: 非满秩的</li><li>f: 真实的基本矩阵秩为2 </li><li>#<a href="https://blog.csdn.net/kokerf/article/details/72630863?locationNum=2&amp;fps=1" target="_blank" rel="noopener">基本矩阵的基本解法之8点算法</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-67d92e80c6b464f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这里进行了两次SVD分解；</li><li>首先获得F矩阵的近似；</li><li>第二次获得RANK为2的F;</li></ul><pre><code class="python"># points1, points2 都是np.arraydef lls_eight_point_alg(points1, points2):    len = points1.shape[0]    W = np.zeros((len, 9))   # 37 * 9 齐次矩阵    for i in range(len):        u1 = points1[i, 0]        v1 = points1[i, 1]        u2 = points2[i, 0]        v2 = points2[i, 1]        W[i] = np.r_[u1*u2, u2*v1, u2, v2*u1, v1*v2, v2, u1, v1, 1]    # SVD    U, S, VT = np.linalg.svd(W, full_matrices=True)    f = VT[-1, :]   # 最后一行为最优解    F_hat = np.reshape(f, (3, 3))    # 最小二乘的近似    # 计算rank =2 的F    U, S_hat, VT = np.linalg.svd(F_hat, full_matrices=True)    s = np.zeros((3, 3))   # sigma 矩阵    s[0, 0] = S_hat[0]    s[1, 1] = S_hat[1]  # sigma 的Rank为2    F = np.dot(U, np.dot(s, VT))    return F</code></pre><h2 id="2-归一化八点算法"><a href="#2-归一化八点算法" class="headerlink" title="2. 归一化八点算法"></a>2. 归一化八点算法</h2><p>标准的8点算法存在的问题：</p><ul><li>p点， 和通过基本矩阵将点p’映射到的极线上l= Fp’，两者的距离很大；点和极线之间的均值误差如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-091b3647c850b792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>8个对应点组成的矩阵W： 最好只有一个奇异值为0或者近似为0,其他的都为非零；这样能够使得svd效果好；</li><li>像素值的范围过大；如pi = (1832; 1023;)</li></ul><hr><p>解决方法：</p><ul><li>归一化像素点<ul><li><ol><li>新坐标系的原点应该位于图像点的质心处（平移）；<br>表示为：</li></ol></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6349e1ccc32f9d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>其次，变换后的图像点距原点的均方距离应为2像素（缩放）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a06c93ec30ac32aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图所示，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-446adabfc4846b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后用新坐标系下的图像应用8点算法计算出Fq；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97bf6c2a7e7c0064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后通过反归一化，获得真实的基本矩阵；</p><hr><p>整个算法分为三个步骤：</p><ul><li>归一化，对每个点进行缩放</li><li>八点算法计算Fq,</li><li>反归一化</li></ul><p>(1) 归一化： 先平移到新坐标系，在缩放<br><img src="http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%20%26s_%7Bx%7D%20%260%20%26s_%7Bx%7Dt_%7Bx%7D%5C%5C%20%260%20%26s_%7By%7D%20%26s_%7By%7Dt_%7By%7D%5C%5C%20%260%20%260%20%261%20%5Cend%7Bbmatrix%7D%20*%20%5Cbegin%7Bbmatrix%7D%20x%5C%5C%20y%5C%5C%201%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20s_%7Bx%7D%28x&plus;t_%7Bx%7D%29%5C%5C%20s_%7By%7D%28y&plus;t_%7By%7D%29%5C%5C%201%20%5Cend%7Bbmatrix%7D" alt=""></p><p>其中，缩放系数为：<br><img src="http://latex.codecogs.com/gif.latex?%5Csqrt%7B2/%28%5Csum_%7Bi%3D0%7D%5E%7Bn%7D%28x_%7Bi%7D%20-%20%5Coverline%7Bx%7D%29%5E%7B2%7D%20/%20N%29%20%7D" alt=""></p><p>代码为：</p><pre><code class="python">def normalized_eight_point_alg(points1, points2):    N = points1.shape[0]    points1_uv = points1[:, 0:2]    points2_uv = points2[:, 0:2]    # 取x,y 坐标    #    # 取坐标均值    points1_mean = np.mean(points1_uv, axis=0)    points2_mean = np.mean(points2_uv, axis=0)    # 点集的到中心的差    points1_new = points1_uv - points1_mean    points2_new = points2_uv - points2_mean    # 计算缩放参数    scale = np.sqrt(np.sum(points1_new**2)/N)    scale1 = np.sqrt(2 / (np.sum(points1_new**2)/N * 1.0))    scale2 = np.sqrt(2 / (np.sum(points2_new**2)/N * 1.0))    # 归一化矩阵    T1 = np.array([        [scale1, 0, -points1_mean[0] * scale1],        [0, scale1, -points1_mean[1] * scale2],        [0, 0, 1]    ])    T2 = np.array([        [scale2, 0, -points1_mean[0] * scale1],        [0, scale2, -points1_mean[1] * scale2],        [0, 0, 1]    ])    # 对坐标点变换    q1 = T1.dot(points1.T).T    # N * 3    q2 = T2.dot(points2.T).T    # N * 3    # 八点算法    Fq = lls_eight_point_alg(q1, q2)    #反归一化    F = T2.T.dot(Fq).dot(T1)    return F</code></pre><h2 id="3-计算平均距离"><a href="#3-计算平均距离" class="headerlink" title="3. 计算平均距离"></a>3. 计算平均距离</h2><ul><li>通过公式将p2的点映射成为p1面上的一条直线—极线</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-47c66c9adca14dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>可以通过点到直线的距离公式计算平均距离：</li></ul><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=930595087,3467127615&amp;fm=58" alt=""></p><p>代码为：</p><pre><code class="python">def compute_distance_to_epipolar_lines(points1, points2, F):    # F.Tp2 = l, 求得p2到p1面上的映射直线    line = F.T.dot(points2.T)  # 3 * N    dis_sum = 0    N = points1.shape[0]    for i in range(N):        x = points1[i, 0]        y = points1[i, 1]        A = line[0, i]        B = line[1, i]        C = line[2, i]        dis_sum += np.abs(A*x + B*y + C) / np.sqrt(A**2 + B**2)    return dis_sum / N      # 平均距离</code></pre><h2 id="4-画出极线"><a href="#4-画出极线" class="headerlink" title="4. 画出极线"></a>4. 画出极线</h2><pre><code class="python">def plot_epipolar_lines_on_images(points1, points2, im1, im2, F):    plt.subplot(1, 2, 1)  # 建立1*2 的图    line1 = F.T.dot(points2.T)   # p2到p1面上的极线    N1 = line1.shape[1]     # 极线的数量    for i in range(N1):        plt.plot([0, im1.shape[1]],                 [-line1[2][i] * 1.0 / line1[1][i], -(line1[2][i] + line1[0][i] * im1.shape[1]) * 1.0 / line1[1][i]], &#39;r&#39;)        plt.plot([points1[i][0]], [points1[i][1]], &#39;b*&#39;)    plt.imshow(im1, cmap=&#39;gray&#39;)    plt.subplot(1, 2, 2)    line2 = F.dot(points1.T)    N2 = line2.shape[1]    for i in range(N2):        plt.plot([0, im2.shape[1]], [-line2[2][i] * 1.0 / line2[1][i], -(line2[2][i] + line2[0][i] * im2.shape[1]) / line2[1][i]],                 &#39;r&#39;)        plt.plot([points2[i][0]], [points2[i][1]], &#39;b*&#39;)    plt.imshow(im2, cmap=&#39;gray&#39;)</code></pre><p>结果为：</p><pre><code>Set: data/set1--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[ 1.55218081e-06 -8.18161523e-06 -1.50440111e-03] [-5.86997052e-06 -3.02892219e-07 -1.13607605e-02] [-3.52312036e-03  1.41453881e-02  9.99828068e-01]]Distance to lines in image 1 for LLS: 28.025662937533877Distance to lines in image 2 for LLS: 25.162875800036915p&#39;^T F p = 0.03156399064220228Fundamental Matrix from normalized 8-point algorithm: [[ 5.93261511e-07 -5.08492255e-06  8.76427688e-05] [-4.66834735e-06 -3.20108624e-07 -6.12207138e-03] [-7.74714403e-04  8.42028676e-03  1.25311400e-01]]Distance to lines in image 1 for normalized: 0.9431072572196602Distance to lines in image 2 for normalized: 0.8719800541568359--------------------------------------------------------------------------------Set: data/set2--------------------------------------------------------------------------------Fundamental Matrix from LLS  8-point algorithm: [[-5.63087200e-06  2.74976583e-05 -6.42650411e-03] [-2.77622828e-05 -6.74748522e-06  1.52182033e-02] [ 1.07623595e-02 -1.22519240e-02 -9.99730547e-01]]Distance to lines in image 1 for LLS: 9.701438829435915Distance to lines in image 2 for LLS: 14.568227190498229p&#39;^T F p = 0.03149037056281445Fundamental Matrix from normalized 8-point algorithm: [[-1.53880961e-07  2.46528633e-06 -1.57563630e-04] [ 3.50323566e-06  3.08159735e-07  6.82243058e-03] [ 2.42265054e-04 -8.27925885e-03 -4.08002117e-03]]Distance to lines in image 1 for normalized: 0.8955997529976532Distance to lines in image 2 for normalized: 0.8959928005846117</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ce26c6c5b0b7826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/23/CS231A-Homework-2-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6_Epipolar_Geomotry_2</title>
      <link>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/</link>
      <guid>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/</guid>
      <pubDate>Fri, 22 Jun 2018 02:38:18 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节许多问题没有看懂，o(╥﹏╥)o&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquo
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><blockquote><p>本章节许多问题没有看懂，o(╥﹏╥)o</p></blockquote><hr><blockquote><p>主题： 图片校正 Image Rectification</p></blockquote><p>#1 问题</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8cc0457621c6e56b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>两个图片平行的问题<ul><li>无旋转 R = I</li><li>平移： 假设在x 轴上平移</li></ul></li></ul><p>那么 本质矩阵为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-208521e7cc7aff33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算极线的方向：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a2d105ea0a781cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="="></p><p>可知，两张图片的极线是水平的；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9b6f663493447819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得知，两点是共享同一个坐标轴 v的；</p><h1 id="2-Rectification-making-two-images-“parallel”"><a href="#2-Rectification-making-two-images-“parallel”" class="headerlink" title="2  Rectification:    making    two    images    “parallel”"></a>2  Rectification:    making    two    images    “parallel”</h1><ul><li>平行图片的优点</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b726092d63e282c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-1-三角化"><a href="#2-1-三角化" class="headerlink" title="2.1 三角化"></a>2.1 三角化</h2><ul><li>point triangulation</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-38908e5c54eec044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>距离计算<br><img src="https://upload-images.jianshu.io/upload_images/5361608-71094389014fe2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-862088c7ad288ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-对应性问题"><a href="#2-2-对应性问题" class="headerlink" title="2.2 对应性问题"></a>2.2 对应性问题</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97cac06011167479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c61637121427c095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-2-1-对应性方法"><a href="#2-2-1-对应性方法" class="headerlink" title="2.2.1 对应性方法"></a>2.2.1 对应性方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/5361608-caa07270e4d57480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>两个图片共享v轴，只在u轴上变化；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a26a241aae147875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这种方法造成强度的改变；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5ef88878c2c0ff5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>窗口大小不同的结果为；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-24873393b76fdbc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>存在四个不同的问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-11b0d26911a7843d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-364455beb480ae7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6359e1f4480583c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-063b28dd23947fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9d707c9d5df7a41f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-9baeaa8d9a32d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="3-校正两张图片"><a href="#3-校正两张图片" class="headerlink" title="3 校正两张图片"></a>3 校正两张图片</h2><p> 校正两个图片不需要就知道相机的内参K和外参矩阵R,T，只需要通过基础矩阵计算极线；<br>然后计算所以极线的交点—极点；由于噪点的干扰，不可能交于一点，因此计算极点，利用最小二乘方法求得极线拟合一点；<br>并且在极线上的每一点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-70ef22c82e308bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果定义极线集合：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2ad1cd071a0b7c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-80295e9834fc1d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因此整个步骤为：</p><ul><li><ol><li>通过归一化8点算法获取基本矩阵</li></ol></li><li><ol start="2"><li>极线交于极点： 通过最小二乘误差拟合</li></ol></li><li><ol start="3"><li>svd计算 极点</li></ol></li></ul><hr><blockquote><p>在求得极点e,e’后，如果极点在水平方向上不是无限的，说明图片没有平行，如果点是无限的，说明图片平行了；</p></blockquote><p>因此，我们的目的：</p><ul><li><strong>寻找一对单应性矩阵H1,H2,使得极点无穷，即两张图片平行；</strong></li></ul><hr><p>(1). <strong>寻找H2：令e’在水平方向上无限,即为点（f,0,0）</strong></p><ul><li>将第二幅图的中心移动到(0,0,1)在齐次坐标系下；<br>这个平移矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f15f7e8f6c1d82a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>应用一个旋转矩阵：使极点坐标旋转到水平坐标轴上，变为(f, 0, 1)</strong></p><ul><li>如果e‘在平移后Te’的坐标为：(e1’,e2’,1)，旋转矩阵为：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2b8848d72443787d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-33ebdcfefbcfc87e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(3). <strong>将极点坐标由(f,0,1)==&gt;(f,0,0)</strong></p><ul><li>只需要变换矩阵：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4cf916086e001850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>经过上面几个步骤。我们可以得到无限极点：这个单应性变换H2为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-eceae870c337bd04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><ul><li><strong>为了寻找单应性矩阵H1,,需要最小化两个图片对应点的均方差之和来获得H1</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ebe437f9682f42c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求导后，可以得到：</p><p>!<img src="https://upload-images.jianshu.io/upload_images/5361608-dffe23f713cf43f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>计算式子中的未知参数：</p><p>(1). <strong>首先计算M</strong></p><ul><li><p>任意3*3的斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3ca1aac7031b398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>因为任何向量的叉积矩阵 是一个斜对称矩阵：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58e56509b18c3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图，a向量的叉乘矩阵为斜对称矩阵；</p><p>因此，前面公式中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e933426be143035d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>合并后，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-cb430c0d0009a532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果M每一列缩放e，则F也需要变化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c2760d1d20996d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b8d6728c7d829f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>(2). <strong>计算Ha矩阵中的参数a</strong></p><ul><li>已经知道了H2, M，如果将图片1中的点p变换到图片2中，然后经过H2变换：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d3dd8c3950e7c971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b26168a6bf4b3003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这两个点应该是最近点，然后使用最小二乘发来最小化误差：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c45f913af4b55069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设两个点齐次坐标为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-c7c39a32c60e82ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最小化式子为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-03f84d774d3fede2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为最后一项两个点在水平线上，则为常数</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2548833df47c882f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终，这个问题变成了解决最小二乘问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-dd8f6953623efa08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4b3993661018b687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>求得a的参数后，得到了HA,H2,M三个矩阵，根据上面的式子：<br>最终可以求得H1；</p>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/6-Epipolar-Geomotry-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3_Single_View_Metrology</title>
      <link>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/</link>
      <guid>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/</guid>
      <pubDate>Fri, 22 Jun 2018 02:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-2d中的变换&quot;&gt;&lt;a href=&quot;#1-2d中的变换&quot; class=&quot;headerlink&quot; title=&quot;1  2
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><h1 id="1-2d中的变换"><a href="#1-2d中的变换" class="headerlink" title="1  2d中的变换"></a>1  2d中的变换</h1><h2 id="1-1-几何变换"><a href="#1-1-几何变换" class="headerlink" title="1.1 几何变换"></a>1.1 几何变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-4293a9fb6318994b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-相似变换"><a href="#1-2-相似变换" class="headerlink" title="1.2 相似变换"></a>1.2 相似变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0b1c1de2d8270f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-仿射变换"><a href="#1-3-仿射变换" class="headerlink" title="1.3 仿射变换"></a>1.3 仿射变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1e1629e3eaf9aec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-4-投影变换"><a href="#1-4-投影变换" class="headerlink" title="1.4 投影变换"></a>1.4 投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-1a1297c41268f109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>投影变换4个共线点的交叉率：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2d65709b5e37222b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h1 id="2-vanishing-points-and-lines-灭点"><a href="#2-vanishing-points-and-lines-灭点" class="headerlink" title="2 vanishing points and lines (灭点)"></a>2 vanishing points and lines (灭点)</h1><h2 id="2-1-无穷点"><a href="#2-1-无穷点" class="headerlink" title="2.1 无穷点"></a>2.1 无穷点</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ed0a8848567585d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于两条直线的交点：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-033b9e87e41a0f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但是，如果两条平行直线的交点，在齐次坐标系进行计算：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5d1a8ee50373adf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在欧氏坐标系下， 这个点是无穷的；</li><li>两条线段的交点也是无穷的；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-ffddc1e05ba0b6f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-2-无穷线"><a href="#2-2-无穷线" class="headerlink" title="2.2 无穷线"></a>2.2 无穷线</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0fa9ecc24c3b48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-3-无穷点的投影变换"><a href="#2-3-无穷点的投影变换" class="headerlink" title="2.3 无穷点的投影变换"></a>2.3 无穷点的投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-42a7f1de720f48a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-4-无穷线的投影变换"><a href="#2-4-无穷线的投影变换" class="headerlink" title="2.4 无穷线的投影变换"></a>2.4 无穷线的投影变换</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b58b22ded0124c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-3d中的点和面"><a href="#3-3d中的点和面" class="headerlink" title="3 3d中的点和面"></a>3 3d中的点和面</h1><ul><li><p>点<br><img src="https://upload-images.jianshu.io/upload_images/5361608-df33547dc5b37f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>线段<br><img src="https://upload-images.jianshu.io/upload_images/5361608-1a498638def1cfff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h2 id="3-1-3d中的无穷点"><a href="#3-1-3d中的无穷点" class="headerlink" title="3.1 3d中的无穷点"></a>3.1 3d中的无穷点</h2><p><img src="https://upload-images.jianshu.io/upload_images/5361608-81e985560c732f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-2-vanishing-points"><a href="#3-2-vanishing-points" class="headerlink" title="3.2 vanishing points"></a>3.2 vanishing points</h2><p>无穷点的投影变换不在是无穷的；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-01071f0955aeb371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>给定一个相机参数K,R,T,得到灭点：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-ccbc7da86c7231c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义一个平行线的超集为一个平面，每对平行线的交点都是无穷点，这些无穷点组成的线段就是无穷线，这个平面的无穷线经过投影变换<code>H</code>后不再是无穷的，被称为<code>vanishing line 或者 horizon line</code>，可以通过以下计算：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0346133f45da09b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例如：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-19aabed436274ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>橙色的是水平线，两个铁轨的交点在水平线，那么这两条铁轨就是水平线；</li></ul><h2 id="3-3-面"><a href="#3-3-面" class="headerlink" title="3.3 面"></a>3.3 面</h2><p>通过3d的平面法线n和对应的水平线，可以得到以下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f823386978ec4821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/5361608-f85ca24a96846ad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>如果相机的参数已知晓，那么可以得到水平线相关的平面的方向；</li></ul><h2 id="3-4-无穷面"><a href="#3-4-无穷面" class="headerlink" title="3.4 无穷面"></a>3.4 无穷面</h2><ul><li>定义：2个或多个无穷线组成的平面</li><li>在齐次坐标系下用<code>[0 0 0 1]T</code>表示</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a38031e839a04718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设两对平行线的灭点为v1,v2, 平行线的方向分别为d1,d2，那么这两个方向的夹角为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-3f0fee0cbccdce69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-344f019d6232aca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f0888390d19d82e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以同时扩展到平面：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-e388a2ec9b5c1e0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-5-投影变换-总结"><a href="#3-5-投影变换-总结" class="headerlink" title="3.5  投影变换 总结"></a>3.5  投影变换 总结</h2><ul><li>使用投影变换，可以将无穷点投影为灭点；</li><li>无穷线投影为水平线；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-4d2c94fdc767a451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2af4fad907d2ad90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-e5c3d841693d5796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/3-Single-Vew-Metrology/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4_Camera_Calibration</title>
      <link>https://jingxa.github.io/2018/06/22/4-Camera-Calibration/</link>
      <guid>https://jingxa.github.io/2018/06/22/4-Camera-Calibration/</guid>
      <pubDate>Fri, 22 Jun 2018 02:33:29 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-单视图校准&quot;&gt;&lt;a href=&quot;#1-单视图校准&quot; class=&quot;headerlink&quot; title=&quot;1 单视图校
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><h1 id="1-单视图校准"><a href="#1-单视图校准" class="headerlink" title="1 单视图校准"></a>1 单视图校准</h1><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f62ca01593756407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>回忆一下，相机参数有5个自由度；<br><img src="https://upload-images.jianshu.io/upload_images/5361608-e93f7fea43d1c564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>w 为：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-b1780f2198be53b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>假设2,3 条件为真，那么w为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2193d397907e4109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这样就剩下了四个变量；</li><li>只需要三对方程就可以求得变量；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5eb9d77e6a71dd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-82a9d2ce14a6c8d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-25e8a60c165779cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/4-Camera-Calibration/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5_Epiplolar_Geometry</title>
      <link>https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/</link>
      <guid>https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/</guid>
      <pubDate>Fri, 22 Jun 2018 02:29:25 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;CS231A笔记&lt;br&gt;文章截图大多来自斯坦福CS231A课程;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1 基本概念&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>CS231A笔记<br>文章截图大多来自斯坦福CS231A课程;</p></blockquote><hr><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><ul><li><p>相机的旋转矩阵： 正交矩阵</p></li><li><p>极点</p></li><li>极线</li><li><p>极平面</p></li><li><p>【推荐文章】：  <a href="http://www.cnblogs.com/clarenceliang/p/6704970.html" target="_blank" rel="noopener">对极几何（Epipolar Geometry）</a></p></li><li><p>叉乘：两个向量的叉乘可以由一个向量的斜对称矩阵和另一向量的积；</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-58e56509b18c3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><ul><li>前向平移—极点都处于同一位置</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-d9608d848346057d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-2-本质矩阵"><a href="#1-2-本质矩阵" class="headerlink" title="1.2 本质矩阵"></a>1.2 本质矩阵</h2><ul><li>相机是 标准相机：K = I</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-24fd49f34c17ed5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-26aa928ebfa621b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由图中可以看出，p经过变换得到p’:<br><img src="https://latex.codecogs.com/gif.latex?p%5E%7B%27%7D%20%3D%20R%5Ccdot%20p&plus;T" alt=""><br>得到：<br><img src="https://latex.codecogs.com/gif.latex?p%20%3D%20R%5E%7BT%7D%5Ccdot%20p%5E%7B%27%7D-%20R%5E%7BT%7DT" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-87f31eed4df5757f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-370b7b6e60cc5083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-7a99b066db36db54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过叉乘：可以将上个式子变成：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-dd94d10de2b0d6f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>定义：<br><img src="https://upload-images.jianshu.io/upload_images/5361608-a818cd6296f89153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>为本质矩阵（The Essential Matrix）：</p><blockquote><ul><li>3*3的矩阵；</li><li>自由度： 5（3:Rotation 2:translation）</li><li>rank : 2 ,奇异矩阵</li></ul></blockquote><blockquote><p>用处</p></blockquote><ol><li>计算p 和 p’的极线</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5e374ad4ee35899c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>表示：p被E投射到 第二幅图像上的极线l’上；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3a66b112ca5c0e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>表示：p’被E投射到 第一幅图像上的极线l上；</p><ol start="2"><li>极点和矩阵的联系</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-320355b22790387f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="1-3-基本矩阵（Fundamental-Matrix）"><a href="#1-3-基本矩阵（Fundamental-Matrix）" class="headerlink" title="1.3 基本矩阵（Fundamental Matrix）"></a>1.3 基本矩阵（Fundamental Matrix）</h2><ul><li>相机是非标准的；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-26aa928ebfa621b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>对应两个相机，两个相机的投影矩阵为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-8e5e3e236a54d742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义<del>世界坐标系</del>  相机坐标系中的点P在两个位置的相机图片上的投影为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-539a4452776e48a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-f33b5f801b31ac0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据本质矩阵得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a1656321484f80b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>推导出，两个相机的位置变换：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-2687edf23d78b80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-0593f0f9af9f79b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>F就被称为： <code>基本矩阵</code></p><blockquote><ul><li>3* 3 矩阵</li><li>奇异矩阵  Rank :2</li><li>包含R, T；</li><li>包含 相机参数 K,K’</li><li>自由度 ： 7 ()</li></ul></blockquote><blockquote><p>用处<br> 基本矩阵已知，已知一张图片上一点和另一张图片上的对应点， 就可以求出p和p’的对应关系；</p></blockquote><p>#2  THE Eight-Point 算法</p><h2 id="2-1-八点算法"><a href="#2-1-八点算法" class="headerlink" title="2.1 八点算法"></a>2.1 八点算法</h2><ul><li>给予两张图片，没有相机内外参数；</li><li><p>求出基本矩阵</p></li><li><p>方法： ‘<em>Eight-Point 算法</em> ‘</p></li></ul><hr><ol><li>至少8对 对应点</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5361608-750407be55d3a189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>则每队对对应点满足：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-39605f51776577d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>即：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-b2ab3e15ad77b5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>展开，可以得到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-321f94cfacb01aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于所有对应点，使用一下公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-3c3ec40ba81b3477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>简写为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-5766d9a159915312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>W ： N*9 矩阵 ， N: 对应对的数量</li><li>f: 基本矩阵</li></ul><hr><ul><li>使用svd分解</li><li>w: 非满秩的</li><li>f: 真实的基本矩阵秩为2 </li><li>#<a href="https://blog.csdn.net/kokerf/article/details/72630863?locationNum=2&amp;fps=1" target="_blank" rel="noopener">基本矩阵的基本解法之8点算法</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-67d92e80c6b464f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="3-2-Normalized-Eight-Point算法"><a href="#3-2-Normalized-Eight-Point算法" class="headerlink" title="3.2 Normalized Eight-Point算法"></a>3.2 Normalized Eight-Point算法</h2><p>标准的8点算法存在的问题：</p><ul><li>p点， 和通过基本矩阵将点p’映射到的极线上l= Fp’，两者的距离很大；点和极线之间的均值误差如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-091b3647c850b792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>8个对应点组成的矩阵W： 最好只有一个奇异值为0或者近似为0,其他的都为非零；这样能够使得svd效果好；</li><li>像素值的范围过大；如pi = (1832; 1023;)</li></ul><hr><p>解决方法：</p><ul><li>归一化像素点<ul><li><ol><li>新坐标系的原点应该位于图像点的质心处（平移）；<br>表示为：</li></ol></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-6349e1ccc32f9d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>其次，变换后的图像点距原点的均方距离应为2像素（缩放）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5361608-a06c93ec30ac32aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图所示，</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-446adabfc4846b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后用新坐标系下的图像应用8点算法计算出Fq；</p><p><img src="https://upload-images.jianshu.io/upload_images/5361608-97bf6c2a7e7c0064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后通过反归一化，获得真实的基本矩阵；</p><hr>]]></content:encoded>
      
      <comments>https://jingxa.github.io/2018/06/22/5-Epiplolar-Geometry/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
